<html>
<head>
<title>vengine_cpy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vengine_cpy.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># DEPRECATED: implementation for ffi.verify()</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">sys</span><span class="s3">, </span><span class="s1">imp</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">model</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">error </span><span class="s2">import </span><span class="s1">VerificationError</span>


<span class="s2">class </span><span class="s1">VCPythonEngine</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s1">_class_key </span><span class="s3">= </span><span class="s4">'x'</span>
    <span class="s1">_gen_python_module </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">verifier</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">verifier </span><span class="s3">= </span><span class="s1">verifier</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi </span><span class="s3">= </span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">ffi</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_types_of_builtin_functions </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">patch_extension_kwds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">so_suffixes</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">f</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">descr </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">path</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">f </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s0"># Note that after a setuptools installation, there are both .py</span>
        <span class="s0"># and .so files with the same basename.  The code here relies on</span>
        <span class="s0"># imp.find_module() locating the .so in priority.</span>
        <span class="s2">if </span><span class="s1">descr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">not in </span><span class="s1">so_suffixes</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">collect_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate</span><span class="s3">(</span><span class="s4">&quot;collecttype&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_prnt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">what</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">what </span><span class="s3">+ </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
        <span class="s0"># a KeyError here is a bug.  please report it! :-)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict</span><span class="s3">[</span><span class="s1">type</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">((</span><span class="s2">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">)</span>
             <span class="s2">or </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">'long double'</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">tp </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict</span><span class="s3">):</span>
            <span class="s1">num </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">] = </span><span class="s1">num</span>

    <span class="s2">def </span><span class="s1">write_source_to_f</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">collect_types</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s0"># The new module will have a _cffi_setup() function that receives</span>
        <span class="s0"># objects from the ffi world, and that calls some setup code in</span>
        <span class="s0"># the module.  This setup code is split in several independent</span>
        <span class="s0"># functions, e.g. one per constant.  The functions are &quot;chained&quot;</span>
        <span class="s0"># by ending in a tail call to each other.</span>
        <span class="s0">#</span>
        <span class="s0"># This is further split in two chained lists, depending on if we</span>
        <span class="s0"># can do it at import-time or if we must wait for _cffi_setup() to</span>
        <span class="s0"># provide us with the &lt;ctype&gt; objects.  This is needed because we</span>
        <span class="s0"># need the values of the enum constants in order to build the</span>
        <span class="s0"># &lt;ctype 'enum'&gt; that we may have to pass to _cffi_setup().</span>
        <span class="s0">#</span>
        <span class="s0"># The following two 'chained_list_constants' items contains</span>
        <span class="s0"># the head of these two chained lists, as a string that gives the</span>
        <span class="s0"># call to do, if any.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants </span><span class="s3">= [</span><span class="s4">'((void)lib,0)'</span><span class="s3">, </span><span class="s4">'((void)lib,0)'</span><span class="s3">]</span>
        <span class="s0">#</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s0"># first paste some standard set of lines that are mostly '#define'</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s1">cffimod_header</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0"># then paste the C source given by the user, verbatim.</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">preamble</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s0"># call generate_cpy_xxx_decl(), for every xxx found from</span>
        <span class="s0"># ffi._parser._declarations.  This generates all the functions.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate</span><span class="s3">(</span><span class="s4">&quot;decl&quot;</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># implement the function _cffi_setup_custom() as calling the</span>
        <span class="s0"># head of the chained list.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_setup_custom</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s0"># produce the method table, including the entries for the</span>
        <span class="s0"># generated Python-&gt;C function wrappers, which are done</span>
        <span class="s0"># by generate_cpy_function_method().</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static PyMethodDef _cffi_methods[] = {'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate</span><span class="s3">(</span><span class="s4">&quot;method&quot;</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  {&quot;_cffi_setup&quot;, _cffi_setup, METH_VARARGS, NULL},'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  {NULL, NULL, 0, NULL}    /* Sentinel */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'};'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s0"># standard init.</span>
        <span class="s1">modname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">get_module_name</span><span class="s3">()</span>
        <span class="s1">constants </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s2">False</span><span class="s3">]</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'#if PY_MAJOR_VERSION &gt;= 3'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static struct PyModuleDef _cffi_module_def = {'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyModuleDef_HEAD_INIT,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  &quot;%s&quot;,' </span><span class="s3">% </span><span class="s1">modname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  NULL,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  -1,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  _cffi_methods,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  NULL, NULL, NULL, NULL'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'};'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'PyMODINIT_FUNC'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'PyInit_%s(void)' </span><span class="s3">% </span><span class="s1">modname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyObject *lib;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  lib = PyModule_Create(&amp;_cffi_module_def);'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (lib == NULL)'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return NULL;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (%s &lt; 0 || _cffi_init() &lt; 0) {' </span><span class="s3">% (</span><span class="s1">constants</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    Py_DECREF(lib);'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return NULL;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  }'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return lib;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'#else'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'PyMODINIT_FUNC'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'init%s(void)' </span><span class="s3">% </span><span class="s1">modname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyObject *lib;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  lib = Py_InitModule(&quot;%s&quot;, _cffi_methods);' </span><span class="s3">% </span><span class="s1">modname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (lib == NULL)'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (%s &lt; 0 || _cffi_init() &lt; 0)' </span><span class="s3">% (</span><span class="s1">constants</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'#endif'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">load_library</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># XXX review all usages of 'self' here!</span>
        <span class="s0"># import it as a new extension module</span>
        <span class="s1">imp</span><span class="s3">.</span><span class="s1">acquire_lock</span><span class="s3">()</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s4">&quot;getdlopenflags&quot;</span><span class="s3">):</span>
                <span class="s1">previous_flags </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">getdlopenflags</span><span class="s3">()</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s4">&quot;setdlopenflags&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">flags </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">sys</span><span class="s3">.</span><span class="s1">setdlopenflags</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>
                <span class="s1">module </span><span class="s3">= </span><span class="s1">imp</span><span class="s3">.</span><span class="s1">load_dynamic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">get_module_name</span><span class="s3">(),</span>
                                          <span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">modulefilename</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">error </span><span class="s3">= </span><span class="s4">&quot;importing %r: %s&quot; </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">modulefilename</span><span class="s3">, </span><span class="s1">e</span><span class="s3">)</span>
                <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span><span class="s1">error</span><span class="s3">)</span>
            <span class="s2">finally</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s4">&quot;setdlopenflags&quot;</span><span class="s3">):</span>
                    <span class="s1">sys</span><span class="s3">.</span><span class="s1">setdlopenflags</span><span class="s3">(</span><span class="s1">previous_flags</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">imp</span><span class="s3">.</span><span class="s1">release_lock</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s0"># call loading_cpy_struct() to get the struct layout inferred by</span>
        <span class="s0"># the C compiler</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_load</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">'loading'</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># the C code will need the &lt;ctype&gt; objects.  Collect them in</span>
        <span class="s0"># order in a list.</span>
        <span class="s1">revmapping </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">([(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)</span>
                           <span class="s2">for </span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">) </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_typesdict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()])</span>
        <span class="s1">lst </span><span class="s3">= [</span><span class="s1">revmapping</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">revmapping</span><span class="s3">))]</span>
        <span class="s1">lst </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">))</span>
        <span class="s0">#</span>
        <span class="s0"># build the FFILibrary class and instance and call _cffi_setup().</span>
        <span class="s0"># this will set up some fields like '_cffi_types', and only then</span>
        <span class="s0"># it will invoke the chained list of functions that will really</span>
        <span class="s0"># build (notably) the constant objects, as &lt;cdata&gt; if they are</span>
        <span class="s0"># pointers, and store them as attributes on the 'library' object.</span>
        <span class="s2">class </span><span class="s1">FFILibrary</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
            <span class="s1">_cffi_python_module </span><span class="s3">= </span><span class="s1">module</span>
            <span class="s1">_cffi_ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
            <span class="s1">_cffi_dir </span><span class="s3">= []</span>
            <span class="s2">def </span><span class="s1">__dir__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">FFILibrary</span><span class="s3">.</span><span class="s1">_cffi_dir </span><span class="s3">+ </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">)</span>
        <span class="s1">library </span><span class="s3">= </span><span class="s1">FFILibrary</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">module</span><span class="s3">.</span><span class="s1">_cffi_setup</span><span class="s3">(</span><span class="s1">lst</span><span class="s3">, </span><span class="s1">VerificationError</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
            <span class="s2">import </span><span class="s1">warnings</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;reimporting %r might overwrite older definitions&quot;</span>
                          <span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">get_module_name</span><span class="s3">()))</span>
        <span class="s0">#</span>
        <span class="s0"># finally, call the loaded_cpy_xxx() functions.  This will perform</span>
        <span class="s0"># the final adjustments, like copying the Python-&gt;C wrapper</span>
        <span class="s0"># functions from the module to the 'library' object, and setting</span>
        <span class="s0"># up the FFILibrary class with properties for the global C variables.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_load</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">'loaded'</span><span class="s3">, </span><span class="s1">library</span><span class="s3">=</span><span class="s1">library</span><span class="s3">)</span>
        <span class="s1">module</span><span class="s3">.</span><span class="s1">_cffi_original_ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
        <span class="s1">module</span><span class="s3">.</span><span class="s1">_cffi_types_of_builtin_funcs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_types_of_builtin_functions</span>
        <span class="s2">return </span><span class="s1">library</span>

    <span class="s2">def </span><span class="s1">_get_declarations</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">lst </span><span class="s3">= [(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">qual</span><span class="s3">)) </span><span class="s2">in</span>
                                <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_parser</span><span class="s3">.</span><span class="s1">_declarations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()]</span>
        <span class="s1">lst</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">lst</span>

    <span class="s2">def </span><span class="s1">_generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">step_name</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_declarations</span><span class="s3">():</span>
            <span class="s1">kind</span><span class="s3">, </span><span class="s1">realname </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">'_generate_cpy_%s_%s' </span><span class="s3">% (</span><span class="s1">kind</span><span class="s3">,</span>
                                                                <span class="s1">step_name</span><span class="s3">))</span>
            <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                    <span class="s4">&quot;not implemented in verify(): %r&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">realname</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">model</span><span class="s3">.</span><span class="s1">attach_exception_info</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">step_name</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_declarations</span><span class="s3">():</span>
            <span class="s1">kind</span><span class="s3">, </span><span class="s1">realname </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">'_%s_cpy_%s' </span><span class="s3">% (</span><span class="s1">step_name</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">))</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">realname</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">model</span><span class="s3">.</span><span class="s1">attach_exception_info</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_generate_nothing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_loaded_noop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s0"># ----------</span>

    <span class="s2">def </span><span class="s1">_convert_funcarg_to_c</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">fromvar</span><span class="s3">, </span><span class="s1">tovar</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">):</span>
        <span class="s1">extraarg </span><span class="s3">= </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">() </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">'_Bool'</span><span class="s3">:</span>
                <span class="s1">converter </span><span class="s3">= </span><span class="s4">'_cffi_to_c_int'</span>
                <span class="s1">extraarg </span><span class="s3">= </span><span class="s4">', %s' </span><span class="s3">% </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">converter </span><span class="s3">= </span><span class="s4">'(%s)_cffi_to_c_%s' </span><span class="s3">% (</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">''</span><span class="s3">),</span>
                                                   <span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">))</span>
            <span class="s1">errvalue </span><span class="s3">= </span><span class="s4">'-1'</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_convert_funcarg_to_c_ptr_or_array</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">fromvar</span><span class="s3">,</span>
                                                    <span class="s1">tovar</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, (</span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">)):</span>
            <span class="s0"># a struct (not a struct pointer) as a function argument</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  if (_cffi_to_c((char *)&amp;%s, _cffi_type(%d), %s) &lt; 0)'</span>
                      <span class="s3">% (</span><span class="s1">tovar</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">), </span><span class="s1">fromvar</span><span class="s3">))</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'    %s;' </span><span class="s3">% </span><span class="s1">errcode</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">):</span>
            <span class="s1">converter </span><span class="s3">= </span><span class="s4">'(%s)_cffi_to_c_pointer' </span><span class="s3">% </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
            <span class="s1">extraarg </span><span class="s3">= </span><span class="s4">', _cffi_type(%d)' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">errvalue </span><span class="s3">= </span><span class="s4">'NULL'</span>
        <span class="s0">#</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  %s = %s(%s%s);' </span><span class="s3">% (</span><span class="s1">tovar</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">, </span><span class="s1">fromvar</span><span class="s3">, </span><span class="s1">extraarg</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  if (%s == (%s)%s &amp;&amp; PyErr_Occurred())' </span><span class="s3">% (</span>
            <span class="s1">tovar</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">''</span><span class="s3">), </span><span class="s1">errvalue</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'    %s;' </span><span class="s3">% </span><span class="s1">errcode</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_extra_local_variables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">localvars</span><span class="s3">, </span><span class="s1">freelines</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">):</span>
            <span class="s1">localvars</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">'Py_ssize_t datasize'</span><span class="s3">)</span>
            <span class="s1">localvars</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">'struct _cffi_freeme_s *large_args_free = NULL'</span><span class="s3">)</span>
            <span class="s1">freelines</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s4">'if (large_args_free != NULL)'</span>
                          <span class="s4">' _cffi_free_array_arguments(large_args_free);'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_convert_funcarg_to_c_ptr_or_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">fromvar</span><span class="s3">, </span><span class="s1">tovar</span><span class="s3">, </span><span class="s1">errcode</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  datasize = _cffi_prepare_pointer_call_argument('</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'      _cffi_type(%d), %s, (char **)&amp;%s);' </span><span class="s3">% (</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">), </span><span class="s1">fromvar</span><span class="s3">, </span><span class="s1">tovar</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  if (datasize != 0) {'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'    %s = ((size_t)datasize) &lt;= 640 ? '</span>
                   <span class="s4">'alloca((size_t)datasize) : NULL;' </span><span class="s3">% (</span><span class="s1">tovar</span><span class="s3">,))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '</span>
                   <span class="s4">'(char **)&amp;%s,' </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">), </span><span class="s1">fromvar</span><span class="s3">, </span><span class="s1">tovar</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'            datasize, &amp;large_args_free) &lt; 0)'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'      %s;' </span><span class="s3">% </span><span class="s1">errcode</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  }'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_convert_expr_from_c</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">context</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">() </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">'_Bool'</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s4">'_cffi_from_c_int(%s, %s)' </span><span class="s3">% (</span><span class="s1">var</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s4">'long double'</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s4">'_cffi_from_c_%s(%s)' </span><span class="s3">% (</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">), </span><span class="s1">var</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s4">'_cffi_from_c_deref((char *)&amp;%s, _cffi_type(%d))' </span><span class="s3">% (</span>
                    <span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, (</span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s4">'_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' </span><span class="s3">% (</span>
                <span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">'_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' </span><span class="s3">% (</span>
                <span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;'%s' is used as %s, but is opaque&quot; </span><span class="s3">% (</span>
                    <span class="s1">tp</span><span class="s3">.</span><span class="s1">_get_c_name</span><span class="s3">(), </span><span class="s1">context</span><span class="s3">))</span>
            <span class="s2">return </span><span class="s4">'_cffi_from_c_struct((char *)&amp;%s, _cffi_type(%d))' </span><span class="s3">% (</span>
                <span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">'_cffi_from_c_deref((char *)&amp;%s, _cffi_type(%d))' </span><span class="s3">% (</span>
                <span class="s1">var</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_gettypenum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># typedefs: generates no code so far</span>

    <span class="s1">_generate_cpy_typedef_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_generate_cpy_typedef_decl   </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_generate_cpy_typedef_method </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_loading_cpy_typedef         </span><span class="s3">= </span><span class="s1">_loaded_noop</span>
    <span class="s1">_loaded_cpy_typedef          </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># function declarations</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_collecttype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># don't call _do_collect_type(tp) in this common case,</span>
            <span class="s0"># otherwise test_autofilled_struct_as_argument fails</span>
            <span class="s2">for </span><span class="s1">type </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">type</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s0"># cannot support vararg functions better than this: check for its</span>
            <span class="s0"># exact type (including the fixed arguments), and build it as a</span>
            <span class="s0"># constant function pointer (no CPython wrapper)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">numargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">numargs </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">argname </span><span class="s3">= </span><span class="s4">'noarg'</span>
        <span class="s2">elif </span><span class="s1">numargs </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">argname </span><span class="s3">= </span><span class="s4">'arg0'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">argname </span><span class="s3">= </span><span class="s4">'args'</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static PyObject *'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'_cffi_f_%s(PyObject *self, PyObject *%s)' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">argname</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s4">'argument of %s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s;' </span><span class="s3">% </span><span class="s1">type</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' x%d' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>
        <span class="s0">#</span>
        <span class="s1">localvars </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">freelines </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">type </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_extra_local_variables</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">localvars</span><span class="s3">, </span><span class="s1">freelines</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">decl </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">localvars</span><span class="s3">):</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s;' </span><span class="s3">% (</span><span class="s1">decl</span><span class="s3">,))</span>
        <span class="s0">#</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">):</span>
            <span class="s1">result_code </span><span class="s3">= </span><span class="s4">'result = '</span>
            <span class="s1">context </span><span class="s3">= </span><span class="s4">'result of %s' </span><span class="s3">% </span><span class="s1">name</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s;' </span><span class="s3">% </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' result'</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyObject *pyresult;'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result_code </span><span class="s3">= </span><span class="s4">''</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">rng </span><span class="s3">= </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rng</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyObject *arg%d;' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">()</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (!PyArg_ParseTuple(args, &quot;%s:%s&quot;, %s))' </span><span class="s3">% (</span>
                <span class="s4">'O' </span><span class="s3">* </span><span class="s1">numargs</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s4">'&amp;arg%d' </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rng</span><span class="s3">])))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return NULL;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_convert_funcarg_to_c</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s4">'arg%d' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">, </span><span class="s4">'x%d' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">,</span>
                                       <span class="s4">'return NULL'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  Py_BEGIN_ALLOW_THREADS'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  _cffi_restore_errno();'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  { %s%s(%s); }' </span><span class="s3">% (</span>
            <span class="s1">result_code</span><span class="s3">, </span><span class="s1">name</span><span class="s3">,</span>
            <span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s4">'x%d' </span><span class="s3">% </span><span class="s1">i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">))])))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  _cffi_save_errno();'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  Py_END_ALLOW_THREADS'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)self; /* unused */'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">numargs </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)noarg; /* unused */'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result_code</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  pyresult = %s;' </span><span class="s3">%</span>
                 <span class="s1">self</span><span class="s3">.</span><span class="s1">_convert_expr_from_c</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">, </span><span class="s4">'result'</span><span class="s3">, </span><span class="s4">'result type'</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">freeline </span><span class="s2">in </span><span class="s1">freelines</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  ' </span><span class="s3">+ </span><span class="s1">freeline</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return pyresult;'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">freeline </span><span class="s2">in </span><span class="s1">freelines</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  ' </span><span class="s3">+ </span><span class="s1">freeline</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  Py_INCREF(Py_None);'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return Py_None;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_function_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">numargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">numargs </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s4">'METH_NOARGS'</span>
        <span class="s2">elif </span><span class="s1">numargs </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s4">'METH_O'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">meth </span><span class="s3">= </span><span class="s4">'METH_VARARGS'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  {&quot;%s&quot;, _cffi_f_%s, %s, NULL},' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">))</span>

    <span class="s1">_loading_cpy_function </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">func</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_types_of_builtin_functions</span><span class="s3">[</span><span class="s1">func</span><span class="s3">] = </span><span class="s1">tp</span>

    <span class="s0"># ----------</span>
    <span class="s0"># named structs</span>

    <span class="s1">_generate_cpy_struct_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_struct_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">name </span><span class="s3">== </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'struct'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_struct_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'struct'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_loading_cpy_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'struct'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_loaded_cpy_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s1">_generate_cpy_union_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_union_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">name </span><span class="s3">== </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'union'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_generate_cpy_union_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'union'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_loading_cpy_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'union'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">_loaded_cpy_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">checkfuncname </span><span class="s3">= </span><span class="s4">'_cffi_check_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">layoutfuncname </span><span class="s3">= </span><span class="s4">'_cffi_layout_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">cname </span><span class="s3">= (</span><span class="s4">'%s %s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)).</span><span class="s1">strip</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static void %s(%s *p)' </span><span class="s3">% (</span><span class="s1">checkfuncname</span><span class="s3">, </span><span class="s1">cname</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* only to generate compile-time warnings or errors */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)p;'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()) </span><span class="s2">or </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s0"># accept all integers, but complain on float or double</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)((p-&gt;%s) &lt;&lt; 1);' </span><span class="s3">% </span><span class="s1">fname</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># only accept exactly the type declared.</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  { %s = &amp;p-&gt;%s; (void)tmp; }' </span><span class="s3">% (</span>
                        <span class="s1">ftype</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">'*tmp'</span><span class="s3">, </span><span class="s4">'field %r'</span><span class="s3">%</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">quals</span><span class="s3">=</span><span class="s1">fqual</span><span class="s3">),</span>
                        <span class="s1">fname</span><span class="s3">))</span>
                <span class="s2">except </span><span class="s1">VerificationError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* %s */' </span><span class="s3">% </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">))   </span><span class="s0"># cannot verify it, ignore</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static PyObject *'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'%s(PyObject *self, PyObject *noarg)' </span><span class="s3">% (</span><span class="s1">layoutfuncname</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  struct _cffi_aligncheck { char x; %s y; };' </span><span class="s3">% </span><span class="s1">cname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  static Py_ssize_t nums[] = {'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    sizeof(%s),' </span><span class="s3">% </span><span class="s1">cname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    offsetof(struct _cffi_aligncheck, y),'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">continue      </span><span class="s0"># xxx ignore fbitsize for now</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    offsetof(%s, %s),' </span><span class="s3">% (</span><span class="s1">cname</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">length </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    0,  /* %s */' </span><span class="s3">% </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">_get_c_name</span><span class="s3">())</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    sizeof(((%s *)0)-&gt;%s),' </span><span class="s3">% (</span><span class="s1">cname</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    -1'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  };'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)self; /* unused */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)noarg; /* unused */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return _cffi_get_struct_layout(nums);'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* the next line is not executed, but compiled */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s(0);' </span><span class="s3">% (</span><span class="s1">checkfuncname</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_generate_struct_or_union_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">layoutfuncname </span><span class="s3">= </span><span class="s4">'_cffi_layout_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span><span class="s3">(</span><span class="s4">'  {&quot;%s&quot;, %s, METH_NOARGS, NULL},' </span><span class="s3">% (</span><span class="s1">layoutfuncname</span><span class="s3">,</span>
                                                         <span class="s1">layoutfuncname</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">layoutfuncname </span><span class="s3">= </span><span class="s4">'_cffi_layout_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s1">function </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">layoutfuncname</span><span class="s3">)</span>
        <span class="s1">layout </span><span class="s3">= </span><span class="s1">function</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s0"># use the function()'s sizes and offsets to guide the</span>
            <span class="s0"># layout of the struct</span>
            <span class="s1">totalsize </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">totalalignment </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">fieldofs </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">2</span><span class="s3">::</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">fieldsize </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">3</span><span class="s3">::</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">force_flatten</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fieldofs</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fieldsize</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames</span><span class="s3">)</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">fixedlayout </span><span class="s3">= </span><span class="s1">fieldofs</span><span class="s3">, </span><span class="s1">fieldsize</span><span class="s3">, </span><span class="s1">totalsize</span><span class="s3">, </span><span class="s1">totalalignment</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cname </span><span class="s3">= (</span><span class="s4">'%s %s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)).</span><span class="s1">strip</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">] = </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">cname</span>

    <span class="s2">def </span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)   </span><span class="s0"># force 'fixedlayout' to be considered</span>

        <span class="s2">if </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">:</span>
            <span class="s0"># check that the layout sizes and offsets match the real ones</span>
            <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">realvalue</span><span class="s3">, </span><span class="s1">expectedvalue</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">realvalue </span><span class="s3">!= </span><span class="s1">expectedvalue</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                        <span class="s4">&quot;%s (we have %d, but C compiler says %d)&quot;</span>
                        <span class="s3">% (</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">expectedvalue</span><span class="s3">, </span><span class="s1">realvalue</span><span class="s3">))</span>
            <span class="s1">ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
            <span class="s1">BStruct </span><span class="s3">= </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">layout</span><span class="s3">, </span><span class="s1">cname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">), </span><span class="s4">&quot;wrong total size&quot;</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">alignof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">), </span><span class="s4">&quot;wrong total alignment&quot;</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">2</span>
            <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">continue        </span><span class="s0"># xxx ignore fbitsize for now</span>
                <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">offsetof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">),</span>
                      <span class="s4">&quot;wrong offset for field %r&quot; </span><span class="s3">% (</span><span class="s1">fname</span><span class="s3">,))</span>
                <span class="s2">if </span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">BField </span><span class="s3">= </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">)</span>
                    <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BField</span><span class="s3">),</span>
                          <span class="s4">&quot;wrong size for field %r&quot; </span><span class="s3">% (</span><span class="s1">fname</span><span class="s3">,))</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s5">2</span>
            <span class="s2">assert </span><span class="s1">i </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># 'anonymous' declarations.  These are produced for anonymous structs</span>
    <span class="s0"># or unions; the 'name' is obtained by a typedef.</span>

    <span class="s1">_generate_cpy_anonymous_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_anonymous_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_enum_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_anonymous_method</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loading_cpy_anonymous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_cpy_enum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_anonymous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_cpy_enum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># constants, likely declared with '#define'</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s4">'const'</span><span class="s3">,</span>
                            <span class="s1">vartp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">delayed</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">size_too</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                            <span class="s1">check_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_%s_%s' </span><span class="s3">% (</span><span class="s1">category</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static int %s(PyObject *lib)' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  PyObject *o;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  int res;'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">is_int</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s;' </span><span class="s3">% (</span><span class="s1">vartp </span><span class="s2">or </span><span class="s1">tp</span><span class="s3">).</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' i'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'const'</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">check_value </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">check_value</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s2">if not </span><span class="s1">is_int</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'var'</span><span class="s3">:</span>
                <span class="s1">realexpr </span><span class="s3">= </span><span class="s4">'&amp;' </span><span class="s3">+ </span><span class="s1">name</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">realexpr </span><span class="s3">= </span><span class="s1">name</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  i = (%s);' </span><span class="s3">% (</span><span class="s1">realexpr</span><span class="s3">,))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  o = %s;' </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_convert_expr_from_c</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'i'</span><span class="s3">,</span>
                                                          <span class="s4">'variable type'</span><span class="s3">),))</span>
            <span class="s2">assert </span><span class="s1">delayed</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  o = _cffi_from_c_int_const(%s);' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (o == NULL)'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return -1;'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">size_too</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  {'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    PyObject *o1 = o;'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    o = Py_BuildValue(&quot;On&quot;, o1, (Py_ssize_t)sizeof(%s));'</span>
                 <span class="s3">% (</span><span class="s1">name</span><span class="s3">,))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    Py_DECREF(o1);'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    if (o == NULL)'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'      return -1;'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  }'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  res = PyObject_SetAttrString(lib, &quot;%s&quot;, o);' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  Py_DECREF(o);'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if (res &lt; 0)'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return -1;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return %s;' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s1">delayed</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s1">delayed</span><span class="s3">] = </span><span class="s1">funcname </span><span class="s3">+ </span><span class="s4">'(lib)'</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_constant_collecttype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">is_int </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">is_int</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_constant_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">is_int </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s1">_generate_cpy_constant_method </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_loading_cpy_constant </span><span class="s3">= </span><span class="s1">_loaded_noop</span>
    <span class="s1">_loaded_cpy_constant  </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># enums</span>

    <span class="s2">def </span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">err_prefix</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if ((%s) &gt; 0 || (long)(%s) != %dL) {' </span><span class="s3">% (</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if ((%s) &lt;= 0 || (unsigned long)(%s) != %dUL) {' </span><span class="s3">% (</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    char buf[64];'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    if ((%s) &lt;= 0)' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'        snprintf(buf, 63, &quot;%%ld&quot;, (long)(%s));' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    else'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'        snprintf(buf, 63, &quot;%%lu&quot;, (unsigned long)(%s));' </span><span class="s3">%</span>
             <span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    PyErr_Format(_cffi_VerificationError,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'                 &quot;%s%s has the real value %s, not %s&quot;,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'                 &quot;%s&quot;, &quot;%s&quot;, buf, &quot;%d&quot;);' </span><span class="s3">% (</span>
            <span class="s1">err_prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return -1;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  }'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_enum_funcname</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s0"># &quot;$enum_$1&quot; =&gt; &quot;___D_enum____D_1&quot;</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'$'</span><span class="s3">, </span><span class="s4">'___D_'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s4">'_cffi_e_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_enum_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">=</span><span class="s4">'enum'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">delayed</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_enum_funcname</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static int %s(PyObject *lib)' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue</span><span class="s3">,</span>
                                           <span class="s4">&quot;enum %s: &quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return %s;' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s2">True</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s2">True</span><span class="s3">] = </span><span class="s1">funcname </span><span class="s3">+ </span><span class="s4">'(lib)'</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s1">_generate_cpy_enum_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_generate_cpy_enum_method </span><span class="s3">= </span><span class="s1">_generate_nothing</span>

    <span class="s2">def </span><span class="s1">_loading_cpy_enum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s1">enumvalues </span><span class="s3">= [</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">)</span>
                          <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">]</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">enumvalues</span><span class="s3">)</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">partial_resolved </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_enum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues</span><span class="s3">):</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># macros: for now only for integers</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_macro_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp </span><span class="s3">== </span><span class="s4">'...'</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s1">tp     </span><span class="s0"># an integer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">check_value</span><span class="s3">=</span><span class="s1">check_value</span><span class="s3">)</span>

    <span class="s1">_generate_cpy_macro_collecttype </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_generate_cpy_macro_method </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_loading_cpy_macro </span><span class="s3">= </span><span class="s1">_loaded_noop</span>
    <span class="s1">_loaded_cpy_macro  </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># global variables</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_variable_collecttype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_do_collect_type</span><span class="s3">(</span><span class="s1">tp_ptr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_cpy_variable_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">vartp</span><span class="s3">=</span><span class="s1">tp_ptr</span><span class="s3">,</span>
                                     <span class="s1">size_too </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length_is_unknown</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_cpy_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp_ptr</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s4">'var'</span><span class="s3">)</span>

    <span class="s1">_generate_cpy_variable_method </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_loading_cpy_variable </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_cpy_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):   </span><span class="s0"># int a[5] is &quot;constant&quot; in the</span>
                                              <span class="s0"># sense that &quot;a=...&quot; is forbidden</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length_is_unknown</span><span class="s3">():</span>
                <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)</span>
                <span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">size</span><span class="s3">) = </span><span class="s1">value</span>
                <span class="s1">BItemType </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
                <span class="s1">length</span><span class="s3">, </span><span class="s1">rest </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BItemType</span><span class="s3">))</span>
                <span class="s2">if </span><span class="s1">rest </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                        <span class="s4">&quot;bad size: %r does not seem to be an array of %s&quot; </span><span class="s3">%</span>
                        <span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">))</span>
                <span class="s1">tp </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">resolve_length</span><span class="s3">(</span><span class="s1">length</span><span class="s3">)</span>
            <span class="s0"># 'value' is a &lt;cdata 'type *'&gt; which we have to replace with</span>
            <span class="s0"># a &lt;cdata 'type[N]'&gt; if the N is actually known</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">BArray </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">BArray</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0"># remove ptr=&lt;cdata 'int *'&gt; from the library instance, and replace</span>
        <span class="s0"># it by a property on the class, which reads/writes into ptr[0].</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">value</span>
        <span class="s1">delattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">getter</span><span class="s3">(</span><span class="s1">library</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">ptr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">def </span><span class="s1">setter</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
            <span class="s1">ptr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">value</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">), </span><span class="s1">name</span><span class="s3">, </span><span class="s1">property</span><span class="s3">(</span><span class="s1">getter</span><span class="s3">, </span><span class="s1">setter</span><span class="s3">))</span>
        <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s0"># ----------</span>

    <span class="s2">def </span><span class="s1">_generate_setup_custom</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static int _cffi_setup_custom(PyObject *lib)'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return %s;' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_chained_list_constants</span><span class="s3">[</span><span class="s2">True</span><span class="s3">])</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>

<span class="s1">cffimod_header </span><span class="s3">= </span><span class="s4">r''' 
#include &lt;Python.h&gt; 
#include &lt;stddef.h&gt; 
 
/* this block of #ifs should be kept exactly identical between 
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py 
   and cffi/_cffi_include.h */ 
#if defined(_MSC_VER) 
# include &lt;malloc.h&gt;   /* for alloca() */ 
# if _MSC_VER &lt; 1600   /* MSVC &lt; 2010 */ 
   typedef __int8 int8_t; 
   typedef __int16 int16_t; 
   typedef __int32 int32_t; 
   typedef __int64 int64_t; 
   typedef unsigned __int8 uint8_t; 
   typedef unsigned __int16 uint16_t; 
   typedef unsigned __int32 uint32_t; 
   typedef unsigned __int64 uint64_t; 
   typedef __int8 int_least8_t; 
   typedef __int16 int_least16_t; 
   typedef __int32 int_least32_t; 
   typedef __int64 int_least64_t; 
   typedef unsigned __int8 uint_least8_t; 
   typedef unsigned __int16 uint_least16_t; 
   typedef unsigned __int32 uint_least32_t; 
   typedef unsigned __int64 uint_least64_t; 
   typedef __int8 int_fast8_t; 
   typedef __int16 int_fast16_t; 
   typedef __int32 int_fast32_t; 
   typedef __int64 int_fast64_t; 
   typedef unsigned __int8 uint_fast8_t; 
   typedef unsigned __int16 uint_fast16_t; 
   typedef unsigned __int32 uint_fast32_t; 
   typedef unsigned __int64 uint_fast64_t; 
   typedef __int64 intmax_t; 
   typedef unsigned __int64 uintmax_t; 
# else 
#  include &lt;stdint.h&gt; 
# endif 
# if _MSC_VER &lt; 1800   /* MSVC &lt; 2013 */ 
#  ifndef __cplusplus 
    typedef unsigned char _Bool; 
#  endif 
# endif 
#else 
# include &lt;stdint.h&gt; 
# if (defined (__SVR4) &amp;&amp; defined (__sun)) || defined(_AIX) || defined(__hpux) 
#  include &lt;alloca.h&gt; 
# endif 
#endif 
 
#if PY_MAJOR_VERSION &lt; 3 
# undef PyCapsule_CheckExact 
# undef PyCapsule_GetPointer 
# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule)) 
# define PyCapsule_GetPointer(capsule, name) \ 
    (PyCObject_AsVoidPtr(capsule)) 
#endif 
 
#if PY_MAJOR_VERSION &gt;= 3 
# define PyInt_FromLong PyLong_FromLong 
#endif 
 
#define _cffi_from_c_double PyFloat_FromDouble 
#define _cffi_from_c_float PyFloat_FromDouble 
#define _cffi_from_c_long PyInt_FromLong 
#define _cffi_from_c_ulong PyLong_FromUnsignedLong 
#define _cffi_from_c_longlong PyLong_FromLongLong 
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong 
#define _cffi_from_c__Bool PyBool_FromLong 
 
#define _cffi_to_c_double PyFloat_AsDouble 
#define _cffi_to_c_float PyFloat_AsDouble 
 
#define _cffi_from_c_int_const(x)                                        \ 
    (((x) &gt; 0) ?                                                         \ 
        ((unsigned long long)(x) &lt;= (unsigned long long)LONG_MAX) ?      \ 
            PyInt_FromLong((long)(x)) :                                  \ 
            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \ 
        ((long long)(x) &gt;= (long long)LONG_MIN) ?                        \ 
            PyInt_FromLong((long)(x)) :                                  \ 
            PyLong_FromLongLong((long long)(x))) 
 
#define _cffi_from_c_int(x, type)                                        \ 
    (((type)-1) &gt; 0 ? /* unsigned */                                     \ 
        (sizeof(type) &lt; sizeof(long) ?                                   \ 
            PyInt_FromLong((long)x) :                                    \ 
         sizeof(type) == sizeof(long) ?                                  \ 
            PyLong_FromUnsignedLong((unsigned long)x) :                  \ 
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \ 
        (sizeof(type) &lt;= sizeof(long) ?                                  \ 
            PyInt_FromLong((long)x) :                                    \ 
            PyLong_FromLongLong((long long)x))) 
 
#define _cffi_to_c_int(o, type)                                          \ 
    ((type)(                                                             \ 
     sizeof(type) == 1 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u8(o)        \ 
                                         : (type)_cffi_to_c_i8(o)) :     \ 
     sizeof(type) == 2 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u16(o)       \ 
                                         : (type)_cffi_to_c_i16(o)) :    \ 
     sizeof(type) == 4 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u32(o)       \ 
                                         : (type)_cffi_to_c_i32(o)) :    \ 
     sizeof(type) == 8 ? (((type)-1) &gt; 0 ? (type)_cffi_to_c_u64(o)       \ 
                                         : (type)_cffi_to_c_i64(o)) :    \ 
     (Py_FatalError(&quot;unsupported size for type &quot; #type), (type)0))) 
 
#define _cffi_to_c_i8                                                    \ 
                 ((int(*)(PyObject *))_cffi_exports[1]) 
#define _cffi_to_c_u8                                                    \ 
                 ((int(*)(PyObject *))_cffi_exports[2]) 
#define _cffi_to_c_i16                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[3]) 
#define _cffi_to_c_u16                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[4]) 
#define _cffi_to_c_i32                                                   \ 
                 ((int(*)(PyObject *))_cffi_exports[5]) 
#define _cffi_to_c_u32                                                   \ 
                 ((unsigned int(*)(PyObject *))_cffi_exports[6]) 
#define _cffi_to_c_i64                                                   \ 
                 ((long long(*)(PyObject *))_cffi_exports[7]) 
#define _cffi_to_c_u64                                                   \ 
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8]) 
#define _cffi_to_c_char                                                  \ 
                 ((int(*)(PyObject *))_cffi_exports[9]) 
#define _cffi_from_c_pointer                                             \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10]) 
#define _cffi_to_c_pointer                                               \ 
    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11]) 
#define _cffi_get_struct_layout                                          \ 
    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12]) 
#define _cffi_restore_errno                                              \ 
    ((void(*)(void))_cffi_exports[13]) 
#define _cffi_save_errno                                                 \ 
    ((void(*)(void))_cffi_exports[14]) 
#define _cffi_from_c_char                                                \ 
    ((PyObject *(*)(char))_cffi_exports[15]) 
#define _cffi_from_c_deref                                               \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16]) 
#define _cffi_to_c                                                       \ 
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17]) 
#define _cffi_from_c_struct                                              \ 
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18]) 
#define _cffi_to_c_wchar_t                                               \ 
    ((wchar_t(*)(PyObject *))_cffi_exports[19]) 
#define _cffi_from_c_wchar_t                                             \ 
    ((PyObject *(*)(wchar_t))_cffi_exports[20]) 
#define _cffi_to_c_long_double                                           \ 
    ((long double(*)(PyObject *))_cffi_exports[21]) 
#define _cffi_to_c__Bool                                                 \ 
    ((_Bool(*)(PyObject *))_cffi_exports[22]) 
#define _cffi_prepare_pointer_call_argument                              \ 
    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23]) 
#define _cffi_convert_array_from_object                                  \ 
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24]) 
#define _CFFI_NUM_EXPORTS 25 
 
typedef struct _ctypedescr CTypeDescrObject; 
 
static void *_cffi_exports[_CFFI_NUM_EXPORTS]; 
static PyObject *_cffi_types, *_cffi_VerificationError; 
 
static int _cffi_setup_custom(PyObject *lib);   /* forward */ 
 
static PyObject *_cffi_setup(PyObject *self, PyObject *args) 
{ 
    PyObject *library; 
    int was_alive = (_cffi_types != NULL); 
    (void)self; /* unused */ 
    if (!PyArg_ParseTuple(args, &quot;OOO&quot;, &amp;_cffi_types, &amp;_cffi_VerificationError, 
                                       &amp;library)) 
        return NULL; 
    Py_INCREF(_cffi_types); 
    Py_INCREF(_cffi_VerificationError); 
    if (_cffi_setup_custom(library) &lt; 0) 
        return NULL; 
    return PyBool_FromLong(was_alive); 
} 
 
union _cffi_union_alignment_u { 
    unsigned char m_char; 
    unsigned short m_short; 
    unsigned int m_int; 
    unsigned long m_long; 
    unsigned long long m_longlong; 
    float m_float; 
    double m_double; 
    long double m_longdouble; 
}; 
 
struct _cffi_freeme_s { 
    struct _cffi_freeme_s *next; 
    union _cffi_union_alignment_u alignment; 
}; 
 
#ifdef __GNUC__ 
  __attribute__((unused)) 
#endif 
static int _cffi_convert_array_argument(CTypeDescrObject *ctptr, PyObject *arg, 
                                        char **output_data, Py_ssize_t datasize, 
                                        struct _cffi_freeme_s **freeme) 
{ 
    char *p; 
    if (datasize &lt; 0) 
        return -1; 
 
    p = *output_data; 
    if (p == NULL) { 
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc( 
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize); 
        if (fp == NULL) 
            return -1; 
        fp-&gt;next = *freeme; 
        *freeme = fp; 
        p = *output_data = (char *)&amp;fp-&gt;alignment; 
    } 
    memset((void *)p, 0, (size_t)datasize); 
    return _cffi_convert_array_from_object(p, ctptr, arg); 
} 
 
#ifdef __GNUC__ 
  __attribute__((unused)) 
#endif 
static void _cffi_free_array_arguments(struct _cffi_freeme_s *freeme) 
{ 
    do { 
        void *p = (void *)freeme; 
        freeme = freeme-&gt;next; 
        PyObject_Free(p); 
    } while (freeme != NULL); 
} 
 
static int _cffi_init(void) 
{ 
    PyObject *module, *c_api_object = NULL; 
 
    module = PyImport_ImportModule(&quot;_cffi_backend&quot;); 
    if (module == NULL) 
        goto failure; 
 
    c_api_object = PyObject_GetAttrString(module, &quot;_C_API&quot;); 
    if (c_api_object == NULL) 
        goto failure; 
    if (!PyCapsule_CheckExact(c_api_object)) { 
        PyErr_SetNone(PyExc_ImportError); 
        goto failure; 
    } 
    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, &quot;cffi&quot;), 
           _CFFI_NUM_EXPORTS * sizeof(void *)); 
 
    Py_DECREF(module); 
    Py_DECREF(c_api_object); 
    return 0; 
 
  failure: 
    Py_XDECREF(module); 
    Py_XDECREF(c_api_object); 
    return -1; 
} 
 
#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num)) 
 
/**********/ 
'''</span>
</pre>
</body>
</html>