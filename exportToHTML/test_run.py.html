<html>
<head>
<title>test_run.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_run.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextvars</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">ExitStack</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">inf</span>

<span class="s0">import </span><span class="s1">outcome</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">sniffio</span>

<span class="s0">from </span><span class="s2">... </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s2">...</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_multierror </span><span class="s0">import </span><span class="s1">MultiError</span><span class="s2">, </span><span class="s1">NonBaseMultiError</span>
<span class="s0">from </span><span class="s2">...</span><span class="s1">_threads </span><span class="s0">import </span><span class="s1">to_thread_run_sync</span>
<span class="s0">from </span><span class="s2">...</span><span class="s1">_timeouts </span><span class="s0">import </span><span class="s1">fail_after</span><span class="s2">, </span><span class="s1">sleep</span>
<span class="s0">from </span><span class="s2">...</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">Sequencer</span><span class="s2">, </span><span class="s1">assert_checkpoints</span><span class="s2">, </span><span class="s1">wait_all_tasks_blocked</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_run </span><span class="s0">import </span><span class="s1">DEADLINE_HEAP_MIN_PRUNE_THRESHOLD</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">tutil </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">buggy_pypy_asyncgens</span><span class="s2">,</span>
    <span class="s1">check_sequence_matches</span><span class="s2">,</span>
    <span class="s1">create_asyncio_future_in_new_loop</span><span class="s2">,</span>
    <span class="s1">gc_collect_harder</span><span class="s2">,</span>
    <span class="s1">ignore_coroutine_never_awaited_warnings</span><span class="s2">,</span>
    <span class="s1">restore_unraisablehook</span><span class="s2">,</span>
    <span class="s1">slow</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">if </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&lt; (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">11</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">exceptiongroup </span><span class="s0">import </span><span class="s1">ExceptionGroup</span>


<span class="s4"># slightly different from _timeouts.sleep_forever because it returns the value</span>
<span class="s4"># its rescheduled with, which is really only useful for tests of</span>
<span class="s4"># rescheduling...</span>
<span class="s0">async def </span><span class="s1">sleep_forever</span><span class="s2">():</span>
    <span class="s0">return await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">SUCCEEDED</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_basic</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">trivial</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">trivial</span><span class="s2">, </span><span class="s3">8</span><span class="s2">) == </span><span class="s3">8</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s4"># Missing an argument</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">trivial</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s4"># Not an async function</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">trivial2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">trivial2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">) == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_initial_task_error</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">main</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">, </span><span class="s3">17</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">args </span><span class="s2">== (</span><span class="s3">17</span><span class="s2">,)</span>


<span class="s0">def </span><span class="s1">test_run_nesting</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">inception</span><span class="s2">():</span>
        <span class="s0">async def </span><span class="s1">main</span><span class="s2">():  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">inception</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s5">&quot;from inside&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_nursery_warn_use_async_with</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">on </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">on</span><span class="s2">:</span>
            <span class="s0">pass  </span><span class="s4"># pragma: no cover</span>
    <span class="s1">excinfo</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span>
        <span class="s5">r&quot;use 'async with open_nursery\(...\)', not 'with open_nursery\(...\)'&quot;</span>
    <span class="s2">)</span>

    <span class="s4"># avoid unawaited coro.</span>
    <span class="s0">async with </span><span class="s1">on</span><span class="s2">:</span>
        <span class="s0">pass</span>


<span class="s0">async def </span><span class="s1">test_nursery_main_block_error_basic</span><span class="s2">():</span>
    <span class="s1">exc </span><span class="s2">= </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;whoops&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
            <span class="s0">raise </span><span class="s1">exc</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value </span><span class="s0">is </span><span class="s1">exc</span>


<span class="s0">async def </span><span class="s1">test_child_crash_basic</span><span class="s2">():</span>
    <span class="s1">exc </span><span class="s2">= </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;uh oh&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">erroring</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">exc</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s4"># nursery.__aexit__ propagates exception from child back to parent</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">erroring</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">e </span><span class="s0">is </span><span class="s1">exc</span>


<span class="s0">async def </span><span class="s1">test_basic_interleave</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">looper</span><span class="s2">(</span><span class="s1">whoami</span><span class="s2">, </span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">3</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">whoami</span><span class="s2">, </span><span class="s1">i</span><span class="s2">))</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">looper</span><span class="s2">, </span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s1">record</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">looper</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s1">record</span><span class="s2">)</span>

    <span class="s1">check_sequence_matches</span><span class="s2">(</span>
        <span class="s1">record</span><span class="s2">, [{(</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">), (</span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)}, {(</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)}, {(</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s3">2</span><span class="s2">), (</span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s3">2</span><span class="s2">)}]</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_task_crash_propagation</span><span class="s2">():</span>
    <span class="s1">looper_record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">looper</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;looper cancelled&quot;</span><span class="s2">)</span>
            <span class="s1">looper_record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;cancelled&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;argh&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">looper</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">looper_record </span><span class="s2">== [</span><span class="s5">&quot;cancelled&quot;</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">args </span><span class="s2">== (</span><span class="s5">&quot;argh&quot;</span><span class="s2">,)</span>


<span class="s0">def </span><span class="s1">test_main_and_task_both_crash</span><span class="s2">():</span>
    <span class="s4"># If main crashes and there's also a task crash, then we get both in a</span>
    <span class="s4"># MultiError</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s2">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">) </span><span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">} == {</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">KeyError</span><span class="s2">,</span>
    <span class="s2">}</span>


<span class="s0">def </span><span class="s1">test_two_child_crashes</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">(</span><span class="s1">etype</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">etype</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s2">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">) </span><span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">} == {</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">KeyError</span><span class="s2">,</span>
    <span class="s2">}</span>


<span class="s0">async def </span><span class="s1">test_child_crash_wakes_parent</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_reschedule</span><span class="s2">():</span>
    <span class="s1">t1 </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">t2 </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child1</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">t1</span><span class="s2">, </span><span class="s1">t2</span>
        <span class="s1">t1 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child1 start&quot;</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child1 woke&quot;</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">x </span><span class="s2">== </span><span class="s3">0</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child1 rescheduling t2&quot;</span><span class="s2">)</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">t2</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Error</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">()))</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child1 exit&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">child2</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">t1</span><span class="s2">, </span><span class="s1">t2</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child2 start&quot;</span><span class="s2">)</span>
        <span class="s1">t2 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">t1</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Value</span><span class="s2">(</span><span class="s3">0</span><span class="s2">))</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child2 sleep&quot;</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;child2 successful exit&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child1</span><span class="s2">)</span>
        <span class="s4"># let t1 run and fall asleep</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child2</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_current_time</span><span class="s2">():</span>
    <span class="s1">t1 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s4"># Windows clock is pretty low-resolution -- appveyor tests fail unless we</span>
    <span class="s4"># sleep for a bit here.</span>
    <span class="s1">time</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">time</span><span class="s2">.</span><span class="s1">get_clock_info</span><span class="s2">(</span><span class="s5">&quot;perf_counter&quot;</span><span class="s2">).</span><span class="s1">resolution</span><span class="s2">)</span>
    <span class="s1">t2 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">t1 </span><span class="s2">&lt; </span><span class="s1">t2</span>


<span class="s0">async def </span><span class="s1">test_current_time_with_mock_clock</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s1">start </span><span class="s2">= </span><span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">jump</span><span class="s2">(</span><span class="s3">3.14</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">start </span><span class="s2">+ </span><span class="s3">3.14 </span><span class="s2">== </span><span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_current_clock</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s1">mock_clock </span><span class="s0">is </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_clock</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_current_task</span><span class="s2">():</span>
    <span class="s1">parent_task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">child</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">().</span><span class="s1">parent_nursery</span><span class="s2">.</span><span class="s1">parent_task </span><span class="s0">is </span><span class="s1">parent_task</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_root_task</span><span class="s2">():</span>
    <span class="s1">root </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_root_task</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">root</span><span class="s2">.</span><span class="s1">parent_nursery </span><span class="s0">is </span><span class="s1">root</span><span class="s2">.</span><span class="s1">eventual_parent_nursery </span><span class="s0">is None</span>


<span class="s0">def </span><span class="s1">test_out_of_context</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_current_statistics</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s4"># Make sure all the early startup stuff has settled down</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>

    <span class="s4"># A child that sticks around to make some interesting stats:</span>
    <span class="s0">async def </span><span class="s1">child</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s1">stats </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_statistics</span><span class="s2">()</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">)</span>
    <span class="s4"># 2 system tasks + us</span>
    <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">tasks_living </span><span class="s2">== </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">run_sync_soon_queue_size </span><span class="s2">== </span><span class="s3">0</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">stats </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_statistics</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">)</span>
        <span class="s4"># 2 system tasks + us + child</span>
        <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">tasks_living </span><span class="s2">== </span><span class="s3">4</span>
        <span class="s4"># the exact value here might shift if we change how we do accounting</span>
        <span class="s4"># (currently it only counts tasks that we already know will be</span>
        <span class="s4"># runnable on the next pass), but still useful to at least test the</span>
        <span class="s4"># difference between now and after we wake up the child:</span>
        <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">tasks_runnable </span><span class="s2">== </span><span class="s3">0</span>
        <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">run_sync_soon_queue_size </span><span class="s2">== </span><span class="s3">2</span>

        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s1">stats </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_statistics</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">tasks_runnable </span><span class="s2">== </span><span class="s3">1</span>

    <span class="s4"># Give the child a chance to die and the run_sync_soon a chance to clear</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() + </span><span class="s3">5</span><span class="s2">):</span>
        <span class="s1">stats </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_statistics</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">seconds_to_next_deadline </span><span class="s2">== </span><span class="s3">5</span>
    <span class="s1">stats </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_statistics</span><span class="s2">()</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">seconds_to_next_deadline </span><span class="s2">== </span><span class="s1">inf</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_repr</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s5">&quot;unbound&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s5">&quot;active&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s5">&quot;deadline is 1.00 seconds ago&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() + </span><span class="s3">10</span>
        <span class="s0">assert </span><span class="s5">&quot;deadline is 10.00 seconds from now&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
        <span class="s4"># when not in async context, can't get the current time</span>
        <span class="s0">assert </span><span class="s5">&quot;deadline&quot; </span><span class="s0">not in await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">)</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s5">&quot;cancelled&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s5">&quot;exited&quot; </span><span class="s0">in </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_cancel_points</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">main1</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main1</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main2</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main2</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main3</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main3</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main4</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main4</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_cancel_edge_cases</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s4"># Two cancels in a row -- idempotent</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s4"># Check level-triggering</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_multierror_filtering</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                    <span class="s4"># Two children that get cancelled by the nursery scope</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)  </span><span class="s4"># t1</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)  </span><span class="s4"># t2</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">shield</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
                        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
                    <span class="s4"># One child that gets cancelled by the outer scope</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)  </span><span class="s4"># t3</span>
                    <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                    <span class="s4"># And one that raises a different error</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)  </span><span class="s4"># t4</span>
                <span class="s4"># and then our __aexit__ also receives an outer Cancelled</span>
            <span class="s0">except </span><span class="s1">MultiError </span><span class="s0">as </span><span class="s1">multi_exc</span><span class="s2">:</span>
                <span class="s4"># Since the outer scope became cancelled before the</span>
                <span class="s4"># nursery block exited, all cancellations inside the</span>
                <span class="s4"># nursery block continue propagating to reach the</span>
                <span class="s4"># outer scope.</span>
                <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">multi_exc</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">5</span>
                <span class="s1">summary </span><span class="s2">= {}</span>
                <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">multi_exc</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">:</span>
                    <span class="s1">summary</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">), </span><span class="s3">0</span><span class="s2">)</span>
                    <span class="s1">summary</span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">)] += </span><span class="s3">1</span>
                <span class="s0">assert </span><span class="s1">summary </span><span class="s2">== {</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">: </span><span class="s3">4</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">: </span><span class="s3">1</span><span class="s2">}</span>
                <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">AssertionError</span><span class="s2">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s4"># This is outside the outer scope, so all the Cancelled</span>
        <span class="s4"># exceptions should have been absorbed, leaving just a regular</span>
        <span class="s4"># KeyError from crasher()</span>
        <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">assert False</span>


<span class="s0">async def </span><span class="s1">test_precancelled_task</span><span class="s2">():</span>
    <span class="s4"># a task that gets spawned into an already-cancelled nursery should begin</span>
    <span class="s4"># execution (https://github.com/python-trio/trio/issues/41), but get a</span>
    <span class="s4"># cancelled error at its first blocking call.</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">blocker</span><span class="s2">():</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;started&quot;</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">blocker</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;started&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_cancel_shielding</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">inner</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

            <span class="s0">assert </span><span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s0">is False</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
                <span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s5">&quot;hello&quot;</span>
            <span class="s0">assert </span><span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s0">is False</span>

            <span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s0">is True</span>
            <span class="s4"># shield protects us from 'outer'</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

            <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">innerest</span><span class="s2">:</span>
                <span class="s1">innerest</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s4"># but it doesn't protect us from scope inside inner</span>
                <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

            <span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># can disable shield again</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

            <span class="s4"># re-enable shield</span>
            <span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s4"># shield doesn't protect us from inner itself</span>
            <span class="s1">inner</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s4"># This should now raise, but be absorbed by the inner scope</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">inner</span><span class="s2">.</span><span class="s1">cancelled_caught</span>


<span class="s4"># make sure that cancellation propagates immediately to all children</span>
<span class="s0">async def </span><span class="s1">test_cancel_inheritance</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">leaf</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">worker</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">leaf</span><span class="s2">, </span><span class="s1">ident </span><span class="s2">+ </span><span class="s5">&quot;-l1&quot;</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">leaf</span><span class="s2">, </span><span class="s1">ident </span><span class="s2">+ </span><span class="s5">&quot;-l2&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">worker</span><span class="s2">, </span><span class="s5">&quot;w1&quot;</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">worker</span><span class="s2">, </span><span class="s5">&quot;w2&quot;</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== {</span><span class="s5">&quot;w1-l1&quot;</span><span class="s2">, </span><span class="s5">&quot;w1-l2&quot;</span><span class="s2">, </span><span class="s5">&quot;w2-l1&quot;</span><span class="s2">, </span><span class="s5">&quot;w2-l2&quot;</span><span class="s2">}</span>


<span class="s0">async def </span><span class="s1">test_cancel_shield_abort</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s4"># The outer scope is cancelled, but this task is protected by the</span>
            <span class="s4"># shield, so it manages to get to sleep</span>
            <span class="s1">record </span><span class="s2">= []</span>

            <span class="s0">async def </span><span class="s1">sleeper</span><span class="s2">():</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">)</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
                <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
                    <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;cancelled&quot;</span><span class="s2">)</span>

            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleeper</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">]</span>
            <span class="s4"># now when we unshield, it should abort the sleep.</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s4"># wait for the task to finish before entering the nursery</span>
            <span class="s4"># __aexit__, because __aexit__ could make it spuriously look like</span>
            <span class="s4"># this worked by cancelling the nursery scope. (When originally</span>
            <span class="s4"># written, without these last few lines, the test spuriously</span>
            <span class="s4"># passed, even though shield assignment was buggy.)</span>
            <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">shield</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
                <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">, </span><span class="s5">&quot;cancelled&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_basic_timeout</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s1">start </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">== </span><span class="s1">inf</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">start </span><span class="s2">+ </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">== </span><span class="s1">start </span><span class="s2">+ </span><span class="s3">1</span>
    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">jump</span><span class="s2">(</span><span class="s3">2</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>

    <span class="s1">start </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s1">start </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">) </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">jump</span><span class="s2">(</span><span class="s3">2</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
    <span class="s4"># But then the scope swallowed the exception... but we can still see it</span>
    <span class="s4"># here:</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

    <span class="s4"># changing deadline</span>
    <span class="s1">start </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">start </span><span class="s2">+ </span><span class="s3">10</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">jump</span><span class="s2">(</span><span class="s3">5</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">start </span><span class="s2">+ </span><span class="s3">1</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_nesting</span><span class="s2">():</span>
    <span class="s4"># Nested scopes: if two triggering at once, the outer one wins</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope1</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope2</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope3</span><span class="s2">:</span>
                <span class="s1">scope3</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s1">scope2</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">scope3</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope3</span><span class="s2">.</span><span class="s1">cancelled_caught</span>
    <span class="s0">assert </span><span class="s1">scope2</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope2</span><span class="s2">.</span><span class="s1">cancelled_caught</span>
    <span class="s0">assert not </span><span class="s1">scope1</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope1</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

    <span class="s4"># shielding</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope1</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope2</span><span class="s2">:</span>
            <span class="s1">scope1</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s4"># if a scope is pending, but then gets popped off the stack, then it</span>
    <span class="s4"># isn't delivered</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>


<span class="s4"># Regression test for https://github.com/python-trio/trio/issues/1175</span>
<span class="s0">async def </span><span class="s1">test_unshield_while_cancel_propagating</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">inner</span><span class="s2">:</span>
            <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
            <span class="s0">finally</span><span class="s2">:</span>
                <span class="s1">inner</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s0">assert </span><span class="s1">outer</span><span class="s2">.</span><span class="s1">cancelled_caught </span><span class="s0">and not </span><span class="s1">inner</span><span class="s2">.</span><span class="s1">cancelled_caught</span>


<span class="s0">async def </span><span class="s1">test_cancel_unbound</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">sleep_until_cancelled</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">scope</span><span class="s2">, </span><span class="s1">fail_after</span><span class="s2">(</span><span class="s3">1</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s4"># Cancel before entry</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_until_cancelled</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">)</span>

    <span class="s4"># Cancel after entry</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_until_cancelled</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s4"># Shield before entry</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s1">scope</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s4"># Can't reuse</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc_info</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s0">pass  </span><span class="s4"># pragma: no cover</span>
    <span class="s0">assert </span><span class="s5">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s4"># Can't reenter</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc_info</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">scope</span><span class="s2">:</span>
                <span class="s0">pass  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">assert </span><span class="s5">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s4"># Can't enter from multiple tasks simultaneously</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">enter_scope</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">enter_scope</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;this one&quot;</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc_info</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">scope</span><span class="s2">:</span>
                <span class="s0">pass  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">assert </span><span class="s5">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s4"># If not yet entered, cancel_called is true when the deadline has passed</span>
    <span class="s4"># even if cancel() hasn't been called yet</span>
    <span class="s1">scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() + </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">-= </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called</span>
    <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">+= </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel_called  </span><span class="s4"># never become un-cancelled</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_misnesting</span><span class="s2">():</span>
    <span class="s1">outer </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s1">inner </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">ExitStack</span><span class="s2">() </span><span class="s0">as </span><span class="s1">stack</span><span class="s2">:</span>
        <span class="s1">stack</span><span class="s2">.</span><span class="s1">enter_context</span><span class="s2">(</span><span class="s1">outer</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">inner</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;still within its child&quot;</span><span class="s2">):</span>
                <span class="s1">stack</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s4"># No further error is raised when exiting the inner context</span>

    <span class="s4"># If there are other tasks inside the abandoned part of the cancel tree,</span>
    <span class="s4"># they get cancelled when the misnesting is detected</span>
    <span class="s0">async def </span><span class="s1">task1</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s4"># Even if inside another cancel scope</span>
    <span class="s0">async def </span><span class="s1">task2</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">():</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">ExitStack</span><span class="s2">() </span><span class="s0">as </span><span class="s1">stack</span><span class="s2">:</span>
        <span class="s1">stack</span><span class="s2">.</span><span class="s1">enter_context</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">())</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">task1</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">task2</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;still within its child&quot;</span><span class="s2">):</span>
                <span class="s1">stack</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>

    <span class="s4"># Variant that makes the child tasks direct children of the scope</span>
    <span class="s4"># that noticed the misnesting:</span>
    <span class="s1">nursery_mgr </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">()</span>
    <span class="s1">nursery </span><span class="s2">= </span><span class="s0">await </span><span class="s1">nursery_mgr</span><span class="s2">.</span><span class="s1">__aenter__</span><span class="s2">()</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">task1</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">task2</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">__exit__</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc_info</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">nursery_mgr</span><span class="s2">.</span><span class="s1">__aexit__</span><span class="s2">(*</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">exc_info</span><span class="s2">())</span>
        <span class="s0">assert </span><span class="s5">&quot;which had already been exited&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">) </span><span class="s0">is </span><span class="s1">NonBaseMultiError</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">3</span>
        <span class="s1">cancelled_in_context </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">exc_info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">RuntimeError</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s5">&quot;closed before the task exited&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">)</span>
            <span class="s1">cancelled_in_context </span><span class="s2">|= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">, </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">cancelled_in_context  </span><span class="s4"># for the sleep_forever</span>

    <span class="s4"># Trying to exit a cancel scope from an unrelated task raises an error</span>
    <span class="s4"># without affecting any state</span>
    <span class="s0">async def </span><span class="s1">task3</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">scope </span><span class="s2">= </span><span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">task3</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;from unrelated&quot;</span><span class="s2">):</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">__exit__</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">slow</span>
<span class="s0">async def </span><span class="s1">test_timekeeping</span><span class="s2">():</span>
    <span class="s4"># probably a good idea to use a real clock for *one* test anyway...</span>
    <span class="s1">TARGET </span><span class="s2">= </span><span class="s3">1.0</span>
    <span class="s4"># give it a few tries in case of random CI server flakiness</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">4</span><span class="s2">):</span>
        <span class="s1">real_start </span><span class="s2">= </span><span class="s1">time</span><span class="s2">.</span><span class="s1">perf_counter</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() + </span><span class="s1">TARGET</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s1">real_duration </span><span class="s2">= </span><span class="s1">time</span><span class="s2">.</span><span class="s1">perf_counter</span><span class="s2">() - </span><span class="s1">real_start</span>
        <span class="s1">accuracy </span><span class="s2">= </span><span class="s1">real_duration </span><span class="s2">/ </span><span class="s1">TARGET</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">accuracy</span><span class="s2">)</span>
        <span class="s4"># Actual time elapsed should always be &gt;= target time</span>
        <span class="s4"># (== is possible depending on system behavior for time.perf_counter resolution</span>
        <span class="s0">if </span><span class="s3">1.0 </span><span class="s2">&lt;= </span><span class="s1">accuracy </span><span class="s2">&lt; </span><span class="s3">2</span><span class="s2">:  </span><span class="s4"># pragma: no branch</span>
            <span class="s0">break</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">assert False</span>


<span class="s0">async def </span><span class="s1">test_failed_abort</span><span class="s2">():</span>
    <span class="s1">stubborn_task </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">]</span>
    <span class="s1">stubborn_scope </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">]</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">stubborn_sleeper</span><span class="s2">():</span>
        <span class="s1">stubborn_task</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] = </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">stubborn_scope</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] = </span><span class="s1">scope</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;sleep&quot;</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">FAILED</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">x </span><span class="s2">== </span><span class="s3">1</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;woke&quot;</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
            <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;cancelled&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">stubborn_sleeper</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleep&quot;</span><span class="s2">]</span>
        <span class="s1">stubborn_scope</span><span class="s2">[</span><span class="s3">0</span><span class="s2">].</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s4"># cancel didn't wake it up</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleep&quot;</span><span class="s2">]</span>
        <span class="s4"># wake it up again by hand</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">stubborn_task</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Value</span><span class="s2">(</span><span class="s3">1</span><span class="s2">))</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleep&quot;</span><span class="s2">, </span><span class="s5">&quot;woke&quot;</span><span class="s2">, </span><span class="s5">&quot;cancelled&quot;</span><span class="s2">]</span>


<span class="s2">@</span><span class="s1">restore_unraisablehook</span><span class="s2">()</span>
<span class="s0">def </span><span class="s1">test_broken_abort</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s4"># These yields are here to work around an annoying warning -- we're</span>
        <span class="s4"># going to crash the main loop, and if we (by chance) do this before</span>
        <span class="s4"># the run_sync_soon task runs for the first time, then Python gives us</span>
        <span class="s4"># a spurious warning about it not being awaited. (I mean, the warning</span>
        <span class="s4"># is correct, but here we're testing our ability to deliver a</span>
        <span class="s4"># semi-meaningful error after things have gone totally pear-shaped, so</span>
        <span class="s4"># it's not relevant.) By letting the run_sync_soon_task run first, we</span>
        <span class="s4"># avoid the warning.</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s4"># None is not a legal return value here</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s4"># Because this crashes, various __del__ methods print complaints on</span>
    <span class="s4"># stderr. Make sure that they get run now, so the output is attached to</span>
    <span class="s4"># this test.</span>
    <span class="s1">gc_collect_harder</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">restore_unraisablehook</span><span class="s2">()</span>
<span class="s0">def </span><span class="s1">test_error_in_run_loop</span><span class="s2">():</span>
    <span class="s4"># Blow stuff up real good to check we at least get a TrioInternalError</span>
    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s1">task</span><span class="s2">.</span><span class="s1">_schedule_points </span><span class="s2">= </span><span class="s5">&quot;hello!&quot;</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">ignore_coroutine_never_awaited_warnings</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_spawn_system_task</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">system_task</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s5">&quot;x&quot;</span><span class="s2">, </span><span class="s1">x</span><span class="s2">))</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s5">&quot;ki&quot;</span><span class="s2">, </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()))</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">system_task</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [(</span><span class="s5">&quot;x&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s2">), (</span><span class="s5">&quot;ki&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)]</span>


<span class="s4"># intentionally make a system task crash</span>
<span class="s0">def </span><span class="s1">test_system_task_crash</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_MultiError</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher1</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">crasher2</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">system_task</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher1</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher2</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">system_task</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s1">me </span><span class="s2">= </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__cause__</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">me</span><span class="s2">, </span><span class="s1">MultiError</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">me</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">2</span>
    <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">me</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, (</span><span class="s1">KeyError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_plus_Cancelled</span><span class="s2">():</span>
    <span class="s4"># Set up a situation where a system task crashes with a</span>
    <span class="s4"># MultiError([Cancelled, ValueError])</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">cancelme</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">system_task</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">cancelme</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">system_task</span><span class="s2">)</span>
        <span class="s4"># then we exit, triggering a cancellation</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">) </span><span class="s0">is </span><span class="s1">ValueError</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_KeyboardInterrupt</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">ki</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyboardInterrupt</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">ki</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">, </span><span class="s1">KeyboardInterrupt</span><span class="s2">)</span>


<span class="s4"># This used to fail because checkpoint was a yield followed by an immediate</span>
<span class="s4"># reschedule. So we had:</span>
<span class="s4"># 1) this task yields</span>
<span class="s4"># 2) this task is rescheduled</span>
<span class="s4"># ...</span>
<span class="s4"># 3) next iteration of event loop starts, runs timeouts</span>
<span class="s4"># 4) this task has timed out</span>
<span class="s4"># 5) ...but it's on the run queue, so the timeout is queued to be delivered</span>
<span class="s4">#    the next time that it's blocked.</span>
<span class="s0">async def </span><span class="s1">test_yield_briefly_checks_for_timeout</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() + </span><span class="s3">5</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s1">mock_clock</span><span class="s2">.</span><span class="s1">jump</span><span class="s2">(</span><span class="s3">10</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>


<span class="s4"># This tests that sys.exc_info is properly saved/restored as we swap between</span>
<span class="s4"># tasks. It turns out that the interpreter automagically handles this for us</span>
<span class="s4"># so there's no special code in Trio required to pass this test, but it's</span>
<span class="s4"># still nice to know that it works :-).</span>
<span class="s4">#</span>
<span class="s4"># Update: it turns out I was right to be nervous! see the next test...</span>
<span class="s0">async def </span><span class="s1">test_exc_info</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">seq </span><span class="s2">= </span><span class="s1">Sequencer</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">child1</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">async with </span><span class="s1">seq</span><span class="s2">(</span><span class="s3">0</span><span class="s2">):</span>
                    <span class="s0">pass  </span><span class="s4"># we don't yield until seq(2) below</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child1 raise&quot;</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;child1&quot;</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child1 sleep&quot;</span><span class="s2">)</span>
                <span class="s0">async with </span><span class="s1">seq</span><span class="s2">(</span><span class="s3">2</span><span class="s2">):</span>
                    <span class="s0">pass</span>
                <span class="s0">assert </span><span class="s5">&quot;child2 wake&quot; </span><span class="s0">in </span><span class="s1">record</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child1 re-raise&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>
        <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is None</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child1 success&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">child2</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">seq</span><span class="s2">(</span><span class="s3">1</span><span class="s2">):</span>
                <span class="s0">pass  </span><span class="s4"># we don't yield until seq(3) below</span>
            <span class="s0">assert </span><span class="s5">&quot;child1 sleep&quot; </span><span class="s0">in </span><span class="s1">record</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child2 wake&quot;</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">exc_info</span><span class="s2">() == (</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s5">&quot;child2&quot;</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child2 sleep again&quot;</span><span class="s2">)</span>
                <span class="s0">async with </span><span class="s1">seq</span><span class="s2">(</span><span class="s3">3</span><span class="s2">):</span>
                    <span class="s0">pass</span>
                <span class="s0">assert </span><span class="s5">&quot;child1 re-raise&quot; </span><span class="s0">in </span><span class="s1">record</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child2 re-raise&quot;</span><span class="s2">)</span>
                <span class="s0">raise</span>
        <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is None</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;child2 success&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child1</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child2</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span>
        <span class="s5">&quot;child1 raise&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child1 sleep&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child2 wake&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child2 sleep again&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child1 re-raise&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child1 success&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child2 re-raise&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;child2 success&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>


<span class="s4"># Before CPython 3.9, using .throw() to raise an exception inside a</span>
<span class="s4"># coroutine/generator causes the original exc_info state to be lost, so things</span>
<span class="s4"># like re-raising and exception chaining are broken.</span>
<span class="s4">#</span>
<span class="s4"># https://bugs.python.org/issue29587</span>
<span class="s0">async def </span><span class="s1">test_exc_info_after_yield_error</span><span class="s2">():</span>
    <span class="s1">child_task </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">child_task</span>
        <span class="s1">child_task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
            <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s0">raise</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">child_task</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Error</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">()))</span>


<span class="s4"># Similar to previous test -- if the ValueError() gets sent in via 'throw',</span>
<span class="s4"># then Python's normal implicit chaining stuff is broken.</span>
<span class="s0">async def </span><span class="s1">test_exception_chaining_after_yield_error</span><span class="s2">():</span>
    <span class="s1">child_task </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">child_task</span>
        <span class="s1">child_task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">child_task</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Error</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">()))</span>

    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_nursery_exception_chaining_doesnt_make_context_loops</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>
    <span class="s4"># the MultiError should not have the KeyError or ValueError as context</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is None</span>


<span class="s0">def </span><span class="s1">test_TrioToken_identity</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">get_and_check_token</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s4"># Two calls in the same run give the same object</span>
        <span class="s0">assert </span><span class="s1">token </span><span class="s0">is </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">token</span>

    <span class="s1">t1 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">get_and_check_token</span><span class="s2">)</span>
    <span class="s1">t2 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">get_and_check_token</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">t1 </span><span class="s0">is not </span><span class="s1">t2</span>
    <span class="s0">assert </span><span class="s1">t1 </span><span class="s2">!= </span><span class="s1">t2</span>
    <span class="s0">assert </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">t1</span><span class="s2">) != </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">t2</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_basic</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">cb</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s5">&quot;cb&quot;</span><span class="s2">, </span><span class="s1">x</span><span class="s2">))</span>

    <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s0">assert not </span><span class="s1">record</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [(</span><span class="s5">&quot;cb&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)]</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_too_late</span><span class="s2">():</span>
    <span class="s1">token </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">token </span><span class="s0">is not None</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">RunFinishedError</span><span class="s2">):</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)  </span><span class="s4"># pragma: no branch</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_idempotent</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">cb</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">record</span><span class="s2">) == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">record</span><span class="s2">) == [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">]</span>

    <span class="s4"># ordering test</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">3</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">100</span><span class="s2">):</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s4"># We guarantee FIFO</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s3">100</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_idempotent_requeue</span><span class="s2">():</span>
    <span class="s4"># We guarantee that if a call has finished, queueing it again will call it</span>
    <span class="s4"># again. Due to the lack of synchronization, this effectively means that</span>
    <span class="s4"># we have to guarantee that once a call has *started*, queueing it again</span>
    <span class="s4"># will call it again. Also this is much easier to test :-)</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">redo</span><span class="s2">(</span><span class="s1">token</span><span class="s2">):</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">redo</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">RunFinishedError</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">redo</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">idempotent</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">record</span><span class="s2">) &gt;= </span><span class="s3">2</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_after_main_crash</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s4"># After main exits but before finally cleaning up, callback processed</span>
        <span class="s4"># normally</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;sync-cb&quot;</span><span class="s2">))</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sync-cb&quot;</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_crashes</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">()[</span><span class="s5">&quot;nope&quot;</span><span class="s2">])</span>
        <span class="s4"># check that a crashing run_sync_soon callback doesn't stop further</span>
        <span class="s4"># calls to run_sync_soon</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s5">&quot;2nd run_sync_soon ran&quot;</span><span class="s2">))</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s5">&quot;cancelled!&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== {</span><span class="s5">&quot;2nd run_sync_soon ran&quot;</span><span class="s2">, </span><span class="s5">&quot;cancelled!&quot;</span><span class="s2">}</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_FIFO</span><span class="s2">():</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s3">100</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">j</span><span class="s2">: </span><span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">j</span><span class="s2">), </span><span class="s1">i</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_starvation_resistance</span><span class="s2">():</span>
    <span class="s4"># Even if we push callbacks in from callbacks, so that the callback queue</span>
    <span class="s4"># never empties out, then we still can't starve out other tasks from</span>
    <span class="s4"># running.</span>
    <span class="s1">token </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">naughty_cb</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">naughty_cb</span><span class="s2">, </span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">RunFinishedError</span><span class="s2">:</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s5">&quot;run finished&quot;</span><span class="s2">, </span><span class="s1">i</span><span class="s2">))</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">naughty_cb</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;starting&quot;</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">20</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">record</span><span class="s2">) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">record</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s5">&quot;starting&quot;</span>
    <span class="s0">assert </span><span class="s1">record</span><span class="s2">[</span><span class="s3">1</span><span class="s2">][</span><span class="s3">0</span><span class="s2">] == </span><span class="s5">&quot;run finished&quot;</span>
    <span class="s0">assert </span><span class="s1">record</span><span class="s2">[</span><span class="s3">1</span><span class="s2">][</span><span class="s3">1</span><span class="s2">] &gt;= </span><span class="s3">19</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_threaded_stress_test</span><span class="s2">():</span>
    <span class="s1">cb_counter </span><span class="s2">= </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">cb</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">cb_counter</span>
        <span class="s1">cb_counter </span><span class="s2">+= </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">stress_thread</span><span class="s2">(</span><span class="s1">token</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">)</span>
                <span class="s1">time</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">RunFinishedError</span><span class="s2">:</span>
            <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">(</span><span class="s1">target</span><span class="s2">=</span><span class="s1">stress_thread</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(</span><span class="s1">token</span><span class="s2">,))</span>
        <span class="s1">thread</span><span class="s2">.</span><span class="s1">start</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">10</span><span class="s2">):</span>
            <span class="s1">start_value </span><span class="s2">= </span><span class="s1">cb_counter</span>
            <span class="s0">while </span><span class="s1">cb_counter </span><span class="s2">== </span><span class="s1">start_value</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0.01</span><span class="s2">)</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s1">cb_counter</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_massive_queue</span><span class="s2">():</span>
    <span class="s4"># There are edge cases in the wakeup fd code when the wakeup fd overflows,</span>
    <span class="s4"># so let's try to make that happen. This is also just a good stress test</span>
    <span class="s4"># in general. (With the current-as-of-2017-02-14 code using a socketpair</span>
    <span class="s4"># with minimal buffer, Linux takes 6 wakeups to fill the buffer and macOS</span>
    <span class="s4"># takes 1 wakeup. So 1000 is overkill if anything. Windows OTOH takes</span>
    <span class="s4"># ~600,000 wakeups, but has the same code paths...)</span>
    <span class="s1">COUNT </span><span class="s2">= </span><span class="s3">1000</span>
    <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">counter </span><span class="s2">= [</span><span class="s3">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">cb</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
        <span class="s4"># This also tests FIFO ordering of callbacks</span>
        <span class="s0">assert </span><span class="s1">counter</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s1">i</span>
        <span class="s1">counter</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] += </span><span class="s3">1</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">COUNT</span><span class="s2">):</span>
        <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">counter</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] == </span><span class="s1">COUNT</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span><span class="s1">buggy_pypy_asyncgens</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;PyPy 7.2 is buggy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_late_crash</span><span class="s2">():</span>
    <span class="s4"># Crash after system nursery is closed -- easiest way to do that is</span>
    <span class="s4"># from an async generator finalizer.</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">saved </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">agen</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s3">1</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: {}[</span><span class="s5">&quot;nope&quot;</span><span class="s2">])</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;2nd ran&quot;</span><span class="s2">))</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">saved</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">agen</span><span class="s2">())</span>
        <span class="s0">await </span><span class="s1">saved</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">].</span><span class="s1">asend</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;main exiting&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__cause__</span><span class="s2">) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;main exiting&quot;</span><span class="s2">, </span><span class="s5">&quot;2nd ran&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_slow_abort_basic</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
            <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

            <span class="s0">def </span><span class="s1">slow_abort</span><span class="s2">(</span><span class="s1">raise_cancel</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">capture</span><span class="s2">(</span><span class="s1">raise_cancel</span><span class="s2">)</span>
                <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">, </span><span class="s1">task</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">FAILED</span>

            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s1">slow_abort</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_slow_abort_edge_cases</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">slow_aborter</span><span class="s2">():</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">slow_abort</span><span class="s2">(</span><span class="s1">raise_cancel</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;abort-called&quot;</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">capture</span><span class="s2">(</span><span class="s1">raise_cancel</span><span class="s2">)</span>
            <span class="s1">token</span><span class="s2">.</span><span class="s1">run_sync_soon</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">, </span><span class="s1">task</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">FAILED</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s1">slow_abort</span><span class="s2">)</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;cancelled&quot;</span><span class="s2">)</span>
        <span class="s4"># blocking again, this time it's okay, because we're shielded</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;done&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer1</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer2</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                <span class="s4"># So we have a task blocked on an operation that can't be</span>
                <span class="s4"># aborted immediately</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">slow_aborter</span><span class="s2">)</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
                <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">]</span>
                <span class="s4"># And then we cancel it, so the abort callback gets run</span>
                <span class="s1">outer1</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">, </span><span class="s5">&quot;abort-called&quot;</span><span class="s2">]</span>
                <span class="s4"># In fact that happens twice! (This used to cause the abort</span>
                <span class="s4"># callback to be run twice)</span>
                <span class="s1">outer2</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">, </span><span class="s5">&quot;abort-called&quot;</span><span class="s2">]</span>
                <span class="s4"># But then before the abort finishes, the task gets shielded!</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s4"># Now we wait for the task to finish...</span>
            <span class="s4"># The cancellation was delivered, even though it was shielded</span>
            <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s5">&quot;sleeping&quot;</span><span class="s2">, </span><span class="s5">&quot;abort-called&quot;</span><span class="s2">, </span><span class="s5">&quot;cancelled&quot;</span><span class="s2">, </span><span class="s5">&quot;done&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_task_tree_introspection</span><span class="s2">():</span>
    <span class="s1">tasks </span><span class="s2">= {}</span>
    <span class="s1">nurseries </span><span class="s2">= {}</span>

    <span class="s0">async def </span><span class="s1">parent</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">] = </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== []</span>

        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery1</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== [</span><span class="s1">nursery1</span><span class="s2">, </span><span class="s1">nursery2</span><span class="s2">]</span>

        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== []</span>

        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">] = </span><span class="s1">nursery</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">child1</span><span class="s2">)</span>

        <span class="s4"># Upward links survive after tasks/nurseries exit</span>
        <span class="s0">assert </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">parent_task </span><span class="s0">is </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">].</span><span class="s1">parent_nursery </span><span class="s0">is </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">].</span><span class="s1">parent_task </span><span class="s0">is </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child2&quot;</span><span class="s2">].</span><span class="s1">parent_nursery </span><span class="s0">is </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">]</span>

        <span class="s1">nursery </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">().</span><span class="s1">parent_nursery</span>
        <span class="s4"># Make sure that chaining eventually gives a nursery of None (and not,</span>
        <span class="s4"># for example, an error)</span>
        <span class="s0">while </span><span class="s1">nursery </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">parent_task</span>
            <span class="s1">nursery </span><span class="s2">= </span><span class="s1">t</span><span class="s2">.</span><span class="s1">parent_nursery</span>

    <span class="s0">async def </span><span class="s1">child2</span><span class="s2">():</span>
        <span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child2&quot;</span><span class="s2">] = </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== [</span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]]</span>
        <span class="s0">assert </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">].</span><span class="s1">child_tasks </span><span class="s2">== </span><span class="s1">frozenset</span><span class="s2">({</span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">]})</span>
        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== [</span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">]]</span>
        <span class="s0">assert </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">].</span><span class="s1">child_tasks </span><span class="s2">== </span><span class="s1">frozenset</span><span class="s2">({</span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child2&quot;</span><span class="s2">]})</span>
        <span class="s0">assert </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child2&quot;</span><span class="s2">].</span><span class="s1">child_nurseries </span><span class="s2">== []</span>

    <span class="s0">async def </span><span class="s1">child1</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">me </span><span class="s2">= </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">] = </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">me</span><span class="s2">.</span><span class="s1">parent_nursery</span><span class="s2">.</span><span class="s1">parent_task </span><span class="s0">is </span><span class="s1">tasks</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">me</span><span class="s2">.</span><span class="s1">parent_nursery </span><span class="s0">is not </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">me</span><span class="s2">.</span><span class="s1">eventual_parent_nursery </span><span class="s0">is </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">me</span><span class="s2">.</span><span class="s1">parent_nursery </span><span class="s0">is </span><span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;parent&quot;</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">me</span><span class="s2">.</span><span class="s1">eventual_parent_nursery </span><span class="s0">is None</span>

        <span class="s4"># Wait for the start() call to return and close its internal nursery, to</span>
        <span class="s4"># ensure consistent results in child2:</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>

        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nurseries</span><span class="s2">[</span><span class="s5">&quot;child1&quot;</span><span class="s2">] = </span><span class="s1">nursery</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child2</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">)</span>

    <span class="s4"># There are no pending starts, so no one should have a non-None</span>
    <span class="s4"># eventual_parent_nursery</span>
    <span class="s0">for </span><span class="s1">task </span><span class="s0">in </span><span class="s1">tasks</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">eventual_parent_nursery </span><span class="s0">is None</span>


<span class="s0">async def </span><span class="s1">test_nursery_closure</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">child1</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">):</span>
        <span class="s4"># We can add new tasks to the nursery even after entering __aexit__,</span>
        <span class="s4"># so long as there are still tasks running</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child2</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">child2</span><span class="s2">():</span>
        <span class="s0">pass</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child1</span><span class="s2">, </span><span class="s1">nursery</span><span class="s2">)</span>

    <span class="s4"># But once we've left __aexit__, the nursery is closed</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child2</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_spawn_name</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">func1</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">):</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">task</span><span class="s2">.</span><span class="s1">name</span>

    <span class="s0">async def </span><span class="s1">func2</span><span class="s2">():  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">spawn_fn </span><span class="s0">in </span><span class="s2">[</span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">, </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">]:</span>
            <span class="s1">spawn_fn</span><span class="s2">(</span><span class="s1">func1</span><span class="s2">, </span><span class="s5">&quot;func1&quot;</span><span class="s2">)</span>
            <span class="s1">spawn_fn</span><span class="s2">(</span><span class="s1">func1</span><span class="s2">, </span><span class="s5">&quot;func2&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">func2</span><span class="s2">)</span>
            <span class="s1">spawn_fn</span><span class="s2">(</span><span class="s1">func1</span><span class="s2">, </span><span class="s5">&quot;func3&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;func3&quot;</span><span class="s2">)</span>
            <span class="s1">spawn_fn</span><span class="s2">(</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">func1</span><span class="s2">, </span><span class="s5">&quot;func1&quot;</span><span class="s2">))</span>
            <span class="s1">spawn_fn</span><span class="s2">(</span><span class="s1">func1</span><span class="s2">, </span><span class="s5">&quot;object&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">object</span><span class="s2">())</span>


<span class="s0">async def </span><span class="s1">test_current_effective_deadline</span><span class="s2">(</span><span class="s1">mock_clock</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s1">inf</span>

    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s3">5</span><span class="s2">) </span><span class="s0">as </span><span class="s1">scope1</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">deadline</span><span class="s2">=</span><span class="s3">10</span><span class="s2">) </span><span class="s0">as </span><span class="s1">scope2</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">5</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s3">3</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">3</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s3">10</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">5</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">10</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">5</span>
            <span class="s1">scope1</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == -</span><span class="s1">inf</span>
            <span class="s1">scope2</span><span class="s2">.</span><span class="s1">shield </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s3">10</span>
        <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == -</span><span class="s1">inf</span>
    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_effective_deadline</span><span class="s2">() == </span><span class="s1">inf</span>


<span class="s0">def </span><span class="s1">test_nice_error_on_bad_calls_to_run_or_spawn</span><span class="s2">():</span>
    <span class="s0">def </span><span class="s1">bad_call_run</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">bad_call_spawn</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s0">for </span><span class="s1">bad_call </span><span class="s0">in </span><span class="s1">bad_call_run</span><span class="s2">, </span><span class="s1">bad_call_spawn</span><span class="s2">:</span>

        <span class="s0">async def </span><span class="s1">f</span><span class="s2">():  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;expecting an async function&quot;</span><span class="s2">):</span>
            <span class="s1">bad_call</span><span class="s2">(</span><span class="s1">f</span><span class="s2">())</span>

        <span class="s0">async def </span><span class="s1">async_gen</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">):  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">yield </span><span class="s1">arg</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span>
            <span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;expected an async function but got an async generator&quot;</span>
        <span class="s2">):</span>
            <span class="s1">bad_call</span><span class="s2">(</span><span class="s1">async_gen</span><span class="s2">, </span><span class="s3">0</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_calling_asyncio_function_gives_nice_error</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">child_xyzzy</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">create_asyncio_future_in_new_loop</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">misguided</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">child_xyzzy</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">misguided</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s5">&quot;asyncio&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>
    <span class="s4"># The traceback should point to the location of the foreign await</span>
    <span class="s0">assert </span><span class="s1">any</span><span class="s2">(  </span><span class="s4"># pragma: no branch</span>
        <span class="s1">entry</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s5">&quot;child_xyzzy&quot; </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">traceback</span>
    <span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_asyncio_function_inside_nursery_does_not_explode</span><span class="s2">():</span>
    <span class="s4"># Regression test for https://github.com/python-trio/trio/issues/552</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">create_asyncio_future_in_new_loop</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s5">&quot;asyncio&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_trivial_yields</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
            <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cancel_scope</span><span class="s2">:</span>
        <span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
                <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s2">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">} == {</span>
            <span class="s1">KeyError</span><span class="s2">,</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">,</span>
        <span class="s2">}</span>


<span class="s0">async def </span><span class="s1">test_nursery_start</span><span class="s2">(</span><span class="s1">autojump_clock</span><span class="s2">):</span>
    <span class="s0">async def </span><span class="s1">no_args</span><span class="s2">():  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s4"># Errors in calling convention get raised immediately from start</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">no_args</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">sleep_then_start</span><span class="s2">(</span><span class="s1">seconds</span><span class="s2">, *, </span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">repr</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">)  </span><span class="s4"># smoke test</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">seconds</span><span class="s2">)</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">(</span><span class="s1">seconds</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">seconds</span><span class="s2">)</span>

    <span class="s4"># Basic happy-path check: start waits for the task to call started(), then</span>
    <span class="s4"># returns, passes back the value, and the given nursery then waits for it</span>
    <span class="s4"># to exit.</span>
    <span class="s0">for </span><span class="s1">seconds </span><span class="s0">in </span><span class="s2">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">]:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">child_tasks</span><span class="s2">) == </span><span class="s3">0</span>
            <span class="s1">t0 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
            <span class="s0">assert await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">sleep_then_start</span><span class="s2">, </span><span class="s1">seconds</span><span class="s2">) == </span><span class="s1">seconds</span>
            <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s1">t0 </span><span class="s2">== </span><span class="s1">seconds</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">child_tasks</span><span class="s2">) == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s1">t0 </span><span class="s2">== </span><span class="s3">2 </span><span class="s2">* </span><span class="s1">seconds</span>

    <span class="s4"># Make sure TASK_STATUS_IGNORED works so task function can be called</span>
    <span class="s4"># directly</span>
    <span class="s1">t0 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">await </span><span class="s1">sleep_then_start</span><span class="s2">(</span><span class="s3">3</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s1">t0 </span><span class="s2">== </span><span class="s3">2 </span><span class="s2">* </span><span class="s3">3</span>

    <span class="s4"># calling started twice</span>
    <span class="s0">async def </span><span class="s1">double_started</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
            <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">double_started</span><span class="s2">)</span>

    <span class="s4"># child crashes before calling started -&gt; error comes out of .start()</span>
    <span class="s0">async def </span><span class="s1">raise_keyerror</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s5">&quot;oops&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">raise_keyerror</span><span class="s2">)</span>

    <span class="s4"># child exiting cleanly before calling started -&gt; triggers a RuntimeError</span>
    <span class="s0">async def </span><span class="s1">nothing</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">return</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">nothing</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s5">&quot;exited without calling&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s4"># if the call to start() is cancelled, then the call to started() does</span>
    <span class="s4"># nothing -- the child keeps executing under start(). The value it passed</span>
    <span class="s4"># is ignored; start() raises Cancelled.</span>
    <span class="s0">async def </span><span class="s1">just_started</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">(</span><span class="s5">&quot;hi&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cs</span><span class="s2">:</span>
            <span class="s1">cs</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">just_started</span><span class="s2">)</span>

    <span class="s4"># and if after the no-op started(), the child crashes, the error comes out</span>
    <span class="s4"># of start()</span>
    <span class="s0">async def </span><span class="s1">raise_keyerror_after_started</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>
        <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s5">&quot;whoopsiedaisy&quot;</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cs</span><span class="s2">:</span>
            <span class="s1">cs</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">raise_keyerror_after_started</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s2">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">} == {</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">,</span>
        <span class="s1">KeyError</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s4"># trying to start in a closed nursery raises an error immediately</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">closed_nursery</span><span class="s2">:</span>
        <span class="s0">pass</span>
    <span class="s1">t0 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">closed_nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">sleep_then_start</span><span class="s2">, </span><span class="s3">7</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s1">t0</span>


<span class="s0">async def </span><span class="s1">test_task_nursery_stack</span><span class="s2">():</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">_child_nurseries </span><span class="s2">== []</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery1</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">_child_nurseries </span><span class="s2">== [</span><span class="s1">nursery1</span><span class="s2">]</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">_child_nurseries </span><span class="s2">== [</span><span class="s1">nursery1</span><span class="s2">, </span><span class="s1">nursery2</span><span class="s2">]</span>
                <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">_child_nurseries </span><span class="s2">== [</span><span class="s1">nursery1</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">_child_nurseries </span><span class="s2">== []</span>


<span class="s0">async def </span><span class="s1">test_nursery_start_with_cancelled_nursery</span><span class="s2">():</span>
    <span class="s4"># This function isn't testing task_status, it's using task_status as a</span>
    <span class="s4"># convenient way to get a nursery that we can test spawning stuff into.</span>
    <span class="s0">async def </span><span class="s1">setup_nursery</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s4"># Calls started() while children are asleep, so we can make sure</span>
    <span class="s4"># that the cancellation machinery notices and aborts when a sleeping task</span>
    <span class="s4"># is moved into a cancelled scope.</span>
    <span class="s0">async def </span><span class="s1">sleeping_children</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, *, </span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s1">fn</span><span class="s2">()</span>
            <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>

    <span class="s4"># Cancelling the setup_nursery just *before* calling started()</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">target_nursery </span><span class="s2">= </span><span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">setup_nursery</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">target_nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span>
            <span class="s1">sleeping_children</span><span class="s2">, </span><span class="s1">target_nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span>
        <span class="s2">)</span>

    <span class="s4"># Cancelling the setup_nursery just *after* calling started()</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">target_nursery </span><span class="s2">= </span><span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">setup_nursery</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">target_nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">sleeping_children</span><span class="s2">, </span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">target_nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_nursery_start_keeps_nursery_open</span><span class="s2">(</span><span class="s1">autojump_clock</span><span class="s2">):</span>
    <span class="s0">async def </span><span class="s1">sleep_a_bit</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">2</span><span class="s2">)</span>
        <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">3</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery1</span><span class="s2">:</span>
        <span class="s1">t0 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
            <span class="s4"># Start the 'start' call running in the background</span>
            <span class="s1">nursery1</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start</span><span class="s2">, </span><span class="s1">sleep_a_bit</span><span class="s2">)</span>
            <span class="s4"># Sleep a bit</span>
            <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)</span>
            <span class="s4"># Start another one.</span>
            <span class="s1">nursery1</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start</span><span class="s2">, </span><span class="s1">sleep_a_bit</span><span class="s2">)</span>
            <span class="s4"># Then exit this nursery. At this point, there are no tasks</span>
            <span class="s4"># present in this nursery -- the only thing keeping it open is</span>
            <span class="s4"># that the tasks will be placed into it soon, when they call</span>
            <span class="s4"># started().</span>
        <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s1">t0 </span><span class="s2">== </span><span class="s3">6</span>

    <span class="s4"># Check that it still works even if the task that the nursery is waiting</span>
    <span class="s4"># for ends up crashing, and never actually enters the nursery.</span>
    <span class="s0">async def </span><span class="s1">sleep_then_crash</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">7</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">start_sleep_then_crash</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">sleep_then_crash</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery1</span><span class="s2">:</span>
        <span class="s1">t0 </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
            <span class="s1">nursery1</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">start_sleep_then_crash</span><span class="s2">, </span><span class="s1">nursery2</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() - </span><span class="s1">t0 </span><span class="s2">== </span><span class="s3">7</span>


<span class="s0">async def </span><span class="s1">test_nursery_explicit_exception</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_nursery_stop_iteration</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">fail</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">fail</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
    <span class="s0">except </span><span class="s1">MultiError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">type</span><span class="s2">, </span><span class="s1">e</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">)) == (</span><span class="s1">StopIteration</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_nursery_stop_async_iteration</span><span class="s2">():</span>
    <span class="s0">class </span><span class="s1">it</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">count</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">= </span><span class="s1">count</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">val </span><span class="s2">= </span><span class="s3">0</span>

        <span class="s0">async def </span><span class="s1">__anext__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
            <span class="s1">val </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">val</span>
            <span class="s0">if </span><span class="s1">val </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">count</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">StopAsyncIteration</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">val </span><span class="s2">+= </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">class </span><span class="s1">async_zip</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">largs</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">nexts </span><span class="s2">= [</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__anext__ </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">largs</span><span class="s2">]</span>

        <span class="s0">async def </span><span class="s1">_accumulate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, </span><span class="s1">i</span><span class="s2">):</span>
            <span class="s1">items</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s0">await </span><span class="s1">f</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">__aiter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">async def </span><span class="s1">__anext__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">nexts </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nexts</span>
            <span class="s1">items </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">nexts</span><span class="s2">)</span>

            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nexts</span><span class="s2">):</span>
                    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_accumulate</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, </span><span class="s1">i</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">items</span>

    <span class="s1">result </span><span class="s2">= []</span>
    <span class="s0">async for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">async_zip</span><span class="s2">(</span><span class="s1">it</span><span class="s2">(</span><span class="s3">4</span><span class="s2">), </span><span class="s1">it</span><span class="s2">(</span><span class="s3">2</span><span class="s2">)):</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">vals</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">result </span><span class="s2">== [[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">], [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">]]</span>


<span class="s0">async def </span><span class="s1">test_traceback_frame_removal</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">my_child_task</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">()</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s4"># Trick: For now cancel/nursery scopes still leave a bunch of tb gunk</span>
        <span class="s4"># behind. But if there's a MultiError, they leave it on the MultiError,</span>
        <span class="s4"># which lets us get a clean look at the KeyError itself. Someday I</span>
        <span class="s4"># guess this will always be a MultiError (#611), but for now we can</span>
        <span class="s4"># force it by raising two exceptions.</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">my_child_task</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">my_child_task</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">MultiError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s1">first_exc </span><span class="s2">= </span><span class="s1">exc</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">first_exc</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">)</span>
        <span class="s4"># The top frame in the exception traceback should be inside the child</span>
        <span class="s4"># task, not trio/contextvars internals. And there's only one frame</span>
        <span class="s4"># inside the child task, so this will also detect if our frame-removal</span>
        <span class="s4"># is too eager.</span>
        <span class="s1">frame </span><span class="s2">= </span><span class="s1">first_exc</span><span class="s2">.</span><span class="s1">__traceback__</span><span class="s2">.</span><span class="s1">tb_frame</span>
        <span class="s0">assert </span><span class="s1">frame</span><span class="s2">.</span><span class="s1">f_code </span><span class="s0">is </span><span class="s1">my_child_task</span><span class="s2">.</span><span class="s1">__code__</span>


<span class="s0">def </span><span class="s1">test_contextvar_support</span><span class="s2">():</span>
    <span class="s1">var </span><span class="s2">= </span><span class="s1">contextvars</span><span class="s2">.</span><span class="s1">ContextVar</span><span class="s2">(</span><span class="s5">&quot;test&quot;</span><span class="s2">)</span>
    <span class="s1">var</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;before&quot;</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;before&quot;</span>

    <span class="s0">async def </span><span class="s1">inner</span><span class="s2">():</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">var</span><span class="s2">) == </span><span class="s5">&quot;before&quot;</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;before&quot;</span>
        <span class="s1">var</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;after&quot;</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;after&quot;</span>
        <span class="s0">assert </span><span class="s1">var </span><span class="s0">in </span><span class="s1">task</span><span class="s2">.</span><span class="s1">context</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">context</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">var</span><span class="s2">) == </span><span class="s5">&quot;after&quot;</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;before&quot;</span>


<span class="s0">async def </span><span class="s1">test_contextvar_multitask</span><span class="s2">():</span>
    <span class="s1">var </span><span class="s2">= </span><span class="s1">contextvars</span><span class="s2">.</span><span class="s1">ContextVar</span><span class="s2">(</span><span class="s5">&quot;test&quot;</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s5">&quot;hmmm&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">t1</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;hmmm&quot;</span>
        <span class="s1">var</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;hmmmm&quot;</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;hmmmm&quot;</span>

    <span class="s0">async def </span><span class="s1">t2</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;hmmmm&quot;</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">n</span><span class="s2">:</span>
        <span class="s1">n</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">t1</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">var</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;hmmm&quot;</span>
        <span class="s1">var</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;hmmmm&quot;</span><span class="s2">)</span>
        <span class="s1">n</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">t2</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_system_task_contexts</span><span class="s2">():</span>
    <span class="s1">cvar </span><span class="s2">= </span><span class="s1">contextvars</span><span class="s2">.</span><span class="s1">ContextVar</span><span class="s2">(</span><span class="s5">&quot;qwilfish&quot;</span><span class="s2">)</span>
    <span class="s1">cvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;water&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">system_task</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;water&quot;</span>

    <span class="s0">async def </span><span class="s1">regular_task</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">() == </span><span class="s5">&quot;poison&quot;</span>

    <span class="s0">async def </span><span class="s1">inner</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">cvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;poison&quot;</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">regular_task</span><span class="s2">)</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">system_task</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_Nursery_init</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">_run</span><span class="s2">.</span><span class="s1">Nursery</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_Nursery_private_init</span><span class="s2">():</span>
    <span class="s4"># context manager creation should not raise</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s0">assert False </span><span class="s2">== </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">_closed</span>


<span class="s0">def </span><span class="s1">test_Nursery_subclass</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>

        <span class="s0">class </span><span class="s1">Subclass</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_run</span><span class="s2">.</span><span class="s1">Nursery</span><span class="s2">):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_Cancelled_init</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">()</span>

    <span class="s4"># private constructor should not raise</span>
    <span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">.</span><span class="s1">_create</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_Cancelled_str</span><span class="s2">():</span>
    <span class="s1">cancelled </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">.</span><span class="s1">_create</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">str</span><span class="s2">(</span><span class="s1">cancelled</span><span class="s2">) == </span><span class="s5">&quot;Cancelled&quot;</span>


<span class="s0">def </span><span class="s1">test_Cancelled_subclass</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>

        <span class="s0">class </span><span class="s1">Subclass</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_CancelScope_subclass</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>

        <span class="s0">class </span><span class="s1">Subclass</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_sniffio_integration</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">AsyncLibraryNotFoundError</span><span class="s2">):</span>
        <span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">check_inside_trio</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">() == </span><span class="s5">&quot;trio&quot;</span>

    <span class="s0">def </span><span class="s1">check_function_returning_coroutine</span><span class="s2">():</span>
        <span class="s0">assert </span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">() == </span><span class="s5">&quot;trio&quot;</span>
        <span class="s0">return </span><span class="s1">check_inside_trio</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">check_inside_trio</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">AsyncLibraryNotFoundError</span><span class="s2">):</span>
        <span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">check_new_task_resets_sniffio_library</span><span class="s2">():</span>
        <span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s5">&quot;nullio&quot;</span><span class="s2">)</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">spawn_system_task</span><span class="s2">(</span><span class="s1">check_inside_trio</span><span class="s2">)</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">check_inside_trio</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">check_function_returning_coroutine</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">() == </span><span class="s5">&quot;nullio&quot;</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">check_new_task_resets_sniffio_library</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_Task_custom_sleep_data</span><span class="s2">():</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">custom_sleep_data </span><span class="s0">is None</span>
    <span class="s1">task</span><span class="s2">.</span><span class="s1">custom_sleep_data </span><span class="s2">= </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">custom_sleep_data </span><span class="s2">== </span><span class="s3">1</span>
    <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">custom_sleep_data </span><span class="s0">is None</span>


<span class="s2">@</span><span class="s1">types</span><span class="s2">.</span><span class="s1">coroutine</span>
<span class="s0">def </span><span class="s1">async_yield</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
    <span class="s0">yield </span><span class="s1">value</span>


<span class="s0">async def </span><span class="s1">test_permanently_detach_coroutine_object</span><span class="s2">():</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">pdco_outcome </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">detachable_coroutine</span><span class="s2">(</span><span class="s1">task_outcome</span><span class="s2">, </span><span class="s1">yield_value</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
        <span class="s0">nonlocal </span><span class="s1">task</span><span class="s2">, </span><span class="s1">pdco_outcome</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s1">pdco_outcome </span><span class="s2">= </span><span class="s0">await </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">acapture</span><span class="s2">(</span>
            <span class="s1">_core</span><span class="s2">.</span><span class="s1">permanently_detach_coroutine_object</span><span class="s2">, </span><span class="s1">task_outcome</span>
        <span class="s2">)</span>
        <span class="s0">await </span><span class="s1">async_yield</span><span class="s2">(</span><span class="s1">yield_value</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">detachable_coroutine</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Value</span><span class="s2">(</span><span class="s0">None</span><span class="s2">), </span><span class="s5">&quot;I'm free!&quot;</span><span class="s2">)</span>

    <span class="s4"># If we get here then Trio thinks the task has exited... but the coroutine</span>
    <span class="s4"># is still iterable</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s5">&quot;be free!&quot;</span><span class="s2">) == </span><span class="s5">&quot;I'm free!&quot;</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome </span><span class="s2">== </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Value</span><span class="s2">(</span><span class="s5">&quot;be free!&quot;</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">StopIteration</span><span class="s2">):</span>
        <span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s4"># Check the exception paths too</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">pdco_outcome </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">):</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">detachable_coroutine</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Error</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">()), </span><span class="s5">&quot;uh oh&quot;</span><span class="s2">)</span>
    <span class="s1">throw_in </span><span class="s2">= </span><span class="s1">ValueError</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">throw</span><span class="s2">(</span><span class="s1">throw_in</span><span class="s2">) == </span><span class="s5">&quot;uh oh&quot;</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome </span><span class="s2">== </span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Error</span><span class="s2">(</span><span class="s1">throw_in</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">StopIteration</span><span class="s2">):</span>
        <span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">bad_detach</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">permanently_detach_coroutine_object</span><span class="s2">(</span><span class="s1">outcome</span><span class="s2">.</span><span class="s1">Value</span><span class="s2">(</span><span class="s0">None</span><span class="s2">))</span>
            <span class="s0">assert </span><span class="s5">&quot;open nurser&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">bad_detach</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_detach_and_reattach_coroutine_object</span><span class="s2">():</span>
    <span class="s1">unrelated_task </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">unrelated_coroutine</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">unrelated_task</span>
        <span class="s1">unrelated_task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">reattachable_coroutine</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s0">nonlocal </span><span class="s1">task</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">abort_fn</span><span class="s2">(</span><span class="s1">_</span><span class="s2">):  </span><span class="s4"># pragma: no cover</span>
            <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">FAILED</span>

        <span class="s1">got </span><span class="s2">= </span><span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">temporarily_detach_coroutine_object</span><span class="s2">(</span><span class="s1">abort_fn</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">got </span><span class="s2">== </span><span class="s5">&quot;not trio!&quot;</span>

        <span class="s0">await </span><span class="s1">async_yield</span><span class="s2">(</span><span class="s3">1</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">async_yield</span><span class="s2">(</span><span class="s3">2</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">reattach_detached_coroutine_object</span><span class="s2">(</span><span class="s1">unrelated_task</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s5">&quot;does not match&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">reattach_detached_coroutine_object</span><span class="s2">(</span><span class="s1">task</span><span class="s2">, </span><span class="s5">&quot;byebye&quot;</span><span class="s2">)</span>

        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">unrelated_coroutine</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">reattachable_coroutine</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">unrelated_task </span><span class="s0">is not None</span>
        <span class="s0">assert </span><span class="s1">task </span><span class="s0">is not None</span>

        <span class="s4"># Okay, it's detached. Here's our coroutine runner:</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s5">&quot;not trio!&quot;</span><span class="s2">) == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s0">None</span><span class="s2">) == </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s0">None</span><span class="s2">) == </span><span class="s5">&quot;byebye&quot;</span>

        <span class="s4"># Now it's been reattached, and we can leave the nursery</span>


<span class="s0">async def </span><span class="s1">test_detached_coroutine_cancellation</span><span class="s2">():</span>
    <span class="s1">abort_fn_called </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">task </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">reattachable_coroutine</span><span class="s2">():</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

        <span class="s0">nonlocal </span><span class="s1">task</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">abort_fn</span><span class="s2">(</span><span class="s1">_</span><span class="s2">):</span>
            <span class="s0">nonlocal </span><span class="s1">abort_fn_called</span>
            <span class="s1">abort_fn_called </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">FAILED</span>

        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">temporarily_detach_coroutine_object</span><span class="s2">(</span><span class="s1">abort_fn</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">reattach_detached_coroutine_object</span><span class="s2">(</span><span class="s1">task</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">reattachable_coroutine</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">task </span><span class="s0">is not None</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s1">task</span><span class="s2">.</span><span class="s1">coro</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">abort_fn_called</span>


<span class="s2">@</span><span class="s1">restore_unraisablehook</span><span class="s2">()</span>
<span class="s0">def </span><span class="s1">test_async_function_implemented_in_C</span><span class="s2">():</span>
    <span class="s4"># These used to crash because we'd try to mutate the coroutine object's</span>
    <span class="s4"># cr_frame, but C functions don't have Python frames.</span>

    <span class="s0">async def </span><span class="s1">agen_fn</span><span class="s2">(</span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">&quot;the generator ran&quot;</span><span class="s2">)</span>
        <span class="s0">yield</span>

    <span class="s1">run_record </span><span class="s2">= []</span>
    <span class="s1">agen </span><span class="s2">= </span><span class="s1">agen_fn</span><span class="s2">(</span><span class="s1">run_record</span><span class="s2">)</span>
    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">agen</span><span class="s2">.</span><span class="s1">__anext__</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">run_record </span><span class="s2">== [</span><span class="s5">&quot;the generator ran&quot;</span><span class="s2">]</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">start_soon_record </span><span class="s2">= []</span>
        <span class="s1">agen </span><span class="s2">= </span><span class="s1">agen_fn</span><span class="s2">(</span><span class="s1">start_soon_record</span><span class="s2">)</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">agen</span><span class="s2">.</span><span class="s1">__anext__</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">start_soon_record </span><span class="s2">== [</span><span class="s5">&quot;the generator ran&quot;</span><span class="s2">]</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_very_deep_cancel_scope_nesting</span><span class="s2">():</span>
    <span class="s4"># This used to crash with a RecursionError in CancelStatus.recalculate</span>
    <span class="s0">with </span><span class="s1">ExitStack</span><span class="s2">() </span><span class="s0">as </span><span class="s1">exit_stack</span><span class="s2">:</span>
        <span class="s1">outermost_scope </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
        <span class="s1">exit_stack</span><span class="s2">.</span><span class="s1">enter_context</span><span class="s2">(</span><span class="s1">outermost_scope</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">5000</span><span class="s2">):</span>
            <span class="s1">exit_stack</span><span class="s2">.</span><span class="s1">enter_context</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">())</span>
        <span class="s1">outermost_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_deadline_duplicates</span><span class="s2">():</span>
    <span class="s4"># This exercises an assert in Deadlines._prune, by intentionally creating</span>
    <span class="s4"># duplicate entries in the deadline heap.</span>
    <span class="s1">now </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cscope</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">DEADLINE_HEAP_MIN_PRUNE_THRESHOLD </span><span class="s2">* </span><span class="s3">2</span><span class="s2">):</span>
            <span class="s1">cscope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">now </span><span class="s2">+ </span><span class="s3">9998</span>
            <span class="s1">cscope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">now </span><span class="s2">+ </span><span class="s3">9999</span>
        <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s3">0.01</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s5">&quot;cpython&quot;</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s2">)</span>
<span class="s0">async def </span><span class="s1">test_simple_cancel_scope_usage_doesnt_create_cyclic_garbage</span><span class="s2">():</span>
    <span class="s4"># https://github.com/python-trio/trio/issues/1770</span>
    <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">do_a_cancel</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cscope</span><span class="s2">:</span>
            <span class="s1">cscope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s1">old_flags </span><span class="s2">= </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">get_debug</span><span class="s2">()</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">gc</span><span class="s2">.</span><span class="s1">DEBUG_SAVEALL</span><span class="s2">)</span>

        <span class="s4"># cover outcome.Error.unwrap</span>
        <span class="s4"># (See https://github.com/python-trio/outcome/pull/29)</span>
        <span class="s0">await </span><span class="s1">do_a_cancel</span><span class="s2">()</span>
        <span class="s4"># cover outcome.Error.unwrap if unrolled_run hangs on to exception refs</span>
        <span class="s4"># (See https://github.com/python-trio/trio/pull/1864)</span>
        <span class="s0">await </span><span class="s1">do_a_cancel</span><span class="s2">()</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                <span class="s4"># cover NurseryManager.__aexit__</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>

        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s0">assert not </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">old_flags</span><span class="s2">)</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s5">&quot;cpython&quot;</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s2">)</span>
<span class="s0">async def </span><span class="s1">test_cancel_scope_exit_doesnt_create_cyclic_garbage</span><span class="s2">():</span>
    <span class="s4"># https://github.com/python-trio/trio/pull/2063</span>
    <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">crasher</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s1">old_flags </span><span class="s2">= </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">get_debug</span><span class="s2">()</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">), </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">outer</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
                <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
                <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">gc</span><span class="s2">.</span><span class="s1">DEBUG_SAVEALL</span><span class="s2">)</span>
                <span class="s4"># One child that gets cancelled by the outer scope</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
                <span class="s1">outer</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s4"># And one that raises a different error</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">crasher</span><span class="s2">)</span>
                <span class="s4"># so that outer filters a Cancelled from the MultiError and</span>
                <span class="s4"># covers CancelScope.__exit__ (and NurseryManager.__aexit__)</span>
                <span class="s4"># (See https://github.com/python-trio/trio/pull/2063)</span>

        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s0">assert not </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">old_flags</span><span class="s2">)</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">version_info </span><span class="s2">&gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">12</span><span class="s2">),</span>
    <span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;Waiting on https://github.com/python/cpython/issues/100964&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s5">&quot;cpython&quot;</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s2">)</span>
<span class="s0">async def </span><span class="s1">test_nursery_cancel_doesnt_create_cyclic_garbage</span><span class="s2">():</span>
    <span class="s4"># https://github.com/python-trio/trio/issues/1770#issuecomment-730229423</span>
    <span class="s0">def </span><span class="s1">toggle_collected</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">collected</span>
        <span class="s1">collected </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s1">collected </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
    <span class="s1">old_flags </span><span class="s2">= </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">get_debug</span><span class="s2">()</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">gc</span><span class="s2">.</span><span class="s1">DEBUG_SAVEALL</span><span class="s2">)</span>

        <span class="s4"># cover Nursery._nested_child_finished</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

        <span class="s1">weakref</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">toggle_collected</span><span class="s2">)</span>
        <span class="s0">del </span><span class="s1">nursery</span>
        <span class="s4"># a checkpoint clears the nursery from the internals, apparently</span>
        <span class="s4"># TODO: stop event loop from hanging on to the nursery at this point</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">collected</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">collect</span><span class="s2">()</span>
        <span class="s0">assert not </span><span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">set_debug</span><span class="s2">(</span><span class="s1">old_flags</span><span class="s2">)</span>
        <span class="s1">gc</span><span class="s2">.</span><span class="s1">garbage</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">!= </span><span class="s5">&quot;cpython&quot;</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s5">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s2">)</span>
<span class="s0">async def </span><span class="s1">test_locals_destroyed_promptly_on_cancel</span><span class="s2">():</span>
    <span class="s1">destroyed </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">finalizer</span><span class="s2">():</span>
        <span class="s0">nonlocal </span><span class="s1">destroyed</span>
        <span class="s1">destroyed </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">class </span><span class="s1">A</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">task</span><span class="s2">():</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">A</span><span class="s2">()</span>
        <span class="s1">weakref</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">finalizer</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>

    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">task</span><span class="s2">)</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">destroyed</span>


<span class="s0">def </span><span class="s1">test_run_strict_exception_groups</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that nurseries respect the global context setting of strict_exception_groups. 
    &quot;&quot;&quot;</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">():</span>
            <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s5">&quot;foo&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">, </span><span class="s1">strict_exception_groups</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]) </span><span class="s0">is </span><span class="s1">Exception</span>
    <span class="s0">assert </span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">].</span><span class="s1">args </span><span class="s2">== (</span><span class="s5">&quot;foo&quot;</span><span class="s2">,)</span>


<span class="s0">def </span><span class="s1">test_run_strict_exception_groups_nursery_override</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that a nursery can override the global context setting of 
    strict_exception_groups. 
    &quot;&quot;&quot;</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">(</span><span class="s1">strict_exception_groups</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s5">&quot;foo&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;foo&quot;</span><span class="s2">):</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">, </span><span class="s1">strict_exception_groups</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_nursery_strict_exception_groups</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test that strict exception groups can be enabled on a per-nursery basis.&quot;&quot;&quot;</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">(</span><span class="s1">strict_exception_groups</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s5">&quot;foo&quot;</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]) </span><span class="s0">is </span><span class="s1">Exception</span>
    <span class="s0">assert </span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">].</span><span class="s1">args </span><span class="s2">== (</span><span class="s5">&quot;foo&quot;</span><span class="s2">,)</span>


<span class="s0">async def </span><span class="s1">test_nursery_collapse_strict</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that a single exception from a nested nursery with strict semantics doesn't get 
    collapsed when CancelledErrors are stripped from it. 
    &quot;&quot;&quot;</span>

    <span class="s0">async def </span><span class="s1">raise_error</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;test error&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">raise_error</span><span class="s2">)</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">(</span><span class="s1">strict_exception_groups</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
                <span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
                <span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">raise_error</span><span class="s2">)</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s1">exceptions </span><span class="s2">= </span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">RuntimeError</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">MultiError</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">1</span><span class="s2">].</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">1</span><span class="s2">].</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">RuntimeError</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_nursery_collapse_loose</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that a single exception from a nested nursery with loose semantics gets 
    collapsed when CancelledErrors are stripped from it. 
    &quot;&quot;&quot;</span>

    <span class="s0">async def </span><span class="s1">raise_error</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;test error&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">MultiError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">raise_error</span><span class="s2">)</span>
            <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery2</span><span class="s2">:</span>
                <span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sleep_forever</span><span class="s2">)</span>
                <span class="s1">nursery2</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">raise_error</span><span class="s2">)</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s1">exceptions </span><span class="s2">= </span><span class="s1">exc</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">exceptions</span>
    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">RuntimeError</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exceptions</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">RuntimeError</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_no_cancellederror</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that when a cancel scope encounters an exception group that does NOT contain 
    a Cancelled exception, it will NOT set the ``cancelled_caught`` flag. 
    &quot;&quot;&quot;</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ExceptionGroup</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
            <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
            <span class="s0">raise </span><span class="s1">ExceptionGroup</span><span class="s2">(</span><span class="s5">&quot;test&quot;</span><span class="s2">, [</span><span class="s1">RuntimeError</span><span class="s2">(), </span><span class="s1">RuntimeError</span><span class="s2">()])</span>

    <span class="s0">assert not </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>
</pre>
</body>
</html>