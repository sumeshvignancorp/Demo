<html>
<head>
<title>test_threads.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_threads.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextvars</span>
<span class="s0">import </span><span class="s1">queue </span><span class="s0">as </span><span class="s1">stdlib_queue</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span><span class="s2">, </span><span class="s1">Optional</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">sniffio </span><span class="s0">import </span><span class="s1">current_async_library_cvar</span>

<span class="s0">from </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">TrioToken</span><span class="s2">, </span><span class="s1">current_trio_token</span>

<span class="s0">from </span><span class="s2">.. </span><span class="s0">import </span><span class="s1">CapacityLimiter</span><span class="s2">, </span><span class="s1">Event</span><span class="s2">, </span><span class="s1">_core</span><span class="s2">, </span><span class="s1">sleep</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_tests</span><span class="s2">.</span><span class="s1">test_ki </span><span class="s0">import </span><span class="s1">ki_self</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_tests</span><span class="s2">.</span><span class="s1">tutil </span><span class="s0">import </span><span class="s1">buggy_pypy_asyncgens</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_threads </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">current_default_thread_limiter</span><span class="s2">,</span>
    <span class="s1">from_thread_run</span><span class="s2">,</span>
    <span class="s1">from_thread_run_sync</span><span class="s2">,</span>
    <span class="s1">to_thread_run_sync</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">wait_all_tasks_blocked</span>


<span class="s0">async def </span><span class="s1">test_do_in_trio_thread</span><span class="s2">():</span>
    <span class="s1">trio_thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">check_case</span><span class="s2">(</span><span class="s1">do_in_trio_thread</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">record </span><span class="s2">= []</span>

        <span class="s0">def </span><span class="s1">threadfn</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;start&quot;</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()))</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">do_in_trio_thread</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">, </span><span class="s1">record</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">trio_token</span><span class="s2">)</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;got&quot;</span><span class="s2">, </span><span class="s1">x</span><span class="s2">))</span>
            <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">)</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">)))</span>

        <span class="s1">child_thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">(</span><span class="s1">target</span><span class="s2">=</span><span class="s1">threadfn</span><span class="s2">, </span><span class="s1">daemon</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">child_thread</span><span class="s2">.</span><span class="s1">start</span><span class="s2">()</span>
        <span class="s0">while </span><span class="s1">child_thread</span><span class="s2">.</span><span class="s1">is_alive</span><span class="s2">():</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;yawn&quot;</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [(</span><span class="s3">&quot;start&quot;</span><span class="s2">, </span><span class="s1">child_thread</span><span class="s2">), (</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s1">trio_thread</span><span class="s2">), </span><span class="s1">expected</span><span class="s2">]</span>

    <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()))</span>
        <span class="s0">return </span><span class="s4">2</span>

    <span class="s0">await </span><span class="s1">check_case</span><span class="s2">(</span><span class="s1">from_thread_run_sync</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, (</span><span class="s3">&quot;got&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s2">), </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()))</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">await </span><span class="s1">check_case</span><span class="s2">(</span><span class="s1">from_thread_run_sync</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, (</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">), </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()))</span>
        <span class="s0">return </span><span class="s4">3</span>

    <span class="s0">await </span><span class="s1">check_case</span><span class="s2">(</span><span class="s1">from_thread_run</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, (</span><span class="s3">&quot;got&quot;</span><span class="s2">, </span><span class="s4">3</span><span class="s2">), </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">record</span><span class="s2">):</span>
        <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">&quot;f&quot;</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()))</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">await </span><span class="s1">check_case</span><span class="s2">(</span><span class="s1">from_thread_run</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, (</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">), </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_do_in_trio_thread_from_trio_thread</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)  </span><span class="s5"># pragma: no branch</span>

    <span class="s0">async def </span><span class="s1">foo</span><span class="s2">():  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">from_thread_run</span><span class="s2">(</span><span class="s1">foo</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_run_in_trio_thread_ki</span><span class="s2">():</span>
    <span class="s5"># if we get a control-C during a run_in_trio_thread, then it propagates</span>
    <span class="s5"># back to the caller (slick!)</span>
    <span class="s1">record </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">check_run_in_trio_thread</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">trio_thread_fn</span><span class="s2">():</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;in Trio thread&quot;</span><span class="s2">)</span>
            <span class="s0">assert not </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">currently_ki_protected</span><span class="s2">()</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;ki_self&quot;</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">ki_self</span><span class="s2">()</span>
            <span class="s0">finally</span><span class="s2">:</span>
                <span class="s0">import </span><span class="s1">sys</span>

                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;finally&quot;</span><span class="s2">, </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">exc_info</span><span class="s2">())</span>

        <span class="s0">async def </span><span class="s1">trio_thread_afn</span><span class="s2">():</span>
            <span class="s1">trio_thread_fn</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">external_thread_fn</span><span class="s2">():</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;running&quot;</span><span class="s2">)</span>
                <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">trio_thread_fn</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">KeyboardInterrupt</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;ok1&quot;</span><span class="s2">)</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s3">&quot;ok1&quot;</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">from_thread_run</span><span class="s2">(</span><span class="s1">trio_thread_afn</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">KeyboardInterrupt</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;ok2&quot;</span><span class="s2">)</span>
                <span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s3">&quot;ok2&quot;</span><span class="s2">)</span>

        <span class="s1">thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">(</span><span class="s1">target</span><span class="s2">=</span><span class="s1">external_thread_fn</span><span class="s2">)</span>
        <span class="s1">thread</span><span class="s2">.</span><span class="s1">start</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;waiting&quot;</span><span class="s2">)</span>
        <span class="s0">while </span><span class="s1">thread</span><span class="s2">.</span><span class="s1">is_alive</span><span class="s2">():</span>
            <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;waited, joining&quot;</span><span class="s2">)</span>
        <span class="s1">thread</span><span class="s2">.</span><span class="s1">join</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;done&quot;</span><span class="s2">)</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">check_run_in_trio_thread</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== {</span><span class="s3">&quot;ok1&quot;</span><span class="s2">, </span><span class="s3">&quot;ok2&quot;</span><span class="s2">}</span>


<span class="s0">def </span><span class="s1">test_await_in_trio_thread_while_main_exits</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">ev </span><span class="s2">= </span><span class="s1">Event</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">trio_fn</span><span class="s2">():</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;sleeping&quot;</span><span class="s2">)</span>
        <span class="s1">ev</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">SUCCEEDED</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">(</span><span class="s1">token</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">from_thread_run</span><span class="s2">(</span><span class="s1">trio_fn</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;cancelled&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
        <span class="s1">thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">(</span><span class="s1">target</span><span class="s2">=</span><span class="s1">thread_fn</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(</span><span class="s1">token</span><span class="s2">,))</span>
        <span class="s1">thread</span><span class="s2">.</span><span class="s1">start</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">ev</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;sleeping&quot;</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">thread</span>

    <span class="s1">thread </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s1">thread</span><span class="s2">.</span><span class="s1">join</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;sleeping&quot;</span><span class="s2">, </span><span class="s3">&quot;cancelled&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_named_thread</span><span class="s2">():</span>
    <span class="s1">ending </span><span class="s2">= </span><span class="s3">&quot; from trio._tests.test_threads.test_named_thread&quot;</span>

    <span class="s0">def </span><span class="s1">inner</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s3">&quot;inner&quot; </span><span class="s2">+ </span><span class="s1">ending</span><span class="s2">) </span><span class="s1">-&gt; threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">().</span><span class="s1">name </span><span class="s2">== </span><span class="s1">name</span>
        <span class="s0">return </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s0">None</span><span class="s2">], </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>

    <span class="s5"># test defaults</span>
    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">, </span><span class="s1">thread_name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s5"># functools.partial doesn't have __name__, so defaults to None</span>
    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s3">&quot;None&quot; </span><span class="s2">+ </span><span class="s1">ending</span><span class="s2">))</span>

    <span class="s5"># test that you can set a custom name, and that it's reset afterwards</span>
    <span class="s0">async def </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">thread </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">name</span><span class="s2">), </span><span class="s1">thread_name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s3">&quot;Trio thread [0-9]*&quot;</span><span class="s2">, </span><span class="s1">thread</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;fobiedoo&quot;</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;name_longer_than_15_characters&quot;</span><span class="s2">)</span>

    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;💙&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_thread_name</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
    <span class="s0">import </span><span class="s1">ctypes</span>
    <span class="s0">import </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util</span>

    <span class="s1">libpthread_path </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">find_library</span><span class="s2">(</span><span class="s3">&quot;pthread&quot;</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">libpthread_path</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;no pthread on </span><span class="s0">{</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s2">)</span>
        <span class="s0">return None</span>
    <span class="s1">libpthread </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">CDLL</span><span class="s2">(</span><span class="s1">libpthread_path</span><span class="s2">)</span>

    <span class="s1">pthread_getname_np </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">libpthread</span><span class="s2">, </span><span class="s3">&quot;pthread_getname_np&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s5"># this should never fail on any platforms afaik</span>
    <span class="s0">assert </span><span class="s1">pthread_getname_np</span>

    <span class="s5"># thankfully getname signature doesn't differ between platforms</span>
    <span class="s1">pthread_getname_np</span><span class="s2">.</span><span class="s1">argtypes </span><span class="s2">= [</span>
        <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_void_p</span><span class="s2">,</span>
        <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_char_p</span><span class="s2">,</span>
        <span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_size_t</span><span class="s2">,</span>
    <span class="s2">]</span>
    <span class="s1">pthread_getname_np</span><span class="s2">.</span><span class="s1">restype </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">c_int</span>

    <span class="s1">name_buffer </span><span class="s2">= </span><span class="s1">ctypes</span><span class="s2">.</span><span class="s1">create_string_buffer</span><span class="s2">(</span><span class="s6">b&quot;&quot;</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=</span><span class="s4">16</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ident </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">ident </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">get_ident</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">pthread_getname_np</span><span class="s2">(</span><span class="s1">ident</span><span class="s2">, </span><span class="s1">name_buffer</span><span class="s2">, </span><span class="s4">16</span><span class="s2">) == </span><span class="s4">0</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">name_buffer</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">decode</span><span class="s2">()</span>
    <span class="s0">except </span><span class="s1">UnicodeDecodeError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:  </span><span class="s5"># pragma: no cover</span>
        <span class="s5"># used for debugging when testing via CI</span>
        <span class="s1">pytest</span><span class="s2">.</span><span class="s1">fail</span><span class="s2">(</span><span class="s3">f&quot;value: </span><span class="s0">{</span><span class="s1">name_buffer</span><span class="s2">.</span><span class="s1">value</span><span class="s0">!r}</span><span class="s3">, exception: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>


<span class="s5"># test os thread naming</span>
<span class="s5"># this depends on pthread being available, which is the case on 99.9% of linux machines</span>
<span class="s5"># and most mac machines. So unless the platform is linux it will just skip</span>
<span class="s5"># in case it fails to fetch the os thread name.</span>
<span class="s0">async def </span><span class="s1">test_named_thread_os</span><span class="s2">():</span>
    <span class="s0">def </span><span class="s1">inner</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) </span><span class="s1">-&gt; threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">:</span>
        <span class="s1">os_thread_name </span><span class="s2">= </span><span class="s1">_get_thread_name</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">os_thread_name </span><span class="s0">is None and </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">!= </span><span class="s3">&quot;linux&quot;</span><span class="s2">:</span>
            <span class="s1">pytest</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s3">f&quot;no pthread OS support on </span><span class="s0">{</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">os_thread_name </span><span class="s2">== </span><span class="s1">name</span><span class="s2">[:</span><span class="s4">15</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s0">None</span><span class="s2">], </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Thread</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>

    <span class="s5"># test defaults</span>
    <span class="s1">default </span><span class="s2">= </span><span class="s3">&quot;None from trio._tests.test_threads.test_named_thread&quot;</span>
    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">default</span><span class="s2">))</span>
    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">default</span><span class="s2">), </span><span class="s1">thread_name</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s5"># test that you can set a custom name, and that it's reset afterwards</span>
    <span class="s0">async def </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">expected </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">expected </span><span class="s2">= </span><span class="s1">name</span>
        <span class="s1">thread </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">expected</span><span class="s2">), </span><span class="s1">thread_name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s1">os_thread_name </span><span class="s2">= </span><span class="s1">_get_thread_name</span><span class="s2">(</span><span class="s1">thread</span><span class="s2">.</span><span class="s1">ident</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">os_thread_name </span><span class="s0">is not None</span><span class="s2">, </span><span class="s3">&quot;should skip earlier if this is the case&quot;</span>
        <span class="s0">assert </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s3">&quot;Trio thread [0-9]*&quot;</span><span class="s2">, </span><span class="s1">os_thread_name</span><span class="s2">)</span>

    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;fobiedoo&quot;</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;name_longer_than_15_characters&quot;</span><span class="s2">)</span>

    <span class="s0">await </span><span class="s1">test_thread_name</span><span class="s2">(</span><span class="s3">&quot;💙&quot;</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">=</span><span class="s3">&quot;?&quot;</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_has_pthread_setname_np</span><span class="s2">():</span>
    <span class="s0">from </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_thread_cache </span><span class="s0">import </span><span class="s1">get_os_thread_name_func</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s1">get_os_thread_name_func</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">k </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform </span><span class="s2">!= </span><span class="s3">&quot;linux&quot;</span>
        <span class="s1">pytest</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s3">f&quot;no pthread_setname_np on </span><span class="s0">{</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">platform</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_run_in_worker_thread</span><span class="s2">():</span>
    <span class="s1">trio_thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">())</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">child_thread </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">x </span><span class="s2">== </span><span class="s4">1</span>
    <span class="s0">assert </span><span class="s1">child_thread </span><span class="s2">!= </span><span class="s1">trio_thread</span>

    <span class="s0">def </span><span class="s1">g</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">())</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s1">trio_thread</span>


<span class="s0">async def </span><span class="s1">test_run_in_worker_thread_cancellation</span><span class="s2">():</span>
    <span class="s1">register </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">q</span><span class="s2">):</span>
        <span class="s5"># Make the thread block for a controlled amount of time</span>
        <span class="s1">register</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s3">&quot;blocking&quot;</span>
        <span class="s1">q</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">register</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s3">&quot;finished&quot;</span>

    <span class="s0">async def </span><span class="s1">child</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">cancellable</span><span class="s2">):</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;start&quot;</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">cancellable</span><span class="s2">=</span><span class="s1">cancellable</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;exit&quot;</span><span class="s2">)</span>

    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">q </span><span class="s2">= </span><span class="s1">stdlib_queue</span><span class="s2">.</span><span class="s1">Queue</span><span class="s2">()</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>
        <span class="s5"># Give it a chance to get started. (This is important because</span>
        <span class="s5"># to_thread_run_sync does a checkpoint_if_cancelled before</span>
        <span class="s5"># blocking on the thread, and we don't want to trigger this.)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;start&quot;</span><span class="s2">]</span>
        <span class="s5"># Then cancel it.</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
    <span class="s5"># The task exited, but the thread didn't:</span>
    <span class="s0">assert </span><span class="s1">register</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s3">&quot;finished&quot;</span>
    <span class="s5"># Put the thread out of its misery:</span>
    <span class="s1">q</span><span class="s2">.</span><span class="s1">put</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">while </span><span class="s1">register</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s3">&quot;finished&quot;</span><span class="s2">:</span>
        <span class="s1">time</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)</span>

    <span class="s5"># This one can't be cancelled</span>
    <span class="s1">record </span><span class="s2">= []</span>
    <span class="s1">register</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s0">None</span>
    <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
        <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">shield</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s5"># It's still running</span>
        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;start&quot;</span><span class="s2">]</span>
        <span class="s1">q</span><span class="s2">.</span><span class="s1">put</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s5"># Now it exits</span>

    <span class="s5"># But if we cancel *before* it enters, the entry is itself a cancellation</span>
    <span class="s5"># point</span>
    <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">scope</span><span class="s2">:</span>
        <span class="s1">scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
        <span class="s0">await </span><span class="s1">child</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>


<span class="s5"># Make sure that if trio.run exits, and then the thread finishes, then that's</span>
<span class="s5"># handled gracefully. (Requires that the thread result machinery be prepared</span>
<span class="s5"># for call_soon to raise RunFinishedError.)</span>
<span class="s0">def </span><span class="s1">test_run_in_worker_thread_abandoned</span><span class="s2">(</span><span class="s1">capfd</span><span class="s2">, </span><span class="s1">monkeypatch</span><span class="s2">):</span>
    <span class="s1">monkeypatch</span><span class="s2">.</span><span class="s1">setattr</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_thread_cache</span><span class="s2">, </span><span class="s3">&quot;IDLE_TIMEOUT&quot;</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">)</span>

    <span class="s1">q1 </span><span class="s2">= </span><span class="s1">stdlib_queue</span><span class="s2">.</span><span class="s1">Queue</span><span class="s2">()</span>
    <span class="s1">q2 </span><span class="s2">= </span><span class="s1">stdlib_queue</span><span class="s2">.</span><span class="s1">Queue</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">q1</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">q2</span><span class="s2">.</span><span class="s1">put</span><span class="s2">(</span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">())</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s0">async def </span><span class="s1">child</span><span class="s2">():</span>
            <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">, </span><span class="s1">cancellable</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>

    <span class="s1">q1</span><span class="s2">.</span><span class="s1">put</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
    <span class="s5"># This makes sure:</span>
    <span class="s5"># - the thread actually ran</span>
    <span class="s5"># - that thread has finished before we check for its output</span>
    <span class="s1">thread </span><span class="s2">= </span><span class="s1">q2</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s0">while </span><span class="s1">thread</span><span class="s2">.</span><span class="s1">is_alive</span><span class="s2">():</span>
        <span class="s1">time</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)  </span><span class="s5"># pragma: no cover</span>

    <span class="s5"># Make sure we don't have a &quot;Exception in thread ...&quot; dump to the console:</span>
    <span class="s1">out</span><span class="s2">, </span><span class="s1">err </span><span class="s2">= </span><span class="s1">capfd</span><span class="s2">.</span><span class="s1">readouterr</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s3">&quot;Exception in thread&quot; </span><span class="s0">not in </span><span class="s1">out</span>
    <span class="s0">assert </span><span class="s3">&quot;Exception in thread&quot; </span><span class="s0">not in </span><span class="s1">err</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;MAX&quot;</span><span class="s2">, [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">])</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;cancel&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;use_default_limiter&quot;</span><span class="s2">, [</span><span class="s0">False</span><span class="s2">, </span><span class="s0">True</span><span class="s2">])</span>
<span class="s0">async def </span><span class="s1">test_run_in_worker_thread_limiter</span><span class="s2">(</span><span class="s1">MAX</span><span class="s2">, </span><span class="s1">cancel</span><span class="s2">, </span><span class="s1">use_default_limiter</span><span class="s2">):</span>
    <span class="s5"># This test is a bit tricky. The goal is to make sure that if we set</span>
    <span class="s5"># limiter=CapacityLimiter(MAX), then in fact only MAX threads are ever</span>
    <span class="s5"># running at a time, even if there are more concurrent calls to</span>
    <span class="s5"># to_thread_run_sync, and even if some of those are cancelled. And</span>
    <span class="s5"># also to make sure that the default limiter actually limits.</span>
    <span class="s1">COUNT </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">MAX</span>
    <span class="s1">gate </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
    <span class="s1">lock </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">Lock</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">use_default_limiter</span><span class="s2">:</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">current_default_thread_limiter</span><span class="s2">()</span>
        <span class="s1">orig_total_tokens </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">total_tokens</span>
        <span class="s1">c</span><span class="s2">.</span><span class="s1">total_tokens </span><span class="s2">= </span><span class="s1">MAX</span>
        <span class="s1">limiter_arg </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">CapacityLimiter</span><span class="s2">(</span><span class="s1">MAX</span><span class="s2">)</span>
        <span class="s1">orig_total_tokens </span><span class="s2">= </span><span class="s1">MAX</span>
        <span class="s1">limiter_arg </span><span class="s2">= </span><span class="s1">c</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s5"># We used to use regular variables and 'nonlocal' here, but it turns</span>
        <span class="s5"># out that it's not safe to assign to closed-over variables that are</span>
        <span class="s5"># visible in multiple threads, at least as of CPython 3.10 and PyPy</span>
        <span class="s5"># 7.3:</span>
        <span class="s5">#</span>
        <span class="s5">#   https://bugs.python.org/issue30744</span>
        <span class="s5">#   https://bitbucket.org/pypy/pypy/issues/2591/</span>
        <span class="s5">#</span>
        <span class="s5"># Mutating them in-place is OK though (as long as you use proper</span>
        <span class="s5"># locking etc.).</span>
        <span class="s0">class </span><span class="s1">state</span><span class="s2">:</span>
            <span class="s0">pass</span>

        <span class="s1">state</span><span class="s2">.</span><span class="s1">ran </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">high_water </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">running </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">state</span><span class="s2">.</span><span class="s1">parked </span><span class="s2">= </span><span class="s4">0</span>

        <span class="s1">token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">(</span><span class="s1">cancel_scope</span><span class="s2">):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;thread_fn start&quot;</span><span class="s2">)</span>
            <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>
            <span class="s0">with </span><span class="s1">lock</span><span class="s2">:</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">ran </span><span class="s2">+= </span><span class="s4">1</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">running </span><span class="s2">+= </span><span class="s4">1</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">high_water </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">state</span><span class="s2">.</span><span class="s1">high_water</span><span class="s2">, </span><span class="s1">state</span><span class="s2">.</span><span class="s1">running</span><span class="s2">)</span>
                <span class="s5"># The Trio thread below watches this value and uses it as a</span>
                <span class="s5"># signal that all the stats calculations have finished.</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">parked </span><span class="s2">+= </span><span class="s4">1</span>
            <span class="s1">gate</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
            <span class="s0">with </span><span class="s1">lock</span><span class="s2">:</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">parked </span><span class="s2">-= </span><span class="s4">1</span>
                <span class="s1">state</span><span class="s2">.</span><span class="s1">running </span><span class="s2">-= </span><span class="s4">1</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;thread_fn exiting&quot;</span><span class="s2">)</span>

        <span class="s0">async def </span><span class="s1">run_thread</span><span class="s2">(</span><span class="s1">event</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cancel_scope</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span>
                    <span class="s1">thread_fn</span><span class="s2">, </span><span class="s1">cancel_scope</span><span class="s2">, </span><span class="s1">limiter</span><span class="s2">=</span><span class="s1">limiter_arg</span><span class="s2">, </span><span class="s1">cancellable</span><span class="s2">=</span><span class="s1">cancel</span>
                <span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;run_thread finished, cancelled:&quot;</span><span class="s2">, </span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span><span class="s2">)</span>
            <span class="s1">event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

        <span class="s0">async with </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;spawning&quot;</span><span class="s2">)</span>
            <span class="s1">events </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">COUNT</span><span class="s2">):</span>
                <span class="s1">events</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">Event</span><span class="s2">())</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">run_thread</span><span class="s2">, </span><span class="s1">events</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">])</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s5"># In the cancel case, we in particular want to make sure that the</span>
            <span class="s5"># cancelled tasks don't release the semaphore. So let's wait until</span>
            <span class="s5"># at least one of them has exited, and that everything has had a</span>
            <span class="s5"># chance to settle down from this, before we check that everyone</span>
            <span class="s5"># who's supposed to be waiting is waiting:</span>
            <span class="s0">if </span><span class="s1">cancel</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;waiting for first cancellation to clear&quot;</span><span class="s2">)</span>
                <span class="s0">await </span><span class="s1">events</span><span class="s2">[</span><span class="s4">0</span><span class="s2">].</span><span class="s1">wait</span><span class="s2">()</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s5"># Then wait until the first MAX threads are parked in gate.wait(),</span>
            <span class="s5"># and the next MAX threads are parked on the semaphore, to make</span>
            <span class="s5"># sure no-one is sneaking past, and to make sure the high_water</span>
            <span class="s5"># check below won't fail due to scheduling issues. (It could still</span>
            <span class="s5"># fail if too many threads are let through here.)</span>
            <span class="s0">while </span><span class="s1">state</span><span class="s2">.</span><span class="s1">parked </span><span class="s2">!= </span><span class="s1">MAX </span><span class="s0">or </span><span class="s1">c</span><span class="s2">.</span><span class="s1">statistics</span><span class="s2">().</span><span class="s1">tasks_waiting </span><span class="s2">!= </span><span class="s1">MAX</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)  </span><span class="s5"># pragma: no cover</span>
            <span class="s5"># Then release the threads</span>
            <span class="s1">gate</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">high_water </span><span class="s2">== </span><span class="s1">MAX</span>

        <span class="s0">if </span><span class="s1">cancel</span><span class="s2">:</span>
            <span class="s5"># Some threads might still be running; need to wait to them to</span>
            <span class="s5"># finish before checking that all threads ran. We can do this</span>
            <span class="s5"># using the CapacityLimiter.</span>
            <span class="s0">while </span><span class="s1">c</span><span class="s2">.</span><span class="s1">borrowed_tokens </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">sleep</span><span class="s2">(</span><span class="s4">0.01</span><span class="s2">)  </span><span class="s5"># pragma: no cover</span>

        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">ran </span><span class="s2">== </span><span class="s1">COUNT</span>
        <span class="s0">assert </span><span class="s1">state</span><span class="s2">.</span><span class="s1">running </span><span class="s2">== </span><span class="s4">0</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">c</span><span class="s2">.</span><span class="s1">total_tokens </span><span class="s2">= </span><span class="s1">orig_total_tokens</span>


<span class="s0">async def </span><span class="s1">test_run_in_worker_thread_custom_limiter</span><span class="s2">():</span>
    <span class="s5"># Basically just checking that we only call acquire_on_behalf_of and</span>
    <span class="s5"># release_on_behalf_of, since that's part of our documented API.</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">class </span><span class="s1">CustomLimiter</span><span class="s2">:</span>
        <span class="s0">async def </span><span class="s1">acquire_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;acquire&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_borrower </span><span class="s2">= </span><span class="s1">borrower</span>

        <span class="s0">def </span><span class="s1">release_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;release&quot;</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">borrower </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrower</span>

    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">, </span><span class="s1">limiter</span><span class="s2">=</span><span class="s1">CustomLimiter</span><span class="s2">())</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;acquire&quot;</span><span class="s2">, </span><span class="s3">&quot;release&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_run_in_worker_thread_limiter_error</span><span class="s2">():</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">class </span><span class="s1">BadCapacityLimiter</span><span class="s2">:</span>
        <span class="s0">async def </span><span class="s1">acquire_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;acquire&quot;</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">release_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;release&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s1">bs </span><span class="s2">= </span><span class="s1">BadCapacityLimiter</span><span class="s2">()</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">, </span><span class="s1">limiter</span><span class="s2">=</span><span class="s1">bs</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;acquire&quot;</span><span class="s2">, </span><span class="s3">&quot;release&quot;</span><span class="s2">]</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s5"># If the original function raised an error, then the semaphore error</span>
    <span class="s5"># chains with it</span>
    <span class="s1">d </span><span class="s2">= {}</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">d</span><span class="s2">[</span><span class="s3">&quot;x&quot;</span><span class="s2">], </span><span class="s1">limiter</span><span class="s2">=</span><span class="s1">bs</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;acquire&quot;</span><span class="s2">, </span><span class="s3">&quot;release&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_run_in_worker_thread_fail_to_spawn</span><span class="s2">(</span><span class="s1">monkeypatch</span><span class="s2">):</span>
    <span class="s5"># Test the unlikely but possible case where trying to spawn a thread fails</span>
    <span class="s0">def </span><span class="s1">bad_start</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">&quot;the engines canna take it captain&quot;</span><span class="s2">)</span>

    <span class="s1">monkeypatch</span><span class="s2">.</span><span class="s1">setattr</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_thread_cache</span><span class="s2">.</span><span class="s1">ThreadCache</span><span class="s2">, </span><span class="s3">&quot;start_thread_soon&quot;</span><span class="s2">, </span><span class="s1">bad_start</span><span class="s2">)</span>

    <span class="s1">limiter </span><span class="s2">= </span><span class="s1">current_default_thread_limiter</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">limiter</span><span class="s2">.</span><span class="s1">borrowed_tokens </span><span class="s2">== </span><span class="s4">0</span>

    <span class="s5"># We get an appropriate error, and the limiter is cleanly released</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)  </span><span class="s5"># pragma: no cover</span>
    <span class="s0">assert </span><span class="s3">&quot;engines&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">limiter</span><span class="s2">.</span><span class="s1">borrowed_tokens </span><span class="s2">== </span><span class="s4">0</span>


<span class="s0">async def </span><span class="s1">test_trio_to_thread_run_sync_token</span><span class="s2">():</span>
    <span class="s5"># Test that to_thread_run_sync automatically injects the current trio token</span>
    <span class="s5"># into a spawned thread</span>
    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">callee_token </span><span class="s2">= </span><span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">callee_token</span>

    <span class="s1">caller_token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">callee_token </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">callee_token </span><span class="s2">== </span><span class="s1">caller_token</span>


<span class="s0">async def </span><span class="s1">test_trio_to_thread_run_sync_expected_error</span><span class="s2">():</span>
    <span class="s5"># Test correct error when passed async function</span>
    <span class="s0">async def </span><span class="s1">async_fn</span><span class="s2">():  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s3">&quot;expected a sync function&quot;</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">async_fn</span><span class="s2">)</span>


<span class="s1">trio_test_contextvar </span><span class="s2">= </span><span class="s1">contextvars</span><span class="s2">.</span><span class="s1">ContextVar</span><span class="s2">(</span><span class="s3">&quot;trio_test_contextvar&quot;</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_trio_to_thread_run_sync_contextvars</span><span class="s2">():</span>
    <span class="s1">trio_thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>
    <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;main&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">():</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">sniffio_cvar_value</span><span class="s2">, </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">())</span>

    <span class="s1">value</span><span class="s2">, </span><span class="s1">sniffio_cvar_value</span><span class="s2">, </span><span class="s1">child_thread </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">value </span><span class="s2">== </span><span class="s3">&quot;main&quot;</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_value </span><span class="s2">== </span><span class="s0">None</span>
    <span class="s0">assert </span><span class="s1">child_thread </span><span class="s2">!= </span><span class="s1">trio_thread</span>

    <span class="s0">def </span><span class="s1">g</span><span class="s2">():</span>
        <span class="s1">parent_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;worker&quot;</span><span class="s2">)</span>
        <span class="s1">inner_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">parent_value</span><span class="s2">,</span>
            <span class="s1">inner_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_value</span><span class="s2">,</span>
            <span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">(),</span>
        <span class="s2">)</span>

    <span class="s2">(</span>
        <span class="s1">parent_value</span><span class="s2">,</span>
        <span class="s1">inner_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_value</span><span class="s2">,</span>
        <span class="s1">child_thread</span><span class="s2">,</span>
    <span class="s2">) = </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">g</span><span class="s2">)</span>
    <span class="s1">current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s1">sniffio_outer_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">parent_value </span><span class="s2">== </span><span class="s3">&quot;main&quot;</span>
    <span class="s0">assert </span><span class="s1">inner_value </span><span class="s2">== </span><span class="s3">&quot;worker&quot;</span>
    <span class="s0">assert </span><span class="s1">current_value </span><span class="s2">== </span><span class="s3">&quot;main&quot;</span><span class="s2">, (</span>
        <span class="s3">&quot;The contextvar value set on the worker would not propagate back to the main&quot;</span>
        <span class="s3">&quot; thread&quot;</span>
    <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_value </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">sniffio_outer_value </span><span class="s2">== </span><span class="s3">&quot;trio&quot;</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_run_sync</span><span class="s2">():</span>
    <span class="s5"># Test that to_thread_run_sync correctly &quot;hands off&quot; the trio token to</span>
    <span class="s5"># trio.from_thread.run_sync()</span>
    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">trio_time </span><span class="s2">= </span><span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">trio_time</span>

    <span class="s1">trio_time </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">trio_time</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>

    <span class="s5"># Test correct error when passed async function</span>
    <span class="s0">async def </span><span class="s1">async_fn</span><span class="s2">():  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">async_fn</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s3">&quot;expected a sync function&quot;</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_run</span><span class="s2">():</span>
    <span class="s5"># Test that to_thread_run_sync correctly &quot;hands off&quot; the trio token to</span>
    <span class="s5"># trio.from_thread.run()</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">back_in_trio_fn</span><span class="s2">():</span>
        <span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()  </span><span class="s5"># implicitly checks that we're in trio</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;back in trio&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;in thread&quot;</span><span class="s2">)</span>
        <span class="s1">from_thread_run</span><span class="s2">(</span><span class="s1">back_in_trio_fn</span><span class="s2">)</span>

    <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;in thread&quot;</span><span class="s2">, </span><span class="s3">&quot;back in trio&quot;</span><span class="s2">]</span>

    <span class="s5"># Test correct error when passed sync function</span>
    <span class="s0">def </span><span class="s1">sync_fn</span><span class="s2">():  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s3">&quot;appears to be synchronous&quot;</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">from_thread_run</span><span class="s2">, </span><span class="s1">sync_fn</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_token</span><span class="s2">():</span>
    <span class="s5"># Test that to_thread_run_sync and spawned trio.from_thread.run_sync()</span>
    <span class="s5"># share the same Trio token</span>
    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">callee_token </span><span class="s2">= </span><span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">callee_token</span>

    <span class="s1">caller_token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">callee_token </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">callee_token </span><span class="s2">== </span><span class="s1">caller_token</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_token_kwarg</span><span class="s2">():</span>
    <span class="s5"># Test that to_thread_run_sync and spawned trio.from_thread.run_sync() can</span>
    <span class="s5"># use an explicitly defined token</span>
    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">(</span><span class="s1">token</span><span class="s2">):</span>
        <span class="s1">callee_token </span><span class="s2">= </span><span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">token</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">callee_token</span>

    <span class="s1">caller_token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s1">callee_token </span><span class="s2">= </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">, </span><span class="s1">caller_token</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">callee_token </span><span class="s2">== </span><span class="s1">caller_token</span>


<span class="s0">async def </span><span class="s1">test_from_thread_no_token</span><span class="s2">():</span>
    <span class="s5"># Test that a &quot;raw call&quot; to trio.from_thread.run() fails because no token</span>
    <span class="s5"># has been provided</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_run_sync_contextvars</span><span class="s2">():</span>
    <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;main&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">thread_parent_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;worker&quot;</span><span class="s2">)</span>
        <span class="s1">thread_current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_thread_pre_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">back_in_main</span><span class="s2">():</span>
            <span class="s1">back_parent_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;back_in_main&quot;</span><span class="s2">)</span>
            <span class="s1">back_current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s1">sniffio_cvar_back_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">back_parent_value</span><span class="s2">, </span><span class="s1">back_current_value</span><span class="s2">, </span><span class="s1">sniffio_cvar_back_value</span>

        <span class="s2">(</span>
            <span class="s1">back_parent_value</span><span class="s2">,</span>
            <span class="s1">back_current_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
        <span class="s2">) = </span><span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">back_in_main</span><span class="s2">)</span>
        <span class="s1">thread_after_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_thread_after_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">thread_parent_value</span><span class="s2">,</span>
            <span class="s1">thread_current_value</span><span class="s2">,</span>
            <span class="s1">thread_after_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_thread_pre_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_thread_after_value</span><span class="s2">,</span>
            <span class="s1">back_parent_value</span><span class="s2">,</span>
            <span class="s1">back_current_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">(</span>
        <span class="s1">thread_parent_value</span><span class="s2">,</span>
        <span class="s1">thread_current_value</span><span class="s2">,</span>
        <span class="s1">thread_after_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_thread_pre_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_thread_after_value</span><span class="s2">,</span>
        <span class="s1">back_parent_value</span><span class="s2">,</span>
        <span class="s1">back_current_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
    <span class="s2">) = </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s1">current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s1">sniffio_cvar_out_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">current_value </span><span class="s2">== </span><span class="s1">thread_parent_value </span><span class="s2">== </span><span class="s3">&quot;main&quot;</span>
    <span class="s0">assert </span><span class="s1">thread_current_value </span><span class="s2">== </span><span class="s1">back_parent_value </span><span class="s2">== </span><span class="s1">thread_after_value </span><span class="s2">== </span><span class="s3">&quot;worker&quot;</span>
    <span class="s0">assert </span><span class="s1">back_current_value </span><span class="s2">== </span><span class="s3">&quot;back_in_main&quot;</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_out_value </span><span class="s2">== </span><span class="s1">sniffio_cvar_back_value </span><span class="s2">== </span><span class="s3">&quot;trio&quot;</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_thread_pre_value </span><span class="s2">== </span><span class="s1">sniffio_cvar_thread_after_value </span><span class="s2">== </span><span class="s0">None</span>


<span class="s0">async def </span><span class="s1">test_trio_from_thread_run_contextvars</span><span class="s2">():</span>
    <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;main&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">thread_fn</span><span class="s2">():</span>
        <span class="s1">thread_parent_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;worker&quot;</span><span class="s2">)</span>
        <span class="s1">thread_current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_thread_pre_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>

        <span class="s0">async def </span><span class="s1">async_back_in_main</span><span class="s2">():</span>
            <span class="s1">back_parent_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s3">&quot;back_in_main&quot;</span><span class="s2">)</span>
            <span class="s1">back_current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s1">sniffio_cvar_back_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">back_parent_value</span><span class="s2">, </span><span class="s1">back_current_value</span><span class="s2">, </span><span class="s1">sniffio_cvar_back_value</span>

        <span class="s2">(</span>
            <span class="s1">back_parent_value</span><span class="s2">,</span>
            <span class="s1">back_current_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
        <span class="s2">) = </span><span class="s1">from_thread_run</span><span class="s2">(</span><span class="s1">async_back_in_main</span><span class="s2">)</span>
        <span class="s1">thread_after_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s1">sniffio_cvar_thread_after_value </span><span class="s2">= </span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s1">thread_parent_value</span><span class="s2">,</span>
            <span class="s1">thread_current_value</span><span class="s2">,</span>
            <span class="s1">thread_after_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_thread_pre_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_thread_after_value</span><span class="s2">,</span>
            <span class="s1">back_parent_value</span><span class="s2">,</span>
            <span class="s1">back_current_value</span><span class="s2">,</span>
            <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">(</span>
        <span class="s1">thread_parent_value</span><span class="s2">,</span>
        <span class="s1">thread_current_value</span><span class="s2">,</span>
        <span class="s1">thread_after_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_thread_pre_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_thread_after_value</span><span class="s2">,</span>
        <span class="s1">back_parent_value</span><span class="s2">,</span>
        <span class="s1">back_current_value</span><span class="s2">,</span>
        <span class="s1">sniffio_cvar_back_value</span><span class="s2">,</span>
    <span class="s2">) = </span><span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">thread_fn</span><span class="s2">)</span>
    <span class="s1">current_value </span><span class="s2">= </span><span class="s1">trio_test_contextvar</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">current_value </span><span class="s2">== </span><span class="s1">thread_parent_value </span><span class="s2">== </span><span class="s3">&quot;main&quot;</span>
    <span class="s0">assert </span><span class="s1">thread_current_value </span><span class="s2">== </span><span class="s1">back_parent_value </span><span class="s2">== </span><span class="s1">thread_after_value </span><span class="s2">== </span><span class="s3">&quot;worker&quot;</span>
    <span class="s0">assert </span><span class="s1">back_current_value </span><span class="s2">== </span><span class="s3">&quot;back_in_main&quot;</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_thread_pre_value </span><span class="s2">== </span><span class="s1">sniffio_cvar_thread_after_value </span><span class="s2">== </span><span class="s0">None</span>
    <span class="s0">assert </span><span class="s1">sniffio_cvar_back_value </span><span class="s2">== </span><span class="s3">&quot;trio&quot;</span>


<span class="s0">def </span><span class="s1">test_run_fn_as_system_task_catched_badly_typed_token</span><span class="s2">():</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s3">&quot;Not TrioTokentype&quot;</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">test_from_thread_inside_trio_thread</span><span class="s2">():</span>
    <span class="s0">def </span><span class="s1">not_called</span><span class="s2">():  </span><span class="s5"># pragma: no cover</span>
        <span class="s0">assert False</span>

    <span class="s1">trio_token </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">from_thread_run_sync</span><span class="s2">(</span><span class="s1">not_called</span><span class="s2">, </span><span class="s1">trio_token</span><span class="s2">=</span><span class="s1">trio_token</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span><span class="s1">buggy_pypy_asyncgens</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s3">&quot;pypy 7.2.0 is buggy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_from_thread_run_during_shutdown</span><span class="s2">():</span>
    <span class="s1">save </span><span class="s2">= []</span>
    <span class="s1">record </span><span class="s2">= []</span>

    <span class="s0">async def </span><span class="s1">agen</span><span class="s2">():</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">RunFinishedError</span><span class="s2">), </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">shield</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">from_thread_run</span><span class="s2">, </span><span class="s1">sleep</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;ok&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">main</span><span class="s2">():</span>
        <span class="s1">save</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">agen</span><span class="s2">())</span>
        <span class="s0">await </span><span class="s1">save</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">].</span><span class="s1">asend</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s1">_core</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s3">&quot;ok&quot;</span><span class="s2">]</span>


<span class="s0">async def </span><span class="s1">test_trio_token_weak_referenceable</span><span class="s2">():</span>
    <span class="s1">token </span><span class="s2">= </span><span class="s1">current_trio_token</span><span class="s2">()</span>
    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">token</span><span class="s2">, </span><span class="s1">TrioToken</span><span class="s2">)</span>
    <span class="s1">weak_reference </span><span class="s2">= </span><span class="s1">weakref</span><span class="s2">.</span><span class="s1">ref</span><span class="s2">(</span><span class="s1">token</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">token </span><span class="s0">is </span><span class="s1">weak_reference</span><span class="s2">()</span>


<span class="s0">async def </span><span class="s1">test_unsafe_cancellable_kwarg</span><span class="s2">():</span>
    <span class="s5"># This is a stand in for a numpy ndarray or other objects</span>
    <span class="s5"># that (maybe surprisingly) lack a notion of truthiness</span>
    <span class="s0">class </span><span class="s1">BadBool</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">__bool__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">to_thread_run_sync</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">cancellable</span><span class="s2">=</span><span class="s1">BadBool</span><span class="s2">())</span>
</pre>
</body>
</html>