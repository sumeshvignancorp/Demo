<html>
<head>
<title>_funcs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_funcs.py</font>
</center></td></tr></table>
<pre><span class="s0"># SPDX-License-Identifier: MIT</span>


<span class="s2">import </span><span class="s1">copy</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_compat </span><span class="s2">import </span><span class="s1">PY_3_9_PLUS</span><span class="s3">, </span><span class="s1">get_generic_base</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_make </span><span class="s2">import </span><span class="s1">NOTHING</span><span class="s3">, </span><span class="s1">_obj_setattr</span><span class="s3">, </span><span class="s1">fields</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s1">AttrsAttributeNotFoundError</span>


<span class="s2">def </span><span class="s1">asdict</span><span class="s3">(</span>
    <span class="s1">inst</span><span class="s3">,</span>
    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the *attrs* attribute values of *inst* as a dict. 
 
    Optionally recurse into other *attrs*-decorated classes. 
 
    :param inst: Instance of an *attrs*-decorated class. 
    :param bool recurse: Recurse into classes that are also 
        *attrs*-decorated. 
    :param callable filter: A callable whose return code determines whether an 
        attribute or element is included (``True``) or dropped (``False``).  Is 
        called with the `attrs.Attribute` as the first argument and the 
        value as the second argument. 
    :param callable dict_factory: A callable to produce dictionaries from.  For 
        example, to produce ordered dictionaries instead of normal Python 
        dictionaries, pass in ``collections.OrderedDict``. 
    :param bool retain_collection_types: Do not convert to ``list`` when 
        encountering an attribute whose type is ``tuple`` or ``set``.  Only 
        meaningful if ``recurse`` is ``True``. 
    :param Optional[callable] value_serializer: A hook that is called for every 
        attribute or dict key/value.  It receives the current instance, field 
        and value and must return the (updated) value.  The hook is run *after* 
        the optional *filter* has been applied. 
 
    :rtype: return type of *dict_factory* 
 
    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs* 
        class. 
 
    ..  versionadded:: 16.0.0 *dict_factory* 
    ..  versionadded:: 16.1.0 *retain_collection_types* 
    ..  versionadded:: 20.3.0 *value_serializer* 
    ..  versionadded:: 21.3.0 If a dict has a collection for a key, it is 
        serialized as a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s1">rv </span><span class="s3">= </span><span class="s1">dict_factory</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">filter </span><span class="s2">is not None and not </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">value_serializer </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">v </span><span class="s3">= </span><span class="s1">value_serializer</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">recurse </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">):</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">asdict</span><span class="s3">(</span>
                    <span class="s1">v</span><span class="s3">,</span>
                    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
                <span class="s1">cf </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain_collection_types </span><span class="s2">is True else </span><span class="s1">list</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">cf</span><span class="s3">(</span>
                    <span class="s3">[</span>
                        <span class="s1">_asdict_anything</span><span class="s3">(</span>
                            <span class="s1">i</span><span class="s3">,</span>
                            <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                        <span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span>
                    <span class="s3">]</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s1">df </span><span class="s3">= </span><span class="s1">dict_factory</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">df</span><span class="s3">(</span>
                    <span class="s3">(</span>
                        <span class="s1">_asdict_anything</span><span class="s3">(</span>
                            <span class="s1">kk</span><span class="s3">,</span>
                            <span class="s1">is_key</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                        <span class="s3">),</span>
                        <span class="s1">_asdict_anything</span><span class="s3">(</span>
                            <span class="s1">vv</span><span class="s3">,</span>
                            <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                        <span class="s3">),</span>
                    <span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">v</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">v</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rv</span><span class="s3">[</span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">v</span>
    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">_asdict_anything</span><span class="s3">(</span>
    <span class="s1">val</span><span class="s3">,</span>
    <span class="s1">is_key</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">,</span>
    <span class="s1">dict_factory</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">,</span>
    <span class="s1">value_serializer</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    ``asdict`` only works on attrs instances, this works on anything. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">val</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s0"># Attrs class.</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">asdict</span><span class="s3">(</span>
            <span class="s1">val</span><span class="s3">,</span>
            <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
            <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
            <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
            <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">retain_collection_types </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">val</span><span class="s3">.</span><span class="s1">__class__</span>
        <span class="s2">elif </span><span class="s1">is_key</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">tuple</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cf </span><span class="s3">= </span><span class="s1">list</span>

        <span class="s1">rv </span><span class="s3">= </span><span class="s1">cf</span><span class="s3">(</span>
            <span class="s3">[</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">i</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">dict_factory</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">)</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">val</span>
            <span class="s3">]</span>
        <span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">dict_factory</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">df</span><span class="s3">(</span>
            <span class="s3">(</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">kk</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">),</span>
                <span class="s1">_asdict_anything</span><span class="s3">(</span>
                    <span class="s1">vv</span><span class="s3">,</span>
                    <span class="s1">is_key</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                    <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                    <span class="s1">dict_factory</span><span class="s3">=</span><span class="s1">df</span><span class="s3">,</span>
                    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain_collection_types</span><span class="s3">,</span>
                    <span class="s1">value_serializer</span><span class="s3">=</span><span class="s1">value_serializer</span><span class="s3">,</span>
                <span class="s3">),</span>
            <span class="s3">)</span>
            <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">val</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">rv </span><span class="s3">= </span><span class="s1">val</span>
        <span class="s2">if </span><span class="s1">value_serializer </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">rv </span><span class="s3">= </span><span class="s1">value_serializer</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">rv</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">astuple</span><span class="s3">(</span>
    <span class="s1">inst</span><span class="s3">,</span>
    <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">filter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple</span><span class="s3">,</span>
    <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the *attrs* attribute values of *inst* as a tuple. 
 
    Optionally recurse into other *attrs*-decorated classes. 
 
    :param inst: Instance of an *attrs*-decorated class. 
    :param bool recurse: Recurse into classes that are also 
        *attrs*-decorated. 
    :param callable filter: A callable whose return code determines whether an 
        attribute or element is included (``True``) or dropped (``False``).  Is 
        called with the `attrs.Attribute` as the first argument and the 
        value as the second argument. 
    :param callable tuple_factory: A callable to produce tuples from.  For 
        example, to produce lists instead of tuples. 
    :param bool retain_collection_types: Do not convert to ``list`` 
        or ``dict`` when encountering an attribute which type is 
        ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is 
        ``True``. 
 
    :rtype: return type of *tuple_factory* 
 
    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs* 
        class. 
 
    ..  versionadded:: 16.2.0 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s1">rv </span><span class="s3">= []</span>
    <span class="s1">retain </span><span class="s3">= </span><span class="s1">retain_collection_types  </span><span class="s0"># Very long. :/</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">filter </span><span class="s2">is not None and not </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">recurse </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">):</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">astuple</span><span class="s3">(</span>
                        <span class="s1">v</span><span class="s3">,</span>
                        <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                        <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                        <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">list</span><span class="s3">, </span><span class="s1">set</span><span class="s3">, </span><span class="s1">frozenset</span><span class="s3">)):</span>
                <span class="s1">cf </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain </span><span class="s2">is True else </span><span class="s1">list</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">cf</span><span class="s3">(</span>
                        <span class="s3">[</span>
                            <span class="s1">astuple</span><span class="s3">(</span>
                                <span class="s1">j</span><span class="s3">,</span>
                                <span class="s1">recurse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                                <span class="s1">filter</span><span class="s3">=</span><span class="s1">filter</span><span class="s3">,</span>
                                <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                                <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                            <span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">j</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                            <span class="s2">else </span><span class="s1">j</span>
                            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">v</span>
                        <span class="s3">]</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">):</span>
                <span class="s1">df </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s2">if </span><span class="s1">retain </span><span class="s2">is True else </span><span class="s1">dict</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s1">df</span><span class="s3">(</span>
                        <span class="s3">(</span>
                            <span class="s1">astuple</span><span class="s3">(</span>
                                <span class="s1">kk</span><span class="s3">,</span>
                                <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                                <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                            <span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">kk</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                            <span class="s2">else </span><span class="s1">kk</span><span class="s3">,</span>
                            <span class="s1">astuple</span><span class="s3">(</span>
                                <span class="s1">vv</span><span class="s3">,</span>
                                <span class="s1">tuple_factory</span><span class="s3">=</span><span class="s1">tuple_factory</span><span class="s3">,</span>
                                <span class="s1">retain_collection_types</span><span class="s3">=</span><span class="s1">retain</span><span class="s3">,</span>
                            <span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">has</span><span class="s3">(</span><span class="s1">vv</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
                            <span class="s2">else </span><span class="s1">vv</span><span class="s3">,</span>
                        <span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">kk</span><span class="s3">, </span><span class="s1">vv </span><span class="s2">in </span><span class="s1">v</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rv</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">rv </span><span class="s2">if </span><span class="s1">tuple_factory </span><span class="s2">is </span><span class="s1">list </span><span class="s2">else </span><span class="s1">tuple_factory</span><span class="s3">(</span><span class="s1">rv</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">has</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Check whether *cls* is a class with *attrs* attributes. 
 
    :param type cls: Class to introspect. 
    :raise TypeError: If *cls* is not a class. 
 
    :rtype: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">attrs </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return True</span>

    <span class="s0"># No attrs, maybe it's a specialized generic (A[str])?</span>
    <span class="s1">generic_base </span><span class="s3">= </span><span class="s1">get_generic_base</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">generic_base </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">generic_attrs </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">generic_base</span><span class="s3">, </span><span class="s5">&quot;__attrs_attrs__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">generic_attrs </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># Stick it on here for speed next time.</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_attrs__ </span><span class="s3">= </span><span class="s1">generic_attrs</span>
        <span class="s2">return </span><span class="s1">generic_attrs </span><span class="s2">is not None</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">assoc</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Copy *inst* and apply *changes*. 
 
    This is different from `evolve` that applies the changes to the arguments 
    that create the new instance. 
 
    `evolve`'s behavior is preferable, but there are `edge cases`_ where it 
    doesn't work. Therefore `assoc` is deprecated, but will not be removed. 
 
    .. _`edge cases`: https://github.com/python-attrs/attrs/issues/251 
 
    :param inst: Instance of a class with *attrs* attributes. 
    :param changes: Keyword changes in the new copy. 
 
    :return: A copy of inst with *changes* incorporated. 
 
    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name* 
        couldn't be found on *cls*. 
    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs* 
        class. 
 
    ..  deprecated:: 17.1.0 
        Use `attrs.evolve` instead if you can. 
        This function will not be removed du to the slightly different approach 
        compared to `attrs.evolve`. 
    &quot;&quot;&quot;</span>
    <span class="s1">new </span><span class="s3">= </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">)</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">changes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">NOTHING</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">is </span><span class="s1">NOTHING</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AttrsAttributeNotFoundError</span><span class="s3">(</span>
                <span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">} </span><span class="s5">is not an attrs attribute on </span><span class="s2">{</span><span class="s1">new</span><span class="s3">.</span><span class="s1">__class__</span><span class="s2">}</span><span class="s5">.&quot;</span>
            <span class="s3">)</span>
        <span class="s1">_obj_setattr</span><span class="s3">(</span><span class="s1">new</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">new</span>


<span class="s2">def </span><span class="s1">evolve</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">changes</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a new instance, based on the first positional argument with 
    *changes* applied. 
 
    :param inst: Instance of a class with *attrs* attributes. 
    :param changes: Keyword changes in the new copy. 
 
    :return: A copy of inst with *changes* incorporated. 
 
    :raise TypeError: If *attr_name* couldn't be found in the class 
        ``__init__``. 
    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs* 
        class. 
 
    .. versionadded:: 17.1.0 
    .. deprecated:: 23.1.0 
       It is now deprecated to pass the instance using the keyword argument 
       *inst*. It will raise a warning until at least April 2024, after which 
       it will become an error. Always pass the instance as a positional 
       argument. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Try to get instance by positional argument first.</span>
    <span class="s0"># Use changes otherwise and warn it'll break.</span>
    <span class="s2">if </span><span class="s1">args</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s3">(</span><span class="s1">inst</span><span class="s3">,) = </span><span class="s1">args</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s5">f&quot;evolve() takes 1 positional argument, but </span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span><span class="s2">} </span><span class="s5">&quot;</span>
                <span class="s5">&quot;were given&quot;</span>
            <span class="s3">) </span><span class="s2">from None</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">inst </span><span class="s3">= </span><span class="s1">changes</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">&quot;inst&quot;</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s5">&quot;evolve() missing 1 required positional argument: 'inst'&quot;</span>
            <span class="s3">) </span><span class="s2">from None</span>

        <span class="s2">import </span><span class="s1">warnings</span>

        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s5">&quot;Passing the instance per keyword argument is deprecated and &quot;</span>
            <span class="s5">&quot;will stop working in, or after, April 2024.&quot;</span><span class="s3">,</span>
            <span class="s1">DeprecationWarning</span><span class="s3">,</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s1">cls </span><span class="s3">= </span><span class="s1">inst</span><span class="s3">.</span><span class="s1">__class__</span>
    <span class="s1">attrs </span><span class="s3">= </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">.</span><span class="s1">init</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s1">attr_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">name  </span><span class="s0"># To deal with private attributes.</span>
        <span class="s1">init_name </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">alias</span>
        <span class="s2">if </span><span class="s1">init_name </span><span class="s2">not in </span><span class="s1">changes</span><span class="s3">:</span>
            <span class="s1">changes</span><span class="s3">[</span><span class="s1">init_name</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">inst</span><span class="s3">, </span><span class="s1">attr_name</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">cls</span><span class="s3">(**</span><span class="s1">changes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">resolve_types</span><span class="s3">(</span>
    <span class="s1">cls</span><span class="s3">, </span><span class="s1">globalns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">localns</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">attribs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">include_extras</span><span class="s3">=</span><span class="s2">True</span>
<span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Resolve any strings and forward annotations in type annotations. 
 
    This is only required if you need concrete types in `Attribute`'s *type* 
    field. In other words, you don't need to resolve your types if you only 
    use them for static type checking. 
 
    With no arguments, names will be looked up in the module in which the class 
    was created. If this is not what you want, e.g. if the name only exists 
    inside a method, you may pass *globalns* or *localns* to specify other 
    dictionaries in which to look up these names. See the docs of 
    `typing.get_type_hints` for more details. 
 
    :param type cls: Class to resolve. 
    :param Optional[dict] globalns: Dictionary containing global variables. 
    :param Optional[dict] localns: Dictionary containing local variables. 
    :param Optional[list] attribs: List of attribs for the given class. 
        This is necessary when calling from inside a ``field_transformer`` 
        since *cls* is not an *attrs* class yet. 
    :param bool include_extras: Resolve more accurately, if possible. 
        Pass ``include_extras`` to ``typing.get_hints``, if supported by the 
        typing module. On supported Python versions (3.9+), this resolves the 
        types more accurately. 
 
    :raise TypeError: If *cls* is not a class. 
    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs* 
        class and you didn't pass any attribs. 
    :raise NameError: If types cannot be resolved because of missing variables. 
 
    :returns: *cls* so you can use this function also as a class decorator. 
        Please note that you have to apply it **after** `attrs.define`. That 
        means the decorator has to come in the line **before** `attrs.define`. 
 
    ..  versionadded:: 20.1.0 
    ..  versionadded:: 21.1.0 *attribs* 
    ..  versionadded:: 23.1.0 *include_extras* 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Since calling get_type_hints is expensive we cache whether we've</span>
    <span class="s0"># done it already.</span>
    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s5">&quot;__attrs_types_resolved__&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) != </span><span class="s1">cls</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">typing</span>

        <span class="s1">kwargs </span><span class="s3">= {</span><span class="s5">&quot;globalns&quot;</span><span class="s3">: </span><span class="s1">globalns</span><span class="s3">, </span><span class="s5">&quot;localns&quot;</span><span class="s3">: </span><span class="s1">localns</span><span class="s3">}</span>

        <span class="s2">if </span><span class="s1">PY_3_9_PLUS</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s5">&quot;include_extras&quot;</span><span class="s3">] = </span><span class="s1">include_extras</span>

        <span class="s1">hints </span><span class="s3">= </span><span class="s1">typing</span><span class="s3">.</span><span class="s1">get_type_hints</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s2">if </span><span class="s1">attribs </span><span class="s2">is None else </span><span class="s1">attribs</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">field</span><span class="s3">.</span><span class="s1">name </span><span class="s2">in </span><span class="s1">hints</span><span class="s3">:</span>
                <span class="s0"># Since fields have been frozen we must work around it.</span>
                <span class="s1">_obj_setattr</span><span class="s3">(</span><span class="s1">field</span><span class="s3">, </span><span class="s5">&quot;type&quot;</span><span class="s3">, </span><span class="s1">hints</span><span class="s3">[</span><span class="s1">field</span><span class="s3">.</span><span class="s1">name</span><span class="s3">])</span>
        <span class="s0"># We store the class we resolved so that subclasses know they haven't</span>
        <span class="s0"># been resolved.</span>
        <span class="s1">cls</span><span class="s3">.</span><span class="s1">__attrs_types_resolved__ </span><span class="s3">= </span><span class="s1">cls</span>

    <span class="s0"># Return the class so you can use it as a decorator too.</span>
    <span class="s2">return </span><span class="s1">cls</span>
</pre>
</body>
</html>