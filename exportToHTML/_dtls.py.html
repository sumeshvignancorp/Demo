<html>
<head>
<title>_dtls.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #a5c261;}
.s6 { color: #6aab73;}
.s7 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dtls.py</font>
</center></td></tr></table>
<pre><span class="s0"># Implementation of DTLS 1.2, using pyopenssl</span>
<span class="s0"># https://datatracker.ietf.org/doc/html/rfc6347</span>
<span class="s0">#</span>
<span class="s0"># OpenSSL's APIs for DTLS are extremely awkward and limited, which forces us to jump</span>
<span class="s0"># through a *lot* of hoops and implement important chunks of the protocol ourselves.</span>
<span class="s0"># Hopefully they fix this before implementing DTLS 1.3, because it's a very different</span>
<span class="s0"># protocol, and it's probably impossible to pull tricks like we do here.</span>

<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">errno</span>
<span class="s2">import </span><span class="s1">hmac</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">weakref</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">count</span>

<span class="s2">import </span><span class="s1">attr</span>

<span class="s2">import </span><span class="s1">trio</span>
<span class="s2">from </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">Final</span><span class="s3">, </span><span class="s1">NoPublicConstructor</span>

<span class="s1">MAX_UDP_PACKET_SIZE </span><span class="s3">= </span><span class="s4">65527</span>


<span class="s2">def </span><span class="s1">packet_header_overhead</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">sock</span><span class="s3">.</span><span class="s1">family </span><span class="s3">== </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">AF_INET</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">28</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">48</span>


<span class="s2">def </span><span class="s1">worst_case_mtu</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">sock</span><span class="s3">.</span><span class="s1">family </span><span class="s3">== </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">AF_INET</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">576 </span><span class="s3">- </span><span class="s1">packet_header_overhead</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">1280 </span><span class="s3">- </span><span class="s1">packet_header_overhead</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">best_guess_mtu</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s4">1500 </span><span class="s3">- </span><span class="s1">packet_header_overhead</span><span class="s3">(</span><span class="s1">sock</span><span class="s3">)</span>


<span class="s0"># There are a bunch of different RFCs that define these codes, so for a</span>
<span class="s0"># comprehensive collection look here:</span>
<span class="s0"># https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml</span>
<span class="s2">class </span><span class="s1">ContentType</span><span class="s3">(</span><span class="s1">enum</span><span class="s3">.</span><span class="s1">IntEnum</span><span class="s3">):</span>
    <span class="s1">change_cipher_spec </span><span class="s3">= </span><span class="s4">20</span>
    <span class="s1">alert </span><span class="s3">= </span><span class="s4">21</span>
    <span class="s1">handshake </span><span class="s3">= </span><span class="s4">22</span>
    <span class="s1">application_data </span><span class="s3">= </span><span class="s4">23</span>
    <span class="s1">heartbeat </span><span class="s3">= </span><span class="s4">24</span>


<span class="s2">class </span><span class="s1">HandshakeType</span><span class="s3">(</span><span class="s1">enum</span><span class="s3">.</span><span class="s1">IntEnum</span><span class="s3">):</span>
    <span class="s1">hello_request </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">client_hello </span><span class="s3">= </span><span class="s4">1</span>
    <span class="s1">server_hello </span><span class="s3">= </span><span class="s4">2</span>
    <span class="s1">hello_verify_request </span><span class="s3">= </span><span class="s4">3</span>
    <span class="s1">new_session_ticket </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">end_of_early_data </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">encrypted_extensions </span><span class="s3">= </span><span class="s4">8</span>
    <span class="s1">certificate </span><span class="s3">= </span><span class="s4">11</span>
    <span class="s1">server_key_exchange </span><span class="s3">= </span><span class="s4">12</span>
    <span class="s1">certificate_request </span><span class="s3">= </span><span class="s4">13</span>
    <span class="s1">server_hello_done </span><span class="s3">= </span><span class="s4">14</span>
    <span class="s1">certificate_verify </span><span class="s3">= </span><span class="s4">15</span>
    <span class="s1">client_key_exchange </span><span class="s3">= </span><span class="s4">16</span>
    <span class="s1">finished </span><span class="s3">= </span><span class="s4">20</span>
    <span class="s1">certificate_url </span><span class="s3">= </span><span class="s4">21</span>
    <span class="s1">certificate_status </span><span class="s3">= </span><span class="s4">22</span>
    <span class="s1">supplemental_data </span><span class="s3">= </span><span class="s4">23</span>
    <span class="s1">key_update </span><span class="s3">= </span><span class="s4">24</span>
    <span class="s1">compressed_certificate </span><span class="s3">= </span><span class="s4">25</span>
    <span class="s1">ekt_key </span><span class="s3">= </span><span class="s4">26</span>
    <span class="s1">message_hash </span><span class="s3">= </span><span class="s4">254</span>


<span class="s2">class </span><span class="s1">ProtocolVersion</span><span class="s3">:</span>
    <span class="s1">DTLS10 </span><span class="s3">= </span><span class="s1">bytes</span><span class="s3">([</span><span class="s4">254</span><span class="s3">, </span><span class="s4">255</span><span class="s3">])</span>
    <span class="s1">DTLS12 </span><span class="s3">= </span><span class="s1">bytes</span><span class="s3">([</span><span class="s4">254</span><span class="s3">, </span><span class="s4">253</span><span class="s3">])</span>


<span class="s1">EPOCH_MASK </span><span class="s3">= </span><span class="s4">0xFFFF </span><span class="s3">&lt;&lt; (</span><span class="s4">6 </span><span class="s3">* </span><span class="s4">8</span><span class="s3">)</span>


<span class="s0"># Conventions:</span>
<span class="s0"># - All functions that handle network data end in _untrusted.</span>
<span class="s0"># - All functions end in _untrusted MUST make sure that bad data from the</span>
<span class="s0">#   network cannot *only* cause BadPacket to be raised. No IndexError or</span>
<span class="s0">#   struct.error or whatever.</span>
<span class="s2">class </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">pass</span>


<span class="s0"># This checks that the DTLS 'epoch' field is 0, which is true iff we're in the</span>
<span class="s0"># initial handshake. It doesn't check the ContentType, because not all</span>
<span class="s0"># handshake messages have ContentType==handshake -- for example,</span>
<span class="s0"># ChangeCipherSpec is used during the handshake but has its own ContentType.</span>
<span class="s0">#</span>
<span class="s0"># Cannot fail.</span>
<span class="s2">def </span><span class="s1">part_of_handshake_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
    <span class="s0"># If the packet is too short, then slicing will successfully return a</span>
    <span class="s0"># short string, which will necessarily fail to match.</span>
    <span class="s2">return </span><span class="s1">packet</span><span class="s3">[</span><span class="s4">3</span><span class="s3">:</span><span class="s4">5</span><span class="s3">] == </span><span class="s5">b&quot;</span><span class="s2">\x00\x00</span><span class="s5">&quot;</span>


<span class="s0"># Cannot fail</span>
<span class="s2">def </span><span class="s1">is_client_hello_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">packet</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">handshake</span>
            <span class="s2">and </span><span class="s1">packet</span><span class="s3">[</span><span class="s4">13</span><span class="s3">] == </span><span class="s1">HandshakeType</span><span class="s3">.</span><span class="s1">client_hello</span>
        <span class="s3">)</span>
    <span class="s2">except </span><span class="s1">IndexError</span><span class="s3">:</span>
        <span class="s0"># Invalid DTLS record</span>
        <span class="s2">return False</span>


<span class="s0"># DTLS records are:</span>
<span class="s0"># - 1 byte content type</span>
<span class="s0"># - 2 bytes version</span>
<span class="s0"># - 8 bytes epoch+seqno</span>
<span class="s0">#    Technically this is 2 bytes epoch then 6 bytes seqno, but we treat it as</span>
<span class="s0">#    a single 8-byte integer, where epoch changes are represented as jumping</span>
<span class="s0">#    forward by 2**(6*8).</span>
<span class="s0"># - 2 bytes payload length (unsigned big-endian)</span>
<span class="s0"># - payload</span>
<span class="s1">RECORD_HEADER </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">Struct</span><span class="s3">(</span><span class="s6">&quot;!B2sQH&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">to_hex</span><span class="s3">(</span><span class="s1">data</span><span class="s3">: </span><span class="s1">bytes</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
    <span class="s2">return </span><span class="s1">data</span><span class="s3">.</span><span class="s1">hex</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">Record</span><span class="s3">:</span>
    <span class="s1">content_type</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">version</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>
    <span class="s1">epoch_seqno</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">payload</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">records_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">ct</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">payload_len </span><span class="s3">= </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
        <span class="s0"># Marked as no-cover because at time of writing, this code is unreachable</span>
        <span class="s0"># (records_untrusted only gets called on packets that are either trusted or that</span>
        <span class="s0"># have passed is_client_hello_untrusted, which filters out short packets)</span>
        <span class="s2">except </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">error </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;invalid record header&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">exc</span>
        <span class="s1">i </span><span class="s3">+= </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">size</span>
        <span class="s1">payload </span><span class="s3">= </span><span class="s1">packet</span><span class="s3">[</span><span class="s1">i </span><span class="s3">: </span><span class="s1">i </span><span class="s3">+ </span><span class="s1">payload_len</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">payload</span><span class="s3">) != </span><span class="s1">payload_len</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;short record&quot;</span><span class="s3">)</span>
        <span class="s1">i </span><span class="s3">+= </span><span class="s1">payload_len</span>
        <span class="s2">yield </span><span class="s1">Record</span><span class="s3">(</span><span class="s1">ct</span><span class="s3">, </span><span class="s1">version</span><span class="s3">, </span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">payload</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">encode_record</span><span class="s3">(</span><span class="s1">record</span><span class="s3">):</span>
    <span class="s1">header </span><span class="s3">= </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
        <span class="s1">record</span><span class="s3">.</span><span class="s1">content_type</span><span class="s3">,</span>
        <span class="s1">record</span><span class="s3">.</span><span class="s1">version</span><span class="s3">,</span>
        <span class="s1">record</span><span class="s3">.</span><span class="s1">epoch_seqno</span><span class="s3">,</span>
        <span class="s1">len</span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">payload</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">header </span><span class="s3">+ </span><span class="s1">record</span><span class="s3">.</span><span class="s1">payload</span>


<span class="s0"># Handshake messages are:</span>
<span class="s0"># - 1 byte message type</span>
<span class="s0"># - 3 bytes total message length</span>
<span class="s0"># - 2 bytes message sequence number</span>
<span class="s0"># - 3 bytes fragment offset</span>
<span class="s0"># - 3 bytes fragment length</span>
<span class="s1">HANDSHAKE_MESSAGE_HEADER </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">Struct</span><span class="s3">(</span><span class="s6">&quot;!B3sH3s3s&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">HandshakeFragment</span><span class="s3">:</span>
    <span class="s1">msg_type</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">msg_len</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">msg_seq</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">frag_offset</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">frag_len</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">frag</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">decode_handshake_fragment_untrusted</span><span class="s3">(</span><span class="s1">payload</span><span class="s3">):</span>
    <span class="s0"># Raises BadPacket if decoding fails</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s3">(</span>
            <span class="s1">msg_type</span><span class="s3">,</span>
            <span class="s1">msg_len_bytes</span><span class="s3">,</span>
            <span class="s1">msg_seq</span><span class="s3">,</span>
            <span class="s1">frag_offset_bytes</span><span class="s3">,</span>
            <span class="s1">frag_len_bytes</span><span class="s3">,</span>
        <span class="s3">) = </span><span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">unpack_from</span><span class="s3">(</span><span class="s1">payload</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">error </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;bad handshake message header&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">exc</span>
    <span class="s0"># 'struct' doesn't have built-in support for 24-bit integers, so we</span>
    <span class="s0"># have to do it by hand. These can't fail.</span>
    <span class="s1">msg_len </span><span class="s3">= </span><span class="s1">int</span><span class="s3">.</span><span class="s1">from_bytes</span><span class="s3">(</span><span class="s1">msg_len_bytes</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
    <span class="s1">frag_offset </span><span class="s3">= </span><span class="s1">int</span><span class="s3">.</span><span class="s1">from_bytes</span><span class="s3">(</span><span class="s1">frag_offset_bytes</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
    <span class="s1">frag_len </span><span class="s3">= </span><span class="s1">int</span><span class="s3">.</span><span class="s1">from_bytes</span><span class="s3">(</span><span class="s1">frag_len_bytes</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
    <span class="s1">frag </span><span class="s3">= </span><span class="s1">payload</span><span class="s3">[</span><span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">size </span><span class="s3">:]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">frag</span><span class="s3">) != </span><span class="s1">frag_len</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;handshake fragment length doesn't match record length&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">HandshakeFragment</span><span class="s3">(</span>
        <span class="s1">msg_type</span><span class="s3">,</span>
        <span class="s1">msg_len</span><span class="s3">,</span>
        <span class="s1">msg_seq</span><span class="s3">,</span>
        <span class="s1">frag_offset</span><span class="s3">,</span>
        <span class="s1">frag_len</span><span class="s3">,</span>
        <span class="s1">frag</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">encode_handshake_fragment</span><span class="s3">(</span><span class="s1">hsf</span><span class="s3">):</span>
    <span class="s1">hs_header </span><span class="s3">= </span><span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
        <span class="s1">hsf</span><span class="s3">.</span><span class="s1">msg_type</span><span class="s3">,</span>
        <span class="s1">hsf</span><span class="s3">.</span><span class="s1">msg_len</span><span class="s3">.</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">),</span>
        <span class="s1">hsf</span><span class="s3">.</span><span class="s1">msg_seq</span><span class="s3">,</span>
        <span class="s1">hsf</span><span class="s3">.</span><span class="s1">frag_offset</span><span class="s3">.</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">),</span>
        <span class="s1">hsf</span><span class="s3">.</span><span class="s1">frag_len</span><span class="s3">.</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">hs_header </span><span class="s3">+ </span><span class="s1">hsf</span><span class="s3">.</span><span class="s1">frag</span>


<span class="s2">def </span><span class="s1">decode_client_hello_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
    <span class="s0"># Raises BadPacket if parsing fails</span>
    <span class="s0"># Returns (record epoch_seqno, cookie from the packet, data that should be</span>
    <span class="s0"># hashed into cookie)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s0"># ClientHello has to be the first record in the packet</span>
        <span class="s1">record </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">records_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">))</span>
        <span class="s0"># no-cover because at time of writing, this is unreachable:</span>
        <span class="s0"># decode_client_hello_untrusted is only called on packets that have passed</span>
        <span class="s0"># is_client_hello_untrusted, which confirms the content type.</span>
        <span class="s2">if </span><span class="s1">record</span><span class="s3">.</span><span class="s1">content_type </span><span class="s3">!= </span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">handshake</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;not a handshake record&quot;</span><span class="s3">)</span>
        <span class="s1">fragment </span><span class="s3">= </span><span class="s1">decode_handshake_fragment_untrusted</span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">payload</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_type </span><span class="s3">!= </span><span class="s1">HandshakeType</span><span class="s3">.</span><span class="s1">client_hello</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;not a ClientHello&quot;</span><span class="s3">)</span>
        <span class="s0"># ClientHello can't be fragmented, because reassembly requires holding</span>
        <span class="s0"># per-connection state, and we refuse to allocate per-connection state</span>
        <span class="s0"># until after we get a valid ClientHello.</span>
        <span class="s2">if </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag_offset </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;fragmented ClientHello&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag_len </span><span class="s3">!= </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_len</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;fragmented ClientHello&quot;</span><span class="s3">)</span>

        <span class="s0"># As per RFC 6347:</span>
        <span class="s0">#</span>
        <span class="s0">#   When responding to a HelloVerifyRequest, the client MUST use the</span>
        <span class="s0">#   same parameter values (version, random, session_id, cipher_suites,</span>
        <span class="s0">#   compression_method) as it did in the original ClientHello.  The</span>
        <span class="s0">#   server SHOULD use those values to generate its cookie and verify that</span>
        <span class="s0">#   they are correct upon cookie receipt.</span>
        <span class="s0">#</span>
        <span class="s0"># However, the record-layer framing can and will change (e.g. the</span>
        <span class="s0"># second ClientHello will have a new record-layer sequence number). So</span>
        <span class="s0"># we need to pull out the handshake message alone, discarding the</span>
        <span class="s0"># record-layer stuff, and then we're going to hash all of it *except*</span>
        <span class="s0"># the cookie.</span>

        <span class="s1">body </span><span class="s3">= </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag</span>
        <span class="s0"># ClientHello is:</span>
        <span class="s0">#</span>
        <span class="s0"># - 2 bytes client_version</span>
        <span class="s0"># - 32 bytes random</span>
        <span class="s0"># - 1 byte session_id length</span>
        <span class="s0"># - session_id</span>
        <span class="s0"># - 1 byte cookie length</span>
        <span class="s0"># - cookie</span>
        <span class="s0"># - everything else</span>
        <span class="s0">#</span>
        <span class="s0"># So to find the cookie, so we need to figure out how long the</span>
        <span class="s0"># session_id is and skip past it.</span>
        <span class="s1">session_id_len </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[</span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">32</span><span class="s3">]</span>
        <span class="s1">cookie_len_offset </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">32 </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">session_id_len</span>
        <span class="s1">cookie_len </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[</span><span class="s1">cookie_len_offset</span><span class="s3">]</span>

        <span class="s1">cookie_start </span><span class="s3">= </span><span class="s1">cookie_len_offset </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s1">cookie_end </span><span class="s3">= </span><span class="s1">cookie_start </span><span class="s3">+ </span><span class="s1">cookie_len</span>

        <span class="s1">before_cookie </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[:</span><span class="s1">cookie_len_offset</span><span class="s3">]</span>
        <span class="s1">cookie </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[</span><span class="s1">cookie_start</span><span class="s3">:</span><span class="s1">cookie_end</span><span class="s3">]</span>
        <span class="s1">after_cookie </span><span class="s3">= </span><span class="s1">body</span><span class="s3">[</span><span class="s1">cookie_end</span><span class="s3">:]</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">cookie</span><span class="s3">) != </span><span class="s1">cookie_len</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;short cookie&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">before_cookie </span><span class="s3">+ </span><span class="s1">after_cookie</span><span class="s3">)</span>

    <span class="s2">except </span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">error</span><span class="s3">, </span><span class="s1">IndexError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">BadPacket</span><span class="s3">(</span><span class="s6">&quot;bad ClientHello&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">exc</span>


<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">HandshakeMessage</span><span class="s3">:</span>
    <span class="s1">record_version</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>
    <span class="s1">msg_type</span><span class="s3">: </span><span class="s1">HandshakeType</span>
    <span class="s1">msg_seq</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">body</span><span class="s3">: </span><span class="s1">bytearray </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>


<span class="s0"># ChangeCipherSpec is part of the handshake, but it's not a &quot;handshake</span>
<span class="s0"># message&quot; and can't be fragmented the same way. Sigh.</span>
<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">PseudoHandshakeMessage</span><span class="s3">:</span>
    <span class="s1">record_version</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>
    <span class="s1">content_type</span><span class="s3">: </span><span class="s1">int</span>
    <span class="s1">payload</span><span class="s3">: </span><span class="s1">bytes </span><span class="s3">= </span><span class="s1">attr</span><span class="s3">.</span><span class="s1">ib</span><span class="s3">(</span><span class="s1">repr</span><span class="s3">=</span><span class="s1">to_hex</span><span class="s3">)</span>


<span class="s0"># The final record in a handshake is Finished, which is encrypted, can't be fragmented</span>
<span class="s0"># (at least by us), and keeps its record number (because it's in a new epoch). So we</span>
<span class="s0"># just pass it through unchanged. (Fortunately, the payload is only a single hash value,</span>
<span class="s0"># so the largest it will ever be is 64 bytes for a 512-bit hash. Which is small enough</span>
<span class="s0"># that it never requires fragmenting to fit into a UDP packet.</span>
<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">OpaqueHandshakeMessage</span><span class="s3">:</span>
    <span class="s1">record</span><span class="s3">: </span><span class="s1">Record</span>


<span class="s0"># This takes a raw outgoing handshake volley that openssl generated, and</span>
<span class="s0"># reconstructs the handshake messages inside it, so that we can repack them</span>
<span class="s0"># into records while retransmitting. So the data ought to be well-behaved --</span>
<span class="s0"># it's not coming from the network.</span>
<span class="s2">def </span><span class="s1">decode_volley_trusted</span><span class="s3">(</span><span class="s1">volley</span><span class="s3">):</span>
    <span class="s1">messages </span><span class="s3">= []</span>
    <span class="s1">messages_by_seq </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">record </span><span class="s2">in </span><span class="s1">records_untrusted</span><span class="s3">(</span><span class="s1">volley</span><span class="s3">):</span>
        <span class="s0"># ChangeCipherSpec isn't a handshake message, so it can't be fragmented.</span>
        <span class="s0"># Handshake messages with epoch &gt; 0 are encrypted, so we can't fragment them</span>
        <span class="s0"># either. Fortunately, ChangeCipherSpec has a 1 byte payload, and the only</span>
        <span class="s0"># encrypted handshake message is Finished, whose payload is a single hash value</span>
        <span class="s0"># -- so 32 bytes for SHA-256, 64 for SHA-512, etc. Neither is going to be so</span>
        <span class="s0"># large that it has to be fragmented to fit into a single packet.</span>
        <span class="s2">if </span><span class="s1">record</span><span class="s3">.</span><span class="s1">epoch_seqno </span><span class="s3">&amp; </span><span class="s1">EPOCH_MASK</span><span class="s3">:</span>
            <span class="s1">messages</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">OpaqueHandshakeMessage</span><span class="s3">(</span><span class="s1">record</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">record</span><span class="s3">.</span><span class="s1">content_type </span><span class="s2">in </span><span class="s3">(</span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">change_cipher_spec</span><span class="s3">, </span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">alert</span><span class="s3">):</span>
            <span class="s1">messages</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s1">PseudoHandshakeMessage</span><span class="s3">(</span>
                    <span class="s1">record</span><span class="s3">.</span><span class="s1">version</span><span class="s3">, </span><span class="s1">record</span><span class="s3">.</span><span class="s1">content_type</span><span class="s3">, </span><span class="s1">record</span><span class="s3">.</span><span class="s1">payload</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">record</span><span class="s3">.</span><span class="s1">content_type </span><span class="s3">== </span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">handshake</span>
            <span class="s1">fragment </span><span class="s3">= </span><span class="s1">decode_handshake_fragment_untrusted</span><span class="s3">(</span><span class="s1">record</span><span class="s3">.</span><span class="s1">payload</span><span class="s3">)</span>
            <span class="s1">msg_type </span><span class="s3">= </span><span class="s1">HandshakeType</span><span class="s3">(</span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_type</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_seq </span><span class="s2">not in </span><span class="s1">messages_by_seq</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s1">HandshakeMessage</span><span class="s3">(</span>
                    <span class="s1">record</span><span class="s3">.</span><span class="s1">version</span><span class="s3">,</span>
                    <span class="s1">msg_type</span><span class="s3">,</span>
                    <span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_seq</span><span class="s3">,</span>
                    <span class="s1">bytearray</span><span class="s3">(</span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_len</span><span class="s3">),</span>
                <span class="s3">)</span>
                <span class="s1">messages</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
                <span class="s1">messages_by_seq</span><span class="s3">[</span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_seq</span><span class="s3">] = </span><span class="s1">msg</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= </span><span class="s1">messages_by_seq</span><span class="s3">[</span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_seq</span><span class="s3">]</span>
            <span class="s2">assert </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">msg_type </span><span class="s3">== </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_type</span>
            <span class="s2">assert </span><span class="s1">msg</span><span class="s3">.</span><span class="s1">msg_seq </span><span class="s3">== </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_seq</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) == </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">msg_len</span>

            <span class="s1">msg</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span>
                <span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag_offset </span><span class="s3">: </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag_offset </span><span class="s3">+ </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag_len</span>
            <span class="s3">] = </span><span class="s1">fragment</span><span class="s3">.</span><span class="s1">frag</span>

    <span class="s2">return </span><span class="s1">messages</span>


<span class="s2">class </span><span class="s1">RecordEncoder</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_record_seq </span><span class="s3">= </span><span class="s1">count</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">set_first_record_number</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_record_seq </span><span class="s3">= </span><span class="s1">count</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">encode_volley</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">messages</span><span class="s3">, </span><span class="s1">mtu</span><span class="s3">):</span>
        <span class="s1">packets </span><span class="s3">= []</span>
        <span class="s1">packet </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">message </span><span class="s2">in </span><span class="s1">messages</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">OpaqueHandshakeMessage</span><span class="s3">):</span>
                <span class="s1">encoded </span><span class="s3">= </span><span class="s1">encode_record</span><span class="s3">(</span><span class="s1">message</span><span class="s3">.</span><span class="s1">record</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">mtu </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">encoded</span><span class="s3">) &lt;= </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">packets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                    <span class="s1">packet </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
                <span class="s1">packet </span><span class="s3">+= </span><span class="s1">encoded</span>
                <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">) &lt;= </span><span class="s1">mtu</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">PseudoHandshakeMessage</span><span class="s3">):</span>
                <span class="s1">space </span><span class="s3">= </span><span class="s1">mtu </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">) - </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">message</span><span class="s3">.</span><span class="s1">payload</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">space </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">packets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                    <span class="s1">packet </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
                <span class="s1">packet </span><span class="s3">+= </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
                    <span class="s1">message</span><span class="s3">.</span><span class="s1">content_type</span><span class="s3">,</span>
                    <span class="s1">message</span><span class="s3">.</span><span class="s1">record_version</span><span class="s3">,</span>
                    <span class="s1">next</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_record_seq</span><span class="s3">),</span>
                    <span class="s1">len</span><span class="s3">(</span><span class="s1">message</span><span class="s3">.</span><span class="s1">payload</span><span class="s3">),</span>
                <span class="s3">)</span>
                <span class="s1">packet </span><span class="s3">+= </span><span class="s1">message</span><span class="s3">.</span><span class="s1">payload</span>
                <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">) &lt;= </span><span class="s1">mtu</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">msg_len_bytes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">message</span><span class="s3">.</span><span class="s1">body</span><span class="s3">).</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
                <span class="s1">frag_offset </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s1">frags_encoded </span><span class="s3">= </span><span class="s4">0</span>
                <span class="s0"># If message.body is empty, then we still want to encode it in one</span>
                <span class="s0"># fragment, not zero.</span>
                <span class="s2">while </span><span class="s1">frag_offset </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">message</span><span class="s3">.</span><span class="s1">body</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">frags_encoded</span><span class="s3">:</span>
                    <span class="s1">space </span><span class="s3">= (</span>
                        <span class="s1">mtu</span>
                        <span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                        <span class="s3">- </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">size</span>
                        <span class="s3">- </span><span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">size</span>
                    <span class="s3">)</span>
                    <span class="s2">if </span><span class="s1">space </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
                        <span class="s1">packets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                        <span class="s1">packet </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
                        <span class="s2">continue</span>
                    <span class="s1">frag </span><span class="s3">= </span><span class="s1">message</span><span class="s3">.</span><span class="s1">body</span><span class="s3">[</span><span class="s1">frag_offset </span><span class="s3">: </span><span class="s1">frag_offset </span><span class="s3">+ </span><span class="s1">space</span><span class="s3">]</span>
                    <span class="s1">frag_offset_bytes </span><span class="s3">= </span><span class="s1">frag_offset</span><span class="s3">.</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
                    <span class="s1">frag_len_bytes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">frag</span><span class="s3">).</span><span class="s1">to_bytes</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s6">&quot;big&quot;</span><span class="s3">)</span>
                    <span class="s1">frag_offset </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">frag</span><span class="s3">)</span>

                    <span class="s1">packet </span><span class="s3">+= </span><span class="s1">RECORD_HEADER</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
                        <span class="s1">ContentType</span><span class="s3">.</span><span class="s1">handshake</span><span class="s3">,</span>
                        <span class="s1">message</span><span class="s3">.</span><span class="s1">record_version</span><span class="s3">,</span>
                        <span class="s1">next</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_record_seq</span><span class="s3">),</span>
                        <span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">frag</span><span class="s3">),</span>
                    <span class="s3">)</span>

                    <span class="s1">packet </span><span class="s3">+= </span><span class="s1">HANDSHAKE_MESSAGE_HEADER</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
                        <span class="s1">message</span><span class="s3">.</span><span class="s1">msg_type</span><span class="s3">,</span>
                        <span class="s1">msg_len_bytes</span><span class="s3">,</span>
                        <span class="s1">message</span><span class="s3">.</span><span class="s1">msg_seq</span><span class="s3">,</span>
                        <span class="s1">frag_offset_bytes</span><span class="s3">,</span>
                        <span class="s1">frag_len_bytes</span><span class="s3">,</span>
                    <span class="s3">)</span>

                    <span class="s1">packet </span><span class="s3">+= </span><span class="s1">frag</span>

                    <span class="s1">frags_encoded </span><span class="s3">+= </span><span class="s4">1</span>
                    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">) &lt;= </span><span class="s1">mtu</span>

        <span class="s2">if </span><span class="s1">packet</span><span class="s3">:</span>
            <span class="s1">packets</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">packets</span>


<span class="s0"># This bit requires implementing a bona fide cryptographic protocol, so even though it's</span>
<span class="s0"># a simple one let's take a moment to discuss the design.</span>
<span class="s0">#</span>
<span class="s0"># Our goal is to force new incoming handshakes that claim to be coming from a</span>
<span class="s0"># given ip:port to prove that they can also receive packets sent to that</span>
<span class="s0"># ip:port. (There's nothing in UDP to stop someone from forging the return</span>
<span class="s0"># address, and it's often used for stuff like DoS reflection attacks, where</span>
<span class="s0"># an attacker tries to trick us into sending data at some innocent victim.)</span>
<span class="s0"># For more details, see:</span>
<span class="s0">#</span>
<span class="s0">#    https://datatracker.ietf.org/doc/html/rfc6347#section-4.2.1</span>
<span class="s0">#</span>
<span class="s0"># To do this, when we receive an initial ClientHello, we calculate a magic</span>
<span class="s0"># cookie, and send it back as a HelloVerifyRequest. Then the client sends us a</span>
<span class="s0"># second ClientHello, this time with the magic cookie included, and after we</span>
<span class="s0"># check that this cookie is valid we go ahead and start the handshake proper.</span>
<span class="s0">#</span>
<span class="s0"># So the magic cookie needs the following properties:</span>
<span class="s0"># - No-one can forge it without knowing our secret key</span>
<span class="s0"># - It ensures that the ip, port, and ClientHello contents from the response</span>
<span class="s0">#   match those in the challenge</span>
<span class="s0"># - It expires after a short-ish period (so that if an attacker manages to steal one, it</span>
<span class="s0">#   won't be useful for long)</span>
<span class="s0"># - It doesn't require storing any peer-specific state on our side</span>
<span class="s0">#</span>
<span class="s0"># To do that, we take the ip/port/ClientHello data and compute an HMAC of them, using a</span>
<span class="s0"># secret key we generate on startup. We also include:</span>
<span class="s0">#</span>
<span class="s0"># - The current time (using Trio's clock), rounded to the nearest 30 seconds</span>
<span class="s0"># - A random salt</span>
<span class="s0">#</span>
<span class="s0"># Then the cookie is the salt and the HMAC digest concatenated together.</span>
<span class="s0">#</span>
<span class="s0"># When verifying a cookie, we use the salt + new ip/port/ClientHello data to recompute</span>
<span class="s0"># the HMAC digest, for both the current time and the current time minus 30 seconds, and</span>
<span class="s0"># if either of them match, we consider the cookie good.</span>
<span class="s0">#</span>
<span class="s0"># Including the rounded-off time like this means that each cookie is good for at least</span>
<span class="s0"># 30 seconds, and possibly as much as 60 seconds.</span>
<span class="s0">#</span>
<span class="s0"># The salt is probably not necessary -- I'm pretty sure that all it does is make it hard</span>
<span class="s0"># for an attacker to figure out when our clock ticks over a 30 second boundary. Which is</span>
<span class="s0"># probably pretty harmless? But it's easier to add the salt than to convince myself that</span>
<span class="s0"># it's *completely* harmless, so, salt it is.</span>

<span class="s1">COOKIE_REFRESH_INTERVAL </span><span class="s3">= </span><span class="s4">30  </span><span class="s0"># seconds</span>
<span class="s1">KEY_BYTES </span><span class="s3">= </span><span class="s4">32</span>
<span class="s1">COOKIE_HASH </span><span class="s3">= </span><span class="s6">&quot;sha256&quot;</span>
<span class="s1">SALT_BYTES </span><span class="s3">= </span><span class="s4">8</span>
<span class="s0"># 32 bytes was the maximum cookie length in DTLS 1.0. DTLS 1.2 raised it to 255. I doubt</span>
<span class="s0"># there are any DTLS 1.0 implementations still in the wild, but really 32 bytes is</span>
<span class="s0"># plenty, and it also gets rid of a confusing warning in Wireshark output.</span>
<span class="s0">#</span>
<span class="s0"># We truncate the cookie to 32 bytes, of which 8 bytes is salt, so that leaves 24 bytes</span>
<span class="s0"># of truncated HMAC = 192 bit security, which is still massive overkill. (TCP uses 32</span>
<span class="s0"># *bits* for this.) HMAC truncation is explicitly noted as safe in RFC 2104:</span>
<span class="s0">#   https://datatracker.ietf.org/doc/html/rfc2104#section-5</span>
<span class="s1">COOKIE_LENGTH </span><span class="s3">= </span><span class="s4">32</span>


<span class="s2">def </span><span class="s1">_current_cookie_tick</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">trio</span><span class="s3">.</span><span class="s1">current_time</span><span class="s3">() / </span><span class="s1">COOKIE_REFRESH_INTERVAL</span><span class="s3">)</span>


<span class="s0"># Simple deterministic and invertible serializer -- i.e., a useful tool for converting</span>
<span class="s0"># structured data into something we can cryptographically sign.</span>
<span class="s2">def </span><span class="s1">_signable</span><span class="s3">(*</span><span class="s1">fields</span><span class="s3">):</span>
    <span class="s1">out </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields</span><span class="s3">:</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s6">&quot;!Q&quot;</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)))</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">field</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">b&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_make_cookie</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">salt</span><span class="s3">, </span><span class="s1">tick</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">client_hello_bits</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">salt</span><span class="s3">) == </span><span class="s1">SALT_BYTES</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) == </span><span class="s1">KEY_BYTES</span>

    <span class="s1">signable_data </span><span class="s3">= </span><span class="s1">_signable</span><span class="s3">(</span>
        <span class="s1">salt</span><span class="s3">,</span>
        <span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s6">&quot;!Q&quot;</span><span class="s3">, </span><span class="s1">tick</span><span class="s3">),</span>
        <span class="s0"># address is a mix of strings and ints, and variable length, so pack</span>
        <span class="s0"># it into a single nested field</span>
        <span class="s1">_signable</span><span class="s3">(*(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">part</span><span class="s3">).</span><span class="s1">encode</span><span class="s3">() </span><span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">address</span><span class="s3">)),</span>
        <span class="s1">client_hello_bits</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">return </span><span class="s3">(</span><span class="s1">salt </span><span class="s3">+ </span><span class="s1">hmac</span><span class="s3">.</span><span class="s1">digest</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">signable_data</span><span class="s3">, </span><span class="s1">COOKIE_HASH</span><span class="s3">))[:</span><span class="s1">COOKIE_LENGTH</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">valid_cookie</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">client_hello_bits</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">cookie</span><span class="s3">) &gt; </span><span class="s1">SALT_BYTES</span><span class="s3">:</span>
        <span class="s1">salt </span><span class="s3">= </span><span class="s1">cookie</span><span class="s3">[:</span><span class="s1">SALT_BYTES</span><span class="s3">]</span>

        <span class="s1">tick </span><span class="s3">= </span><span class="s1">_current_cookie_tick</span><span class="s3">()</span>

        <span class="s1">cur_cookie </span><span class="s3">= </span><span class="s1">_make_cookie</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">salt</span><span class="s3">, </span><span class="s1">tick</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">client_hello_bits</span><span class="s3">)</span>
        <span class="s1">old_cookie </span><span class="s3">= </span><span class="s1">_make_cookie</span><span class="s3">(</span>
            <span class="s1">key</span><span class="s3">, </span><span class="s1">salt</span><span class="s3">, </span><span class="s1">max</span><span class="s3">(</span><span class="s1">tick </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">), </span><span class="s1">address</span><span class="s3">, </span><span class="s1">client_hello_bits</span>
        <span class="s3">)</span>

        <span class="s0"># I doubt using a short-circuiting 'or' here would leak any meaningful</span>
        <span class="s0"># information, but why risk it when '|' is just as easy.</span>
        <span class="s2">return </span><span class="s1">hmac</span><span class="s3">.</span><span class="s1">compare_digest</span><span class="s3">(</span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">cur_cookie</span><span class="s3">) | </span><span class="s1">hmac</span><span class="s3">.</span><span class="s1">compare_digest</span><span class="s3">(</span>
            <span class="s1">cookie</span><span class="s3">, </span><span class="s1">old_cookie</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">challenge_for</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">client_hello_bits</span><span class="s3">):</span>
    <span class="s1">salt </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">urandom</span><span class="s3">(</span><span class="s1">SALT_BYTES</span><span class="s3">)</span>
    <span class="s1">tick </span><span class="s3">= </span><span class="s1">_current_cookie_tick</span><span class="s3">()</span>
    <span class="s1">cookie </span><span class="s3">= </span><span class="s1">_make_cookie</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">salt</span><span class="s3">, </span><span class="s1">tick</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">client_hello_bits</span><span class="s3">)</span>

    <span class="s0"># HelloVerifyRequest body is:</span>
    <span class="s0"># - 2 bytes version</span>
    <span class="s0"># - length-prefixed cookie</span>
    <span class="s0">#</span>
    <span class="s0"># The DTLS 1.2 spec says that for this message specifically we should use</span>
    <span class="s0"># the DTLS 1.0 version.</span>
    <span class="s0">#</span>
    <span class="s0"># (It also says the opposite of that, but that part is a mistake:</span>
    <span class="s0">#    https://www.rfc-editor.org/errata/eid4103</span>
    <span class="s0"># ).</span>
    <span class="s0">#</span>
    <span class="s0"># And I guess we use this for both the message-level and record-level</span>
    <span class="s0"># ProtocolVersions, since we haven't negotiated anything else yet?</span>
    <span class="s1">body </span><span class="s3">= </span><span class="s1">ProtocolVersion</span><span class="s3">.</span><span class="s1">DTLS10 </span><span class="s3">+ </span><span class="s1">bytes</span><span class="s3">([</span><span class="s1">len</span><span class="s3">(</span><span class="s1">cookie</span><span class="s3">)]) + </span><span class="s1">cookie</span>

    <span class="s0"># RFC says have to copy the client's record number</span>
    <span class="s0"># Errata says it should be handshake message number</span>
    <span class="s0"># Openssl copies back record sequence number, and always sets message seq</span>
    <span class="s0"># number 0. So I guess we'll follow openssl.</span>
    <span class="s1">hs </span><span class="s3">= </span><span class="s1">HandshakeFragment</span><span class="s3">(</span>
        <span class="s1">msg_type</span><span class="s3">=</span><span class="s1">HandshakeType</span><span class="s3">.</span><span class="s1">hello_verify_request</span><span class="s3">,</span>
        <span class="s1">msg_len</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">body</span><span class="s3">),</span>
        <span class="s1">msg_seq</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
        <span class="s1">frag_offset</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
        <span class="s1">frag_len</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">body</span><span class="s3">),</span>
        <span class="s1">frag</span><span class="s3">=</span><span class="s1">body</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">payload </span><span class="s3">= </span><span class="s1">encode_handshake_fragment</span><span class="s3">(</span><span class="s1">hs</span><span class="s3">)</span>

    <span class="s1">packet </span><span class="s3">= </span><span class="s1">encode_record</span><span class="s3">(</span>
        <span class="s1">Record</span><span class="s3">(</span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">handshake</span><span class="s3">, </span><span class="s1">ProtocolVersion</span><span class="s3">.</span><span class="s1">DTLS10</span><span class="s3">, </span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">payload</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">packet</span>


<span class="s2">class </span><span class="s1">_Queue</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">incoming_packets_buffer</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">s</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">r </span><span class="s3">= </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">open_memory_channel</span><span class="s3">(</span><span class="s1">incoming_packets_buffer</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_read_loop</span><span class="s3">(</span><span class="s1">read_fn</span><span class="s3">):</span>
    <span class="s1">chunks </span><span class="s3">= []</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">chunk </span><span class="s3">= </span><span class="s1">read_fn</span><span class="s3">(</span><span class="s4">2</span><span class="s3">**</span><span class="s4">14</span><span class="s3">)  </span><span class="s0"># max TLS record size</span>
        <span class="s2">except </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">WantReadError</span><span class="s3">:</span>
            <span class="s2">break</span>
        <span class="s1">chunks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s5">b&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">chunks</span><span class="s3">)</span>


<span class="s2">async def </span><span class="s1">handle_client_hello_untrusted</span><span class="s3">(</span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">packet</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_context </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">bits </span><span class="s3">= </span><span class="s1">decode_client_hello_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">BadPacket</span><span class="s3">:</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_key </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_key </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">urandom</span><span class="s3">(</span><span class="s1">KEY_BYTES</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">valid_cookie</span><span class="s3">(</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_key</span><span class="s3">, </span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">):</span>
        <span class="s1">challenge_packet </span><span class="s3">= </span><span class="s1">challenge_for</span><span class="s3">(</span>
            <span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_key</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">epoch_seqno</span><span class="s3">, </span><span class="s1">bits</span>
        <span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">async with </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_send_lock</span><span class="s3">:</span>
                <span class="s2">await </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">sendto</span><span class="s3">(</span><span class="s1">challenge_packet</span><span class="s3">, </span><span class="s1">address</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">ClosedResourceError</span><span class="s3">):</span>
            <span class="s2">pass</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># We got a real, valid ClientHello!</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">DTLSChannel</span><span class="s3">.</span><span class="s1">_create</span><span class="s3">(</span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_listening_context</span><span class="s3">)</span>
        <span class="s0"># Our HelloRetryRequest had some sequence number. We need our future sequence</span>
        <span class="s0"># numbers to be larger than it, so our peer knows that our future records aren't</span>
        <span class="s0"># stale/duplicates. But, we don't know what this sequence number was. What we do</span>
        <span class="s0"># know is:</span>
        <span class="s0"># - the HelloRetryRequest seqno was copied it from the initial ClientHello</span>
        <span class="s0"># - the new ClientHello has a higher seqno than the initial ClientHello</span>
        <span class="s0"># So, if we copy the new ClientHello's seqno into our first real handshake</span>
        <span class="s0"># record and increment from there, that should work.</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">_record_encoder</span><span class="s3">.</span><span class="s1">set_first_record_number</span><span class="s3">(</span><span class="s1">epoch_seqno</span><span class="s3">)</span>
        <span class="s0"># Process the ClientHello</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">stream</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_write</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
            <span class="s1">stream</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">DTLSv1_listen</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">Error</span><span class="s3">:</span>
            <span class="s0"># ...OpenSSL didn't like it, so I guess we didn't have a valid ClientHello</span>
            <span class="s0"># after all.</span>
            <span class="s2">return</span>

        <span class="s0"># Some old versions of OpenSSL have a bug with memory BIOs, where DTLSv1_listen</span>
        <span class="s0"># consumes the ClientHello out of the BIO, but then do_handshake expects the</span>
        <span class="s0"># ClientHello to still be in there (but not the one that ships with Ubuntu</span>
        <span class="s0"># 20.04). In particular, this is known to affect the OpenSSL v1.1.1 that ships</span>
        <span class="s0"># with Ubuntu 18.04. To work around this, we deliver a second copy of the</span>
        <span class="s0"># ClientHello after DTLSv1_listen has completed. This is safe to do</span>
        <span class="s0"># unconditionally, because on newer versions of OpenSSL, the second ClientHello</span>
        <span class="s0"># is treated as a duplicate packet, which is a normal thing that can happen over</span>
        <span class="s0"># UDP. For more details, see:</span>
        <span class="s0">#</span>
        <span class="s0">#     https://github.com/pyca/pyopenssl/blob/e84e7b57d1838de70ab7a27089fbee78ce0d2106/tests/test_ssl.py#L4226-L4293</span>
        <span class="s0">#</span>
        <span class="s0"># This was fixed in v1.1.1a, and all later versions. So maybe in 2024 or so we</span>
        <span class="s0"># can delete this. The fix landed in OpenSSL master as 079ef6bd534d2, and then</span>
        <span class="s0"># was backported to the 1.1.1 branch as d1bfd8076e28.</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_write</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>

        <span class="s0"># Check if we have an existing association</span>
        <span class="s1">old_stream </span><span class="s3">= </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">address</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">old_stream </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">old_stream</span><span class="s3">.</span><span class="s1">_client_hello </span><span class="s3">== (</span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">):</span>
                <span class="s0"># ...This was just a duplicate of the last ClientHello, so never mind.</span>
                <span class="s2">return</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># Ok, this *really is* a new handshake; the old stream should go away.</span>
                <span class="s1">old_stream</span><span class="s3">.</span><span class="s1">_set_replaced</span><span class="s3">()</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">_client_hello </span><span class="s3">= (</span><span class="s1">cookie</span><span class="s3">, </span><span class="s1">bits</span><span class="s3">)</span>
        <span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">[</span><span class="s1">address</span><span class="s3">] = </span><span class="s1">stream</span>
        <span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_incoming_connections_q</span><span class="s3">.</span><span class="s1">s</span><span class="s3">.</span><span class="s1">send_nowait</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>


<span class="s2">async def </span><span class="s1">dtls_receive_loop</span><span class="s3">(</span><span class="s1">endpoint_ref</span><span class="s3">, </span><span class="s1">sock</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">packet</span><span class="s3">, </span><span class="s1">address </span><span class="s3">= </span><span class="s2">await </span><span class="s1">sock</span><span class="s3">.</span><span class="s1">recvfrom</span><span class="s3">(</span><span class="s1">MAX_UDP_PACKET_SIZE</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">errno </span><span class="s3">== </span><span class="s1">errno</span><span class="s3">.</span><span class="s1">ECONNRESET</span><span class="s3">:</span>
                    <span class="s0"># Windows only: &quot;On a UDP-datagram socket [ECONNRESET]</span>
                    <span class="s0"># indicates a previous send operation resulted in an ICMP Port</span>
                    <span class="s0"># Unreachable message&quot; -- https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom</span>
                    <span class="s0">#</span>
                    <span class="s0"># This is totally useless -- there's nothing we can do with this</span>
                    <span class="s0"># information. So we just ignore it and retry the recv.</span>
                    <span class="s2">continue</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise</span>
            <span class="s1">endpoint </span><span class="s3">= </span><span class="s1">endpoint_ref</span><span class="s3">()</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">endpoint </span><span class="s2">is None</span><span class="s3">:</span>
                    <span class="s2">return</span>
                <span class="s2">if </span><span class="s1">is_client_hello_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
                    <span class="s2">await </span><span class="s1">handle_client_hello_untrusted</span><span class="s3">(</span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">packet</span><span class="s3">)</span>
                <span class="s2">elif </span><span class="s1">address </span><span class="s2">in </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">:</span>
                    <span class="s1">stream </span><span class="s3">= </span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">[</span><span class="s1">address</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_did_handshake </span><span class="s2">and </span><span class="s1">part_of_handshake_untrusted</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">):</span>
                        <span class="s0"># The peer just sent us more handshake messages, that aren't a</span>
                        <span class="s0"># ClientHello, and we thought the handshake was done. Some of</span>
                        <span class="s0"># the packets that we sent to finish the handshake must have</span>
                        <span class="s0"># gotten lost. So re-send them. We do this directly here instead</span>
                        <span class="s0"># of just putting it into the queue and letting the receiver do</span>
                        <span class="s0"># it, because there's no guarantee that anyone is reading from</span>
                        <span class="s0"># the queue, because we think the handshake is done!</span>
                        <span class="s2">await </span><span class="s1">stream</span><span class="s3">.</span><span class="s1">_resend_final_volley</span><span class="s3">()</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s1">stream</span><span class="s3">.</span><span class="s1">_q</span><span class="s3">.</span><span class="s1">s</span><span class="s3">.</span><span class="s1">send_nowait</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">WouldBlock</span><span class="s3">:</span>
                            <span class="s1">stream</span><span class="s3">.</span><span class="s1">_packets_dropped_in_trio </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s0"># Drop packet</span>
                    <span class="s2">pass</span>
            <span class="s2">finally</span><span class="s3">:</span>
                <span class="s2">del </span><span class="s1">endpoint</span>
    <span class="s2">except </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">ClosedResourceError</span><span class="s3">:</span>
        <span class="s0"># socket was closed</span>
        <span class="s2">return</span>
    <span class="s2">except </span><span class="s1">OSError </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">errno </span><span class="s2">in </span><span class="s3">(</span><span class="s1">errno</span><span class="s3">.</span><span class="s1">EBADF</span><span class="s3">, </span><span class="s1">errno</span><span class="s3">.</span><span class="s1">ENOTSOCK</span><span class="s3">):</span>
            <span class="s0"># socket was closed</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
            <span class="s0"># ??? shouldn't happen</span>
            <span class="s2">raise</span>


<span class="s3">@</span><span class="s1">attr</span><span class="s3">.</span><span class="s1">frozen</span>
<span class="s2">class </span><span class="s1">DTLSChannelStatistics</span><span class="s3">:</span>
    <span class="s1">incoming_packets_dropped_in_trio</span><span class="s3">: </span><span class="s1">int</span>


<span class="s2">class </span><span class="s1">DTLSChannel</span><span class="s3">(</span><span class="s1">trio</span><span class="s3">.</span><span class="s1">abc</span><span class="s3">.</span><span class="s1">Channel</span><span class="s3">[</span><span class="s1">bytes</span><span class="s3">], </span><span class="s1">metaclass</span><span class="s3">=</span><span class="s1">NoPublicConstructor</span><span class="s3">):</span>
    <span class="s7">&quot;&quot;&quot;A DTLS connection. 
 
    This class has no public constructor  you get instances by calling 
    `DTLSEndpoint.serve` or `~DTLSEndpoint.connect`. 
 
    .. attribute:: endpoint 
 
       The `DTLSEndpoint` that this connection is using. 
 
    .. attribute:: peer_address 
 
       The IP/port of the remote peer that this connection is associated with. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">, </span><span class="s1">peer_address</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint </span><span class="s3">= </span><span class="s1">endpoint</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">peer_address </span><span class="s3">= </span><span class="s1">peer_address</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_packets_dropped_in_trio </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_client_hello </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s0"># These are mandatory for all DTLS connections. OP_NO_QUERY_MTU is required to</span>
        <span class="s0"># stop openssl from trying to query the memory BIO's MTU and then breaking, and</span>
        <span class="s0"># OP_NO_RENEGOTIATION disables renegotiation, which is too complex for us to</span>
        <span class="s0"># support and isn't useful anyway -- especially for DTLS where it's equivalent</span>
        <span class="s0"># to just performing a new handshake.</span>
        <span class="s1">ctx</span><span class="s3">.</span><span class="s1">set_options</span><span class="s3">(</span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">OP_NO_QUERY_MTU </span><span class="s3">| </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">OP_NO_RENEGOTIATION</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl </span><span class="s3">= </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">Connection</span><span class="s3">(</span><span class="s1">ctx</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_mtu </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s0"># This calls self._ssl.set_ciphertext_mtu, which is important, because if you</span>
        <span class="s0"># don't call it then openssl doesn't work.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_ciphertext_mtu</span><span class="s3">(</span><span class="s1">best_guess_mtu</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_replaced </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_q </span><span class="s3">= </span><span class="s1">_Queue</span><span class="s3">(</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">incoming_packets_buffer</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_lock </span><span class="s3">= </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">Lock</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_record_encoder </span><span class="s3">= </span><span class="s1">RecordEncoder</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_set_replaced</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_replaced </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s0"># Any packets we already received could maybe possibly still be processed, but</span>
        <span class="s0"># there are no more coming. So we close this on the sender side.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_q</span><span class="s3">.</span><span class="s1">s</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_check_replaced</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replaced</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">BrokenResourceError</span><span class="s3">(</span>
                <span class="s6">&quot;peer tore down this connection to start a new one&quot;</span>
            <span class="s3">)</span>

    <span class="s0"># XX on systems where we can (maybe just Linux?) take advantage of the kernel's PMTU</span>
    <span class="s0"># estimate</span>

    <span class="s0"># XX should we send close-notify when closing? It seems particularly pointless for</span>
    <span class="s0"># DTLS where packets are all independent and can be lost anyway. We do at least need</span>
    <span class="s0"># to handle receiving it properly though, which might be easier if we send it...</span>

    <span class="s2">def </span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Close this connection. 
 
        `DTLSChannel`\\s don't actually own any OS-level resources  the 
        socket is owned by the `DTLSEndpoint`, not the individual connections. So 
        you don't really *have* to call this. But it will interrupt any other tasks 
        calling `receive` with a `ClosedResourceError`, and cause future attempts to use 
        this connection to fail. 
 
        You can also use this object as a synchronous or asynchronous context manager. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">peer_address</span><span class="s3">) </span><span class="s2">is </span><span class="s1">self</span><span class="s3">:</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">peer_address</span><span class="s3">]</span>
        <span class="s0"># Will wake any tasks waiting on self._q.get with a</span>
        <span class="s0"># ClosedResourceError</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_q</span><span class="s3">.</span><span class="s1">r</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__enter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">async def </span><span class="s1">aclose</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Close this connection, but asynchronously. 
 
        This is included to satisfy the `trio.abc.Channel` contract. It's 
        identical to `close`, but async. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">await </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">lowlevel</span><span class="s3">.</span><span class="s1">checkpoint</span><span class="s3">()</span>

    <span class="s2">async def </span><span class="s1">_send_volley</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">volley_messages</span><span class="s3">):</span>
        <span class="s1">packets </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_record_encoder</span><span class="s3">.</span><span class="s1">encode_volley</span><span class="s3">(</span>
            <span class="s1">volley_messages</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_mtu</span>
        <span class="s3">)</span>
        <span class="s2">for </span><span class="s1">packet </span><span class="s2">in </span><span class="s1">packets</span><span class="s3">:</span>
            <span class="s2">async with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_send_lock</span><span class="s3">:</span>
                <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">sendto</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">peer_address</span><span class="s3">)</span>

    <span class="s2">async def </span><span class="s1">_resend_final_volley</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_send_volley</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_final_volley</span><span class="s3">)</span>

    <span class="s2">async def </span><span class="s1">do_handshake</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">initial_retransmit_timeout</span><span class="s3">=</span><span class="s4">1.0</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Perform the handshake. 
 
        Calling this is optional  if you don't, then it will be automatically called 
        the first time you call `send` or `receive`. But calling it explicitly can be 
        useful in case you want to control the retransmit timeout, use a cancel scope to 
        place an overall timeout on the handshake, or catch errors from the handshake 
        specifically. 
 
        It's safe to call this multiple times, or call it simultaneously from multiple 
        tasks  the first call will perform the handshake, and the rest will be no-ops. 
 
        Args: 
 
          initial_retransmit_timeout (float): Since UDP is an unreliable protocol, it's 
            possible that some of the packets we send during the handshake will get 
            lost. To handle this, DTLS uses a timer to automatically retransmit 
            handshake packets that don't receive a response. This lets you set the 
            timeout we use to detect packet loss. Ideally, it should be set to ~1.5 
            times the round-trip time to your peer, but 1 second is a reasonable 
            default. There's `some useful guidance here 
            &lt;https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values&gt;`__. 
 
            This is the *initial* timeout, because if packets keep being lost then Trio 
            will automatically back off to longer values, to avoid overloading the 
            network. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">async with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_lock</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake</span><span class="s3">:</span>
                <span class="s2">return</span>

            <span class="s1">timeout </span><span class="s3">= </span><span class="s1">initial_retransmit_timeout</span>
            <span class="s1">volley_messages </span><span class="s3">= []</span>
            <span class="s1">volley_failed_sends </span><span class="s3">= </span><span class="s4">0</span>

            <span class="s2">def </span><span class="s1">read_volley</span><span class="s3">():</span>
                <span class="s1">volley_bytes </span><span class="s3">= </span><span class="s1">_read_loop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_read</span><span class="s3">)</span>
                <span class="s1">new_volley_messages </span><span class="s3">= </span><span class="s1">decode_volley_trusted</span><span class="s3">(</span><span class="s1">volley_bytes</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">new_volley_messages</span>
                    <span class="s2">and </span><span class="s1">volley_messages</span>
                    <span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">new_volley_messages</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">HandshakeMessage</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">new_volley_messages</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">msg_seq </span><span class="s3">== </span><span class="s1">volley_messages</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">msg_seq</span>
                <span class="s3">):</span>
                    <span class="s0"># openssl decided to retransmit; discard because we handle</span>
                    <span class="s0"># retransmits ourselves</span>
                    <span class="s2">return </span><span class="s3">[]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">new_volley_messages</span>

            <span class="s0"># If we're a client, we send the initial volley. If we're a server, then</span>
            <span class="s0"># the initial ClientHello has already been inserted into self._ssl's</span>
            <span class="s0"># read BIO. So either way, we start by generating a new volley.</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">do_handshake</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">WantReadError</span><span class="s3">:</span>
                <span class="s2">pass</span>
            <span class="s1">volley_messages </span><span class="s3">= </span><span class="s1">read_volley</span><span class="s3">()</span>
            <span class="s0"># If we don't have messages to send in our initial volley, then something</span>
            <span class="s0"># has gone very wrong. (I'm not sure this can actually happen without an</span>
            <span class="s0"># error from OpenSSL, but we check just in case.)</span>
            <span class="s2">if not </span><span class="s1">volley_messages</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
                <span class="s2">raise </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">Error</span><span class="s3">(</span><span class="s6">&quot;something wrong with peer's ClientHello&quot;</span><span class="s3">)</span>

            <span class="s2">while True</span><span class="s3">:</span>
                <span class="s0"># -- at this point, we need to either send or re-send a volley --</span>
                <span class="s2">assert </span><span class="s1">volley_messages</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_replaced</span><span class="s3">()</span>
                <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_send_volley</span><span class="s3">(</span><span class="s1">volley_messages</span><span class="s3">)</span>
                <span class="s0"># -- then this is where we wait for a reply --</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_ensure_receive_loop</span><span class="s3">()</span>
                <span class="s2">with </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">move_on_after</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">) </span><span class="s2">as </span><span class="s1">cscope</span><span class="s3">:</span>
                    <span class="s2">async for </span><span class="s1">packet </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_q</span><span class="s3">.</span><span class="s1">r</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_write</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">do_handshake</span><span class="s3">()</span>
                        <span class="s0"># We ignore generic SSL.Error here, because you can get those</span>
                        <span class="s0"># from random invalid packets</span>
                        <span class="s2">except </span><span class="s3">(</span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">WantReadError</span><span class="s3">, </span><span class="s1">SSL</span><span class="s3">.</span><span class="s1">Error</span><span class="s3">):</span>
                            <span class="s2">pass</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s0"># No exception -&gt; the handshake is done, and we can</span>
                            <span class="s0"># switch into data transfer mode.</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake </span><span class="s3">= </span><span class="s2">True</span>
                            <span class="s0"># Might be empty, but that's ok -- we'll just send no</span>
                            <span class="s0"># packets.</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">_final_volley </span><span class="s3">= </span><span class="s1">read_volley</span><span class="s3">()</span>
                            <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_send_volley</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_final_volley</span><span class="s3">)</span>
                            <span class="s2">return</span>
                        <span class="s1">maybe_volley </span><span class="s3">= </span><span class="s1">read_volley</span><span class="s3">()</span>
                        <span class="s2">if </span><span class="s1">maybe_volley</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s3">(</span>
                                <span class="s1">isinstance</span><span class="s3">(</span><span class="s1">maybe_volley</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">PseudoHandshakeMessage</span><span class="s3">)</span>
                                <span class="s2">and </span><span class="s1">maybe_volley</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">content_type </span><span class="s3">== </span><span class="s1">ContentType</span><span class="s3">.</span><span class="s1">alert</span>
                            <span class="s3">):</span>
                                <span class="s0"># we're sending an alert (e.g. due to a corrupted</span>
                                <span class="s0"># packet). We want to send it once, but don't save it to</span>
                                <span class="s0"># retransmit -- keep the last volley as the current</span>
                                <span class="s0"># volley.</span>
                                <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_send_volley</span><span class="s3">(</span><span class="s1">maybe_volley</span><span class="s3">)</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s0"># We managed to get all of the peer's volley and</span>
                                <span class="s0"># generate a new one ourselves! break out of the 'for'</span>
                                <span class="s0"># loop and restart the timer.</span>
                                <span class="s1">volley_messages </span><span class="s3">= </span><span class="s1">maybe_volley</span>
                                <span class="s0"># &quot;Implementations SHOULD retain the current timer value</span>
                                <span class="s0"># until a transmission without loss occurs, at which</span>
                                <span class="s0"># time the value may be reset to the initial value.&quot;</span>
                                <span class="s2">if </span><span class="s1">volley_failed_sends </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                                    <span class="s1">timeout </span><span class="s3">= </span><span class="s1">initial_retransmit_timeout</span>
                                <span class="s1">volley_failed_sends </span><span class="s3">= </span><span class="s4">0</span>
                                <span class="s2">break</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replaced</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_replaced</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">cscope</span><span class="s3">.</span><span class="s1">cancelled_caught</span><span class="s3">:</span>
                    <span class="s0"># Timeout expired. Double timeout for backoff, with a limit of 60</span>
                    <span class="s0"># seconds (this matches what openssl does, and also the</span>
                    <span class="s0"># recommendation in draft-ietf-tls-dtls13).</span>
                    <span class="s1">timeout </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">timeout</span><span class="s3">, </span><span class="s4">60.0</span><span class="s3">)</span>
                    <span class="s1">volley_failed_sends </span><span class="s3">+= </span><span class="s4">1</span>
                    <span class="s2">if </span><span class="s1">volley_failed_sends </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
                        <span class="s0"># We tried sending this twice and they both failed. Maybe our</span>
                        <span class="s0"># PMTU estimate is wrong? Let's try dropping it to the minimum</span>
                        <span class="s0"># and hope that helps.</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_mtu </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_mtu</span><span class="s3">, </span><span class="s1">worst_case_mtu</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">)</span>
                        <span class="s3">)</span>

    <span class="s2">async def </span><span class="s1">send</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Send a packet of data, securely.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">ClosedResourceError</span>
        <span class="s2">if not </span><span class="s1">data</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;openssl doesn't support sending empty DTLS packets&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake</span><span class="s3">:</span>
            <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">do_handshake</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_replaced</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s2">async with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">_send_lock</span><span class="s3">:</span>
            <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endpoint</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">sendto</span><span class="s3">(</span>
                <span class="s1">_read_loop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_read</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">peer_address</span>
            <span class="s3">)</span>

    <span class="s2">async def </span><span class="s1">receive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Fetch the next packet of data from this connection's peer, waiting if 
        necessary. 
 
        This is safe to call from multiple tasks simultaneously, in case you have some 
        reason to do that. And more importantly, it's cancellation-safe, meaning that 
        cancelling a call to `receive` will never cause a packet to be lost or corrupt 
        the underlying connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake</span><span class="s3">:</span>
            <span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">do_handshake</span><span class="s3">()</span>
        <span class="s0"># If the packet isn't really valid, then openssl can decode it to the empty</span>
        <span class="s0"># string (e.g. b/c it's a late-arriving handshake packet, or a duplicate copy of</span>
        <span class="s0"># a data packet). Skip over these instead of returning them.</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">packet </span><span class="s3">= </span><span class="s2">await </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_q</span><span class="s3">.</span><span class="s1">r</span><span class="s3">.</span><span class="s1">receive</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">EndOfChannel</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_replaced</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_replaced</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">bio_write</span><span class="s3">(</span><span class="s1">packet</span><span class="s3">)</span>
            <span class="s1">cleartext </span><span class="s3">= </span><span class="s1">_read_loop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">read</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">cleartext</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">cleartext</span>

    <span class="s2">def </span><span class="s1">set_ciphertext_mtu</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">new_mtu</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Tells Trio the `largest amount of data that can be sent in a single packet to 
        this peer &lt;https://en.wikipedia.org/wiki/Maximum_transmission_unit&gt;`__. 
 
        Trio doesn't actually enforce this limit  if you pass a huge packet to `send`, 
        then we'll dutifully encrypt it and attempt to send it. But calling this method 
        does have two useful effects: 
 
        - If called before the handshake is performed, then Trio will automatically 
          fragment handshake messages to fit within the given MTU. It also might 
          fragment them even smaller, if it detects signs of packet loss, so setting 
          this should never be necessary to make a successful connection. But, the 
          packet loss detection only happens after multiple timeouts have expired, so if 
          you have reason to believe that a smaller MTU is required, then you can set 
          this to skip those timeouts and establish the connection more quickly. 
 
        - It changes the value returned from `get_cleartext_mtu`. So if you have some 
          kind of estimate of the network-level MTU, then you can use this to figure out 
          how much overhead DTLS will need for hashes/padding/etc., and how much space 
          you have left for your application data. 
 
        The MTU here is measuring the largest UDP *payload* you think can be sent, the 
        amount of encrypted data that can be handed to the operating system in a single 
        call to `send`. It should *not* include IP/UDP headers. Note that OS estimates 
        of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on 
        IPv4 and 48 bytes on IPv6 to get the ciphertext MTU. 
 
        By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6, 
        which correspond to the common Ethernet MTU of 1500 bytes after accounting for 
        IP/UDP overhead. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_handshake_mtu </span><span class="s3">= </span><span class="s1">new_mtu</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">set_ciphertext_mtu</span><span class="s3">(</span><span class="s1">new_mtu</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_cleartext_mtu</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Returns the largest number of bytes that you can pass in a single call to 
        `send` while still fitting within the network-level MTU. 
 
        See `set_ciphertext_mtu` for more details. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_did_handshake</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">NeedHandshakeError</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">get_cleartext_mtu</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">statistics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Returns an object with statistics about this connection. 
 
        Currently this has only one attribute: 
 
        - ``incoming_packets_dropped_in_trio`` (``int``): Gives a count of the number of 
          incoming packets from this peer that Trio successfully received from the 
          network, but then got dropped because the internal channel buffer was full. If 
          this is non-zero, then you might want to call ``receive`` more often, or use a 
          larger ``incoming_packets_buffer``, or just not worry about it because your 
          UDP-based protocol should be able to handle the occasional lost packet, right? 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">DTLSChannelStatistics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_packets_dropped_in_trio</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">DTLSEndpoint</span><span class="s3">(</span><span class="s1">metaclass</span><span class="s3">=</span><span class="s1">Final</span><span class="s3">):</span>
    <span class="s7">&quot;&quot;&quot;A DTLS endpoint. 
 
    A single UDP socket can handle arbitrarily many DTLS connections simultaneously, 
    acting as a client or server as needed. A `DTLSEndpoint` object holds a UDP socket 
    and manages these connections, which are represented as `DTLSChannel` objects. 
 
    Args: 
      socket: (trio.socket.SocketType): A ``SOCK_DGRAM`` socket. If you want to accept 
        incoming connections in server mode, then you should probably bind the socket to 
        some known port. 
      incoming_packets_buffer (int): Each `DTLSChannel` using this socket has its own 
        buffer that holds incoming packets until you call `~DTLSChannel.receive` to read 
        them. This lets you adjust the size of this buffer. `~DTLSChannel.statistics` 
        lets you check if the buffer has overflowed. 
 
    .. attribute:: socket 
                   incoming_packets_buffer 
 
       Both constructor arguments are also exposed as attributes, in case you need to 
       access them later. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, *, </span><span class="s1">incoming_packets_buffer</span><span class="s3">=</span><span class="s4">10</span><span class="s3">):</span>
        <span class="s0"># We do this lazily on first construction, so only people who actually use DTLS</span>
        <span class="s0"># have to install PyOpenSSL.</span>
        <span class="s2">global </span><span class="s1">SSL</span>
        <span class="s2">from </span><span class="s1">OpenSSL </span><span class="s2">import </span><span class="s1">SSL</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">socket </span><span class="s3">= </span><span class="s2">None  </span><span class="s0"># for __del__, in case the next line raises</span>
        <span class="s2">if </span><span class="s1">socket</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">SOCK_DGRAM</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;DTLS requires a SOCK_DGRAM socket&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">socket </span><span class="s3">= </span><span class="s1">socket</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">incoming_packets_buffer </span><span class="s3">= </span><span class="s1">incoming_packets_buffer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_token </span><span class="s3">= </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">lowlevel</span><span class="s3">.</span><span class="s1">current_trio_token</span><span class="s3">()</span>
        <span class="s0"># We don't need to track handshaking vs non-handshake connections</span>
        <span class="s0"># separately. We only keep one connection per remote address; as soon</span>
        <span class="s0"># as a peer provides a valid cookie, we can immediately tear down the</span>
        <span class="s0"># old connection.</span>
        <span class="s0"># {remote address: DTLSChannel}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_streams </span><span class="s3">= </span><span class="s1">weakref</span><span class="s3">.</span><span class="s1">WeakValueDictionary</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_listening_context </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_listening_key </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_incoming_connections_q </span><span class="s3">= </span><span class="s1">_Queue</span><span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s6">&quot;inf&quot;</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_send_lock </span><span class="s3">= </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">Lock</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_receive_loop_spawned </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_ensure_receive_loop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># We have to spawn this lazily, because on Windows it will immediately error out</span>
        <span class="s0"># if the socket isn't already bound -- which for clients might not happen until</span>
        <span class="s0"># after we send our first packet.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_receive_loop_spawned</span><span class="s3">:</span>
            <span class="s1">trio</span><span class="s3">.</span><span class="s1">lowlevel</span><span class="s3">.</span><span class="s1">spawn_system_task</span><span class="s3">(</span>
                <span class="s1">dtls_receive_loop</span><span class="s3">, </span><span class="s1">weakref</span><span class="s3">.</span><span class="s1">ref</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">socket</span>
            <span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_receive_loop_spawned </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__del__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Do nothing if this object was never fully constructed</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">socket </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s0"># Close the socket in Trio context (if our Trio context still exists), so that</span>
        <span class="s0"># the background task gets notified about the closure and can exit.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_token</span><span class="s3">.</span><span class="s1">run_sync_soon</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">close</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">RuntimeError</span><span class="s3">:</span>
                <span class="s2">pass</span>
            <span class="s0"># Do this last, because it might raise an exception</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s6">f&quot;unclosed DTLS endpoint </span><span class="s2">{</span><span class="s1">self</span><span class="s2">!r}</span><span class="s6">&quot;</span><span class="s3">, </span><span class="s1">ResourceWarning</span><span class="s3">, </span><span class="s1">source</span><span class="s3">=</span><span class="s1">self</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Close this socket, and all associated DTLS connections. 
 
        This object can also be used as a context manager. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">stream </span><span class="s2">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()):</span>
            <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_incoming_connections_q</span><span class="s3">.</span><span class="s1">s</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__enter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_check_closed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">ClosedResourceError</span>

    <span class="s2">async def </span><span class="s1">serve</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ssl_context</span><span class="s3">, </span><span class="s1">async_fn</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, </span><span class="s1">task_status</span><span class="s3">=</span><span class="s1">trio</span><span class="s3">.</span><span class="s1">TASK_STATUS_IGNORED</span>
    <span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Listen for incoming connections, and spawn a handler for each using an 
        internal nursery. 
 
        Similar to `~trio.serve_tcp`, this function never returns until cancelled, or 
        the `DTLSEndpoint` is closed and all handlers have exited. 
 
        Usage commonly looks like:: 
 
            async def handler(dtls_channel): 
                ... 
 
            async with trio.open_nursery() as nursery: 
                await nursery.start(dtls_endpoint.serve, ssl_context, handler) 
                # ... do other things here ... 
 
        The ``dtls_channel`` passed into the handler function has already performed the 
        &quot;cookie exchange&quot; part of the DTLS handshake, so the peer address is 
        trustworthy. But the actual cryptographic handshake doesn't happen until you 
        start using it, giving you a chance for any last minute configuration, and the 
        option to catch and handle handshake errors. 
 
        Args: 
          ssl_context (OpenSSL.SSL.Context): The PyOpenSSL context object to use for 
            incoming connections. 
          async_fn: The handler function that will be invoked for each incoming 
            connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_closed</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_listening_context </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">BusyResourceError</span><span class="s3">(</span><span class="s6">&quot;another task is already listening&quot;</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">socket</span><span class="s3">.</span><span class="s1">getsockname</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">OSError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s6">&quot;DTLS socket must be bound before it can serve&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_receive_loop</span><span class="s3">()</span>
        <span class="s0"># We do cookie verification ourselves, so tell OpenSSL not to worry about it.</span>
        <span class="s0"># (See also _inject_client_hello_untrusted.)</span>
        <span class="s1">ssl_context</span><span class="s3">.</span><span class="s1">set_cookie_verify_callback</span><span class="s3">(</span><span class="s2">lambda </span><span class="s3">*</span><span class="s1">_</span><span class="s3">: </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_listening_context </span><span class="s3">= </span><span class="s1">ssl_context</span>
            <span class="s1">task_status</span><span class="s3">.</span><span class="s1">started</span><span class="s3">()</span>

            <span class="s2">async def </span><span class="s1">handler_wrapper</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">):</span>
                <span class="s2">with </span><span class="s1">stream</span><span class="s3">:</span>
                    <span class="s2">await </span><span class="s1">async_fn</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>

            <span class="s2">async with </span><span class="s1">trio</span><span class="s3">.</span><span class="s1">open_nursery</span><span class="s3">() </span><span class="s2">as </span><span class="s1">nursery</span><span class="s3">:</span>
                <span class="s2">async for </span><span class="s1">stream </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_incoming_connections_q</span><span class="s3">.</span><span class="s1">r</span><span class="s3">:  </span><span class="s0"># pragma: no branch</span>
                    <span class="s1">nursery</span><span class="s3">.</span><span class="s1">start_soon</span><span class="s3">(</span><span class="s1">handler_wrapper</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_listening_context </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">connect</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">ssl_context</span><span class="s3">):</span>
        <span class="s7">&quot;&quot;&quot;Initiate an outgoing DTLS connection. 
 
        Notice that this is a synchronous method. That's because it doesn't actually 
        initiate any I/O  it just sets up a `DTLSChannel` object. The actual handshake 
        doesn't occur until you start using the `DTLSChannel`. This gives you a chance 
        to do further configuration first, like setting MTU etc. 
 
        Args: 
          address: The address to connect to. Usually a (host, port) tuple, like 
            ``(&quot;127.0.0.1&quot;, 12345)``. 
          ssl_context (OpenSSL.SSL.Context): The PyOpenSSL context object to use for 
            this connection. 
 
        Returns: 
          DTLSChannel 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># it would be nice if we could detect when 'address' is our own endpoint (a</span>
        <span class="s0"># loopback connection), because that can't work</span>
        <span class="s0"># but I don't see how to do it reliably</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_closed</span><span class="s3">()</span>
        <span class="s1">channel </span><span class="s3">= </span><span class="s1">DTLSChannel</span><span class="s3">.</span><span class="s1">_create</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">ssl_context</span><span class="s3">)</span>
        <span class="s1">channel</span><span class="s3">.</span><span class="s1">_ssl</span><span class="s3">.</span><span class="s1">set_connect_state</span><span class="s3">()</span>
        <span class="s1">old_channel </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">address</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">old_channel </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">old_channel</span><span class="s3">.</span><span class="s1">_set_replaced</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_streams</span><span class="s3">[</span><span class="s1">address</span><span class="s3">] = </span><span class="s1">channel</span>
        <span class="s2">return </span><span class="s1">channel</span>
</pre>
</body>
</html>