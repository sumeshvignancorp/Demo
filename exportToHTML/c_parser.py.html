<html>
<head>
<title>c_parser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
c_parser.py</font>
</center></td></tr></table>
<pre><span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># pycparser: c_parser.py</span>
<span class="s0">#</span>
<span class="s0"># CParser class: Parser and AST builder for the C language</span>
<span class="s0">#</span>
<span class="s0"># Eli Bendersky [https://eli.thegreenplace.net/]</span>
<span class="s0"># License: BSD</span>
<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">ply </span><span class="s2">import </span><span class="s1">yacc</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">c_ast</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">c_lexer </span><span class="s2">import </span><span class="s1">CLexer</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">plyparser </span><span class="s2">import </span><span class="s1">PLYParser</span><span class="s3">, </span><span class="s1">ParseError</span><span class="s3">, </span><span class="s1">parameterized</span><span class="s3">, </span><span class="s1">template</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">ast_transforms </span><span class="s2">import </span><span class="s1">fix_switch_cases</span><span class="s3">, </span><span class="s1">fix_atomic_specifiers</span>


<span class="s3">@</span><span class="s1">template</span>
<span class="s2">class </span><span class="s1">CParser</span><span class="s3">(</span><span class="s1">PLYParser</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">lex_optimize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">lexer</span><span class="s3">=</span><span class="s1">CLexer</span><span class="s3">,</span>
            <span class="s1">lextab</span><span class="s3">=</span><span class="s4">'pycparser.lextab'</span><span class="s3">,</span>
            <span class="s1">yacc_optimize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
            <span class="s1">yacctab</span><span class="s3">=</span><span class="s4">'pycparser.yacctab'</span><span class="s3">,</span>
            <span class="s1">yacc_debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
            <span class="s1">taboutputdir</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Create a new CParser. 
 
            Some arguments for controlling the debug/optimization 
            level of the parser are provided. The defaults are 
            tuned for release/performance mode. 
            The simple rules for using them are: 
            *) When tweaking CParser/CLexer, set these to False 
            *) When releasing a stable parser, set to True 
 
            lex_optimize: 
                Set to False when you're modifying the lexer. 
                Otherwise, changes in the lexer won't be used, if 
                some lextab.py file exists. 
                When releasing with a stable lexer, set to True 
                to save the re-generation of the lexer table on 
                each run. 
 
            lexer: 
                Set this parameter to define the lexer to use if 
                you're not using the default CLexer. 
 
            lextab: 
                Points to the lex table that's used for optimized 
                mode. Only if you're modifying the lexer and want 
                some tests to avoid re-generating the table, make 
                this point to a local lex table file (that's been 
                earlier generated with lex_optimize=True) 
 
            yacc_optimize: 
                Set to False when you're modifying the parser. 
                Otherwise, changes in the parser won't be used, if 
                some parsetab.py file exists. 
                When releasing with a stable parser, set to True 
                to save the re-generation of the parser table on 
                each run. 
 
            yacctab: 
                Points to the yacc table that's used for optimized 
                mode. Only if you're modifying the parser, make 
                this point to a local yacc table file 
 
            yacc_debug: 
                Generate a parser.out file that explains how yacc 
                built the parsing table from the grammar. 
 
            taboutputdir: 
                Set this parameter to control the location of generated 
                lextab and yacctab files. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">clex </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">(</span>
            <span class="s1">error_func</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lex_error_func</span><span class="s3">,</span>
            <span class="s1">on_lbrace_func</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lex_on_lbrace_func</span><span class="s3">,</span>
            <span class="s1">on_rbrace_func</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lex_on_rbrace_func</span><span class="s3">,</span>
            <span class="s1">type_lookup_func</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_lex_type_lookup_func</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">build</span><span class="s3">(</span>
            <span class="s1">optimize</span><span class="s3">=</span><span class="s1">lex_optimize</span><span class="s3">,</span>
            <span class="s1">lextab</span><span class="s3">=</span><span class="s1">lextab</span><span class="s3">,</span>
            <span class="s1">outputdir</span><span class="s3">=</span><span class="s1">taboutputdir</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tokens </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">tokens</span>

        <span class="s1">rules_with_opt </span><span class="s3">= [</span>
            <span class="s4">'abstract_declarator'</span><span class="s3">,</span>
            <span class="s4">'assignment_expression'</span><span class="s3">,</span>
            <span class="s4">'declaration_list'</span><span class="s3">,</span>
            <span class="s4">'declaration_specifiers_no_type'</span><span class="s3">,</span>
            <span class="s4">'designation'</span><span class="s3">,</span>
            <span class="s4">'expression'</span><span class="s3">,</span>
            <span class="s4">'identifier_list'</span><span class="s3">,</span>
            <span class="s4">'init_declarator_list'</span><span class="s3">,</span>
            <span class="s4">'id_init_declarator_list'</span><span class="s3">,</span>
            <span class="s4">'initializer_list'</span><span class="s3">,</span>
            <span class="s4">'parameter_type_list'</span><span class="s3">,</span>
            <span class="s4">'block_item_list'</span><span class="s3">,</span>
            <span class="s4">'type_qualifier_list'</span><span class="s3">,</span>
            <span class="s4">'struct_declarator_list'</span>
        <span class="s3">]</span>

        <span class="s2">for </span><span class="s1">rule </span><span class="s2">in </span><span class="s1">rules_with_opt</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_create_opt_rule</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">cparser </span><span class="s3">= </span><span class="s1">yacc</span><span class="s3">.</span><span class="s1">yacc</span><span class="s3">(</span>
            <span class="s1">module</span><span class="s3">=</span><span class="s1">self</span><span class="s3">,</span>
            <span class="s1">start</span><span class="s3">=</span><span class="s4">'translation_unit_or_empty'</span><span class="s3">,</span>
            <span class="s1">debug</span><span class="s3">=</span><span class="s1">yacc_debug</span><span class="s3">,</span>
            <span class="s1">optimize</span><span class="s3">=</span><span class="s1">yacc_optimize</span><span class="s3">,</span>
            <span class="s1">tabmodule</span><span class="s3">=</span><span class="s1">yacctab</span><span class="s3">,</span>
            <span class="s1">outputdir</span><span class="s3">=</span><span class="s1">taboutputdir</span><span class="s3">)</span>

        <span class="s0"># Stack of scopes for keeping track of symbols. _scope_stack[-1] is</span>
        <span class="s0"># the current (topmost) scope. Each scope is a dictionary that</span>
        <span class="s0"># specifies whether a name is a type. If _scope_stack[n][name] is</span>
        <span class="s0"># True, 'name' is currently a type in the scope. If it's False,</span>
        <span class="s0"># 'name' is used in the scope but not as a type (for instance, if we</span>
        <span class="s0"># saw: int name;</span>
        <span class="s0"># If 'name' is not a key in _scope_stack[n] then 'name' was not defined</span>
        <span class="s0"># in this scope at all.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack </span><span class="s3">= [</span><span class="s1">dict</span><span class="s3">()]</span>

        <span class="s0"># Keeps track of the last token given to yacc (the lookahead token)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_last_yielded_token </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">parse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Parses C code and returns an AST. 
 
            text: 
                A string containing the C source code 
 
            filename: 
                Name of the file being parsed (for meaningful 
                error messages) 
 
            debug: 
                Debug flag to YACC 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s1">filename</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">reset_lineno</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack </span><span class="s3">= [</span><span class="s1">dict</span><span class="s3">()]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_last_yielded_token </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cparser</span><span class="s3">.</span><span class="s1">parse</span><span class="s3">(</span>
                <span class="s1">input</span><span class="s3">=</span><span class="s1">text</span><span class="s3">,</span>
                <span class="s1">lexer</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">,</span>
                <span class="s1">debug</span><span class="s3">=</span><span class="s1">debug</span><span class="s3">)</span>

    <span class="s0">######################--   PRIVATE   --######################</span>

    <span class="s2">def </span><span class="s1">_push_scope</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">_pop_scope</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">) &gt; </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_add_typedef_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Add a new typedef name (ie a TYPEID) to the current scope 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s2">True</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span>
                <span class="s4">&quot;Typedef %r previously declared as non-typedef &quot;</span>
                <span class="s4">&quot;in this scope&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">][</span><span class="s1">name</span><span class="s3">] = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_add_identifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Add a new object, function, or enum member name (ie an ID) to the 
            current scope 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span>
                <span class="s4">&quot;Non-typedef %r previously declared as typedef &quot;</span>
                <span class="s4">&quot;in this scope&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">][</span><span class="s1">name</span><span class="s3">] = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_is_type_in_scope</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Is *name* a typedef-name in the current scope? 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">scope </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_scope_stack</span><span class="s3">):</span>
            <span class="s0"># If name is an identifier in this scope it shadows typedefs in</span>
            <span class="s0"># higher scopes.</span>
            <span class="s1">in_scope </span><span class="s3">= </span><span class="s1">scope</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">in_scope </span><span class="s2">is not None</span><span class="s3">: </span><span class="s2">return </span><span class="s1">in_scope</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_lex_error_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">column</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_coord</span><span class="s3">(</span><span class="s1">line</span><span class="s3">, </span><span class="s1">column</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_lex_on_lbrace_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_push_scope</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_lex_on_rbrace_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pop_scope</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_lex_type_lookup_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Looks up types that were previously defined with 
            typedef. 
            Passed to the lexer for recognizing identifiers that 
            are types. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_type_in_scope</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">is_type</span>

    <span class="s2">def </span><span class="s1">_get_yacc_lookahead_token</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; We need access to yacc's lookahead token in certain cases. 
            This is the last token yacc requested from the lexer, so we 
            ask the lexer. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">last_token</span>

    <span class="s0"># To understand what's going on here, read sections A.8.5 and</span>
    <span class="s0"># A.8.6 of K&amp;R2 very carefully.</span>
    <span class="s0">#</span>
    <span class="s0"># A C type consists of a basic type declaration, with a list</span>
    <span class="s0"># of modifiers. For example:</span>
    <span class="s0">#</span>
    <span class="s0"># int *c[5];</span>
    <span class="s0">#</span>
    <span class="s0"># The basic declaration here is 'int c', and the pointer and</span>
    <span class="s0"># the array are the modifiers.</span>
    <span class="s0">#</span>
    <span class="s0"># Basic declarations are represented by TypeDecl (from module c_ast) and the</span>
    <span class="s0"># modifiers are FuncDecl, PtrDecl and ArrayDecl.</span>
    <span class="s0">#</span>
    <span class="s0"># The standard states that whenever a new modifier is parsed, it should be</span>
    <span class="s0"># added to the end of the list of modifiers. For example:</span>
    <span class="s0">#</span>
    <span class="s0"># K&amp;R2 A.8.6.2: Array Declarators</span>
    <span class="s0">#</span>
    <span class="s0"># In a declaration T D where D has the form</span>
    <span class="s0">#   D1 [constant-expression-opt]</span>
    <span class="s0"># and the type of the identifier in the declaration T D1 is</span>
    <span class="s0"># &quot;type-modifier T&quot;, the type of the</span>
    <span class="s0"># identifier of D is &quot;type-modifier array of T&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># This is what this method does. The declarator it receives</span>
    <span class="s0"># can be a list of declarators ending with TypeDecl. It</span>
    <span class="s0"># tacks the modifier to the end of this list, just before</span>
    <span class="s0"># the TypeDecl.</span>
    <span class="s0">#</span>
    <span class="s0"># Additionally, the modifier may be a list itself. This is</span>
    <span class="s0"># useful for pointers, that can come as a chain from the rule</span>
    <span class="s0"># p_pointer. In this case, the whole modifier list is spliced</span>
    <span class="s0"># into the new location.</span>
    <span class="s2">def </span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">, </span><span class="s1">modifier</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Tacks a type modifier on a declarator, and returns 
            the modified declarator. 
 
            Note: the declarator and modifier may be modified 
        &quot;&quot;&quot;</span>
        <span class="s0">#~ print '****'</span>
        <span class="s0">#~ decl.show(offset=3)</span>
        <span class="s0">#~ modifier.show(offset=3)</span>
        <span class="s0">#~ print '****'</span>

        <span class="s1">modifier_head </span><span class="s3">= </span><span class="s1">modifier</span>
        <span class="s1">modifier_tail </span><span class="s3">= </span><span class="s1">modifier</span>

        <span class="s0"># The modifier may be a nested list. Reach its tail.</span>
        <span class="s2">while </span><span class="s1">modifier_tail</span><span class="s3">.</span><span class="s1">type</span><span class="s3">:</span>
            <span class="s1">modifier_tail </span><span class="s3">= </span><span class="s1">modifier_tail</span><span class="s3">.</span><span class="s1">type</span>

        <span class="s0"># If the decl is a basic type, just tack the modifier onto it.</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">):</span>
            <span class="s1">modifier_tail</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">decl</span>
            <span class="s2">return </span><span class="s1">modifier</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Otherwise, the decl is a list of modifiers. Reach</span>
            <span class="s0"># its tail and splice the modifier onto the tail,</span>
            <span class="s0"># pointing to the underlying basic type.</span>
            <span class="s1">decl_tail </span><span class="s3">= </span><span class="s1">decl</span>

            <span class="s2">while not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decl_tail</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">):</span>
                <span class="s1">decl_tail </span><span class="s3">= </span><span class="s1">decl_tail</span><span class="s3">.</span><span class="s1">type</span>

            <span class="s1">modifier_tail</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">decl_tail</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s1">decl_tail</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">modifier_head</span>
            <span class="s2">return </span><span class="s1">decl</span>

    <span class="s0"># Due to the order in which declarators are constructed,</span>
    <span class="s0"># they have to be fixed in order to look like a normal AST.</span>
    <span class="s0">#</span>
    <span class="s0"># When a declaration arrives from syntax construction, it has</span>
    <span class="s0"># these problems:</span>
    <span class="s0"># * The innermost TypeDecl has no type (because the basic</span>
    <span class="s0">#   type is only known at the uppermost declaration level)</span>
    <span class="s0"># * The declaration has no variable name, since that is saved</span>
    <span class="s0">#   in the innermost TypeDecl</span>
    <span class="s0"># * The typename of the declaration is a list of type</span>
    <span class="s0">#   specifiers, and not a node. Here, basic identifier types</span>
    <span class="s0">#   should be separated from more complex types like enums</span>
    <span class="s0">#   and structs.</span>
    <span class="s0">#</span>
    <span class="s0"># This method fixes these problems.</span>
    <span class="s2">def </span><span class="s1">_fix_decl_name_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Fixes a declaration. Modifies decl. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Reach the underlying basic type</span>
        <span class="s0">#</span>
        <span class="s1">type </span><span class="s3">= </span><span class="s1">decl</span>
        <span class="s2">while not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">):</span>
            <span class="s1">type </span><span class="s3">= </span><span class="s1">type</span><span class="s3">.</span><span class="s1">type</span>

        <span class="s1">decl</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">type</span><span class="s3">.</span><span class="s1">declname</span>
        <span class="s1">type</span><span class="s3">.</span><span class="s1">quals </span><span class="s3">= </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">quals</span><span class="s3">[:]</span>

        <span class="s0"># The typename is a list of types. If any type in this</span>
        <span class="s0"># list isn't an IdentifierType, it must be the only</span>
        <span class="s0"># type in the list (it's illegal to declare &quot;int enum ..&quot;)</span>
        <span class="s0"># If all the types are basic, they're collected in the</span>
        <span class="s0"># IdentifierType holder.</span>
        <span class="s2">for </span><span class="s1">tn </span><span class="s2">in </span><span class="s1">typename</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tn</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">typename</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span>
                        <span class="s4">&quot;Invalid multiple types specified&quot;</span><span class="s3">, </span><span class="s1">tn</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">type</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">tn</span>
                    <span class="s2">return </span><span class="s1">decl</span>

        <span class="s2">if not </span><span class="s1">typename</span><span class="s3">:</span>
            <span class="s0"># Functions default to returning int</span>
            <span class="s0">#</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncDecl</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span>
                        <span class="s4">&quot;Missing type in declaration&quot;</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>
            <span class="s1">type</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">(</span>
                    <span class="s3">[</span><span class="s4">'int'</span><span class="s3">],</span>
                    <span class="s1">coord</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># At this point, we know that typename is a list of IdentifierType</span>
            <span class="s0"># nodes. Concatenate all the names into a single list.</span>
            <span class="s0">#</span>
            <span class="s1">type</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">(</span>
                <span class="s3">[</span><span class="s1">name </span><span class="s2">for </span><span class="s1">id </span><span class="s2">in </span><span class="s1">typename </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">id</span><span class="s3">.</span><span class="s1">names</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">typename</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">decl</span>

    <span class="s2">def </span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">declspec</span><span class="s3">, </span><span class="s1">newspec</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Declaration specifiers are represented by a dictionary 
            with the entries: 
            * qual: a list of type qualifiers 
            * storage: a list of storage type qualifiers 
            * type: a list of type specifiers 
            * function: a list of function specifiers 
            * alignment: a list of alignment specifiers 
 
            This method is given a declaration specifier, and a 
            new specifier of a given kind. 
            If `append` is True, the new specifier is added to the end of 
            the specifiers list, otherwise it's added at the beginning. 
            Returns the declaration specifier, with the new 
            specifier incorporated. 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">declspec </span><span class="s2">or </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">qual</span><span class="s3">=[], </span><span class="s1">storage</span><span class="s3">=[], </span><span class="s1">type</span><span class="s3">=[], </span><span class="s1">function</span><span class="s3">=[], </span><span class="s1">alignment</span><span class="s3">=[])</span>

        <span class="s2">if </span><span class="s1">append</span><span class="s3">:</span>
            <span class="s1">spec</span><span class="s3">[</span><span class="s1">kind</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">newspec</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">spec</span><span class="s3">[</span><span class="s1">kind</span><span class="s3">].</span><span class="s1">insert</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">newspec</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">spec</span>

    <span class="s2">def </span><span class="s1">_build_declarations</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">spec</span><span class="s3">, </span><span class="s1">decls</span><span class="s3">, </span><span class="s1">typedef_namespace</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Builds a list of declarations all sharing the given specifiers. 
            If typedef_namespace is true, each declared name is added 
            to the &quot;typedef namespace&quot;, which also includes objects, 
            functions, and enum constants. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_typedef </span><span class="s3">= </span><span class="s4">'typedef' </span><span class="s2">in </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">]</span>
        <span class="s1">declarations </span><span class="s3">= []</span>

        <span class="s0"># Bit-fields are allowed to be unnamed.</span>
        <span class="s2">if </span><span class="s1">decls</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'bitsize'</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">pass</span>

        <span class="s0"># When redeclaring typedef names as identifiers in inner scopes, a</span>
        <span class="s0"># problem can occur where the identifier gets grouped into</span>
        <span class="s0"># spec['type'], leaving decl as None.  This can only occur for the</span>
        <span class="s0"># first declarator.</span>
        <span class="s2">elif </span><span class="s1">decls</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'decl'</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]) &lt; </span><span class="s6">2 </span><span class="s2">or </span><span class="s1">len</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">) != </span><span class="s6">1 </span><span class="s2">or </span><span class="s1">\</span>
                    <span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_is_type_in_scope</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]):</span>
                <span class="s1">coord </span><span class="s3">= </span><span class="s4">'?'</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]:</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s4">'coord'</span><span class="s3">):</span>
                        <span class="s1">coord </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">coord</span>
                        <span class="s2">break</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span><span class="s4">'Invalid declaration'</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">)</span>

            <span class="s0"># Make this look as if it came from &quot;direct_declarator:ID&quot;</span>
            <span class="s1">decls</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'decl'</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span>
                <span class="s1">declname</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">quals</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">align</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'alignment'</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
            <span class="s0"># Remove the &quot;new&quot; type's name from the end of spec['type']</span>
            <span class="s2">del </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s0"># A similar problem can occur where the declaration ends up looking</span>
        <span class="s0"># like an abstract declarator.  Give it a name if this is the case.</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decls</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'decl'</span><span class="s3">], (</span>
                <span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Struct</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Union</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">)):</span>
            <span class="s1">decls_0_tail </span><span class="s3">= </span><span class="s1">decls</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'decl'</span><span class="s3">]</span>
            <span class="s2">while not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">decls_0_tail</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">):</span>
                <span class="s1">decls_0_tail </span><span class="s3">= </span><span class="s1">decls_0_tail</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s2">if </span><span class="s1">decls_0_tail</span><span class="s3">.</span><span class="s1">declname </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">decls_0_tail</span><span class="s3">.</span><span class="s1">declname </span><span class="s3">= </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                <span class="s2">del </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">for </span><span class="s1">decl </span><span class="s2">in </span><span class="s1">decls</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">decl</span><span class="s3">[</span><span class="s4">'decl'</span><span class="s3">] </span><span class="s2">is not None</span>
            <span class="s2">if </span><span class="s1">is_typedef</span><span class="s3">:</span>
                <span class="s1">declaration </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Typedef</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">quals</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'qual'</span><span class="s3">],</span>
                    <span class="s1">storage</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">],</span>
                    <span class="s1">type</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">[</span><span class="s4">'decl'</span><span class="s3">],</span>
                    <span class="s1">coord</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">[</span><span class="s4">'decl'</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">declaration </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Decl</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">quals</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'qual'</span><span class="s3">],</span>
                    <span class="s1">align</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'alignment'</span><span class="s3">],</span>
                    <span class="s1">storage</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">],</span>
                    <span class="s1">funcspec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'function'</span><span class="s3">],</span>
                    <span class="s1">type</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">[</span><span class="s4">'decl'</span><span class="s3">],</span>
                    <span class="s1">init</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'init'</span><span class="s3">),</span>
                    <span class="s1">bitsize</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'bitsize'</span><span class="s3">),</span>
                    <span class="s1">coord</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">[</span><span class="s4">'decl'</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">declaration</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, (</span>
                    <span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Struct</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Union</span><span class="s3">,</span>
                    <span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">)):</span>
                <span class="s1">fixed_decl </span><span class="s3">= </span><span class="s1">declaration</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">fixed_decl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_decl_name_type</span><span class="s3">(</span><span class="s1">declaration</span><span class="s3">, </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">])</span>

            <span class="s0"># Add the type name defined by typedef to a</span>
            <span class="s0"># symbol table (for usage in the lexer)</span>
            <span class="s2">if </span><span class="s1">typedef_namespace</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">is_typedef</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_typedef_name</span><span class="s3">(</span><span class="s1">fixed_decl</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">fixed_decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_identifier</span><span class="s3">(</span><span class="s1">fixed_decl</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">fixed_decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>

            <span class="s1">fixed_decl </span><span class="s3">= </span><span class="s1">fix_atomic_specifiers</span><span class="s3">(</span><span class="s1">fixed_decl</span><span class="s3">)</span>
            <span class="s1">declarations</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">fixed_decl</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">declarations</span>

    <span class="s2">def </span><span class="s1">_build_function_definition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">spec</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">, </span><span class="s1">param_decls</span><span class="s3">, </span><span class="s1">body</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Builds a function definition. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">'typedef' </span><span class="s2">in </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">]:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span><span class="s4">&quot;Invalid typedef&quot;</span><span class="s3">, </span><span class="s1">decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">declaration </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
            <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">, </span><span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)],</span>
            <span class="s1">typedef_namespace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncDef</span><span class="s3">(</span>
            <span class="s1">decl</span><span class="s3">=</span><span class="s1">declaration</span><span class="s3">,</span>
            <span class="s1">param_decls</span><span class="s3">=</span><span class="s1">param_decls</span><span class="s3">,</span>
            <span class="s1">body</span><span class="s3">=</span><span class="s1">body</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">decl</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_select_struct_union_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">token</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; Given a token (either STRUCT or UNION), selects the 
            appropriate AST class. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">token </span><span class="s3">== </span><span class="s4">'struct'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Struct</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Union</span>

    <span class="s0">##</span>
    <span class="s0">## Precedence and associativity of operators</span>
    <span class="s0">##</span>
    <span class="s0"># If this changes, c_generator.CGenerator.precedence_map needs to change as</span>
    <span class="s0"># well</span>
    <span class="s1">precedence </span><span class="s3">= (</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'LOR'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'LAND'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'OR'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'XOR'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'AND'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'EQ'</span><span class="s3">, </span><span class="s4">'NE'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'GT'</span><span class="s3">, </span><span class="s4">'GE'</span><span class="s3">, </span><span class="s4">'LT'</span><span class="s3">, </span><span class="s4">'LE'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'RSHIFT'</span><span class="s3">, </span><span class="s4">'LSHIFT'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'PLUS'</span><span class="s3">, </span><span class="s4">'MINUS'</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'TIMES'</span><span class="s3">, </span><span class="s4">'DIVIDE'</span><span class="s3">, </span><span class="s4">'MOD'</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s0">##</span>
    <span class="s0">## Grammar productions</span>
    <span class="s0">## Implementation of the BNF defined in K&amp;R2 A.13</span>
    <span class="s0">##</span>

    <span class="s0"># Wrapper around a translation unit, to allow for empty input.</span>
    <span class="s0"># Not strictly part of the C99 Grammar, but useful in practice.</span>
    <span class="s2">def </span><span class="s1">p_translation_unit_or_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; translation_unit_or_empty   : translation_unit 
                                        | empty 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FileAST</span><span class="s3">([])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FileAST</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_translation_unit_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; translation_unit    : external_declaration 
        &quot;&quot;&quot;</span>
        <span class="s0"># Note: external_declaration is already a list</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_translation_unit_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; translation_unit    : translation_unit external_declaration 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">])</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># Declarations always come as lists (because they can be</span>
    <span class="s0"># several in one line), so we wrap the function definition</span>
    <span class="s0"># into a list as well, to make the return value of</span>
    <span class="s0"># external_declaration homogeneous.</span>
    <span class="s2">def </span><span class="s1">p_external_declaration_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; external_declaration    : function_definition 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_external_declaration_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; external_declaration    : declaration 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_external_declaration_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; external_declaration    : pp_directive 
                                    | pppragma_directive 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_external_declaration_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; external_declaration    : SEMI 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = []</span>

    <span class="s2">def </span><span class="s1">p_external_declaration_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; external_declaration    : static_assert 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_static_assert_declaration</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; static_assert           : _STATIC_ASSERT LPAREN constant_expression COMMA unified_string_literal RPAREN 
                                    | _STATIC_ASSERT LPAREN constant_expression RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">5</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">StaticAssert</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s2">None</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">StaticAssert</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">p_pp_directive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; pp_directive  : PPHASH 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span><span class="s4">'Directives not supported yet'</span><span class="s3">,</span>
                          <span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_pppragma_directive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; pppragma_directive      : PPPRAGMA 
                                    | PPPRAGMA PPPRAGMASTR 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Pragma</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Pragma</span><span class="s3">(</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s0"># In function definitions, the declarator can be followed by</span>
    <span class="s0"># a declaration list, for old &quot;K&amp;R style&quot; function definitios.</span>
    <span class="s2">def </span><span class="s1">p_function_definition_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; function_definition : id_declarator declaration_list_opt compound_statement 
        &quot;&quot;&quot;</span>
        <span class="s0"># no declaration specifiers - 'int' becomes the default type</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span>
            <span class="s1">qual</span><span class="s3">=[],</span>
            <span class="s1">alignment</span><span class="s3">=[],</span>
            <span class="s1">storage</span><span class="s3">=[],</span>
            <span class="s1">type</span><span class="s3">=[</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">([</span><span class="s4">'int'</span><span class="s3">],</span>
                                       <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))],</span>
            <span class="s1">function</span><span class="s3">=[])</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_function_definition</span><span class="s3">(</span>
            <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">],</span>
            <span class="s1">param_decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">body</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_function_definition_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; function_definition : declaration_specifiers id_declarator declaration_list_opt compound_statement 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_function_definition</span><span class="s3">(</span>
            <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">param_decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">body</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">])</span>

    <span class="s0"># Note, according to C18 A.2.2 6.7.10 static_assert-declaration _Static_assert</span>
    <span class="s0"># is a declaration, not a statement. We additionally recognise it as a statement</span>
    <span class="s0"># to fix parsing of _Static_assert inside the functions.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_statement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; statement   : labeled_statement 
                        | expression_statement 
                        | compound_statement 
                        | selection_statement 
                        | iteration_statement 
                        | jump_statement 
                        | pppragma_directive 
                        | static_assert 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># A pragma is generally considered a decorator rather than an actual</span>
    <span class="s0"># statement. Still, for the purposes of analyzing an abstract syntax tree of</span>
    <span class="s0"># C code, pragma's should not be ignored and were previously treated as a</span>
    <span class="s0"># statement. This presents a problem for constructs that take a statement</span>
    <span class="s0"># such as labeled_statements, selection_statements, and</span>
    <span class="s0"># iteration_statements, causing a misleading structure in the AST. For</span>
    <span class="s0"># example, consider the following C code.</span>
    <span class="s0">#</span>
    <span class="s0">#   for (int i = 0; i &lt; 3; i++)</span>
    <span class="s0">#       #pragma omp critical</span>
    <span class="s0">#       sum += 1;</span>
    <span class="s0">#</span>
    <span class="s0"># This code will compile and execute &quot;sum += 1;&quot; as the body of the for</span>
    <span class="s0"># loop. Previous implementations of PyCParser would render the AST for this</span>
    <span class="s0"># block of code as follows:</span>
    <span class="s0">#</span>
    <span class="s0">#   For:</span>
    <span class="s0">#     DeclList:</span>
    <span class="s0">#       Decl: i, [], [], []</span>
    <span class="s0">#         TypeDecl: i, []</span>
    <span class="s0">#           IdentifierType: ['int']</span>
    <span class="s0">#         Constant: int, 0</span>
    <span class="s0">#     BinaryOp: &lt;</span>
    <span class="s0">#       ID: i</span>
    <span class="s0">#       Constant: int, 3</span>
    <span class="s0">#     UnaryOp: p++</span>
    <span class="s0">#       ID: i</span>
    <span class="s0">#     Pragma: omp critical</span>
    <span class="s0">#   Assignment: +=</span>
    <span class="s0">#     ID: sum</span>
    <span class="s0">#     Constant: int, 1</span>
    <span class="s0">#</span>
    <span class="s0"># This AST misleadingly takes the Pragma as the body of the loop and the</span>
    <span class="s0"># assignment then becomes a sibling of the loop.</span>
    <span class="s0">#</span>
    <span class="s0"># To solve edge cases like these, the pragmacomp_or_statement rule groups</span>
    <span class="s0"># a pragma and its following statement (which would otherwise be orphaned)</span>
    <span class="s0"># using a compound block, effectively turning the above code into:</span>
    <span class="s0">#</span>
    <span class="s0">#   for (int i = 0; i &lt; 3; i++) {</span>
    <span class="s0">#       #pragma omp critical</span>
    <span class="s0">#       sum += 1;</span>
    <span class="s0">#   }</span>
    <span class="s2">def </span><span class="s1">p_pragmacomp_or_statement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; pragmacomp_or_statement     : pppragma_directive statement 
                                        | statement 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Pragma</span><span class="s3">) </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Compound</span><span class="s3">(</span>
                <span class="s1">block_items</span><span class="s3">=[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># In C, declarations can come several in a line:</span>
    <span class="s0">#   int x, *px, romulo = 5;</span>
    <span class="s0">#</span>
    <span class="s0"># However, for the AST, we will split them to separate Decl</span>
    <span class="s0"># nodes.</span>
    <span class="s0">#</span>
    <span class="s0"># This rule splits its declarations and always returns a list</span>
    <span class="s0"># of Decl nodes, even if it's one element long.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_decl_body</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; decl_body : declaration_specifiers init_declarator_list_opt 
                      | declaration_specifiers_no_type id_init_declarator_list_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s0"># p[2] (init_declarator_list_opt) is either a list or None</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># By the standard, you must have at least one declarator unless</span>
            <span class="s0"># declaring a structure tag, a union tag, or the members of an</span>
            <span class="s0"># enumeration.</span>
            <span class="s0">#</span>
            <span class="s1">ty </span><span class="s3">= </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]</span>
            <span class="s1">s_u_or_e </span><span class="s3">= (</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Struct</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Union</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">s_u_or_e</span><span class="s3">):</span>
                <span class="s1">decls </span><span class="s3">= [</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Decl</span><span class="s3">(</span>
                    <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">quals</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'qual'</span><span class="s3">],</span>
                    <span class="s1">align</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'alignment'</span><span class="s3">],</span>
                    <span class="s1">storage</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">],</span>
                    <span class="s1">funcspec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'function'</span><span class="s3">],</span>
                    <span class="s1">type</span><span class="s3">=</span><span class="s1">ty</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                    <span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">bitsize</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">coord</span><span class="s3">=</span><span class="s1">ty</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)]</span>

            <span class="s0"># However, this case can also occur on redeclared identifiers in</span>
            <span class="s0"># an inner scope.  The trouble is that the redeclared type's name</span>
            <span class="s0"># gets grouped into declaration_specifiers; _build_declarations</span>
            <span class="s0"># compensates for this.</span>
            <span class="s0">#</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">decls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                    <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                    <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)],</span>
                    <span class="s1">typedef_namespace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">decls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
                <span class="s1">typedef_namespace</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">decls</span>

    <span class="s0"># The declaration has been split to a decl_body sub-rule and</span>
    <span class="s0"># SEMI, because having them in a single rule created a problem</span>
    <span class="s0"># for defining typedefs.</span>
    <span class="s0">#</span>
    <span class="s0"># If a typedef line was directly followed by a line using the</span>
    <span class="s0"># type defined with the typedef, the type would not be</span>
    <span class="s0"># recognized. This is because to reduce the declaration rule,</span>
    <span class="s0"># the parser's lookahead asked for the token after SEMI, which</span>
    <span class="s0"># was the type from the next line, and the lexer had no chance</span>
    <span class="s0"># to see the updated type symbol table.</span>
    <span class="s0">#</span>
    <span class="s0"># Splitting solves this problem, because after seeing SEMI,</span>
    <span class="s0"># the parser reduces decl_body, which actually adds the new</span>
    <span class="s0"># type into the table to be seen by the lexer before the next</span>
    <span class="s0"># line is reached.</span>
    <span class="s2">def </span><span class="s1">p_declaration</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration : decl_body SEMI 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># Since each declaration is a list of declarations, this</span>
    <span class="s0"># rule will combine all the declarations and return a single</span>
    <span class="s0"># list</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_declaration_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_list    : declaration 
                                | declaration_list declaration 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s0"># To know when declaration-specifiers end and declarators begin,</span>
    <span class="s0"># we require declaration-specifiers to have at least one</span>
    <span class="s0"># type-specifier, and disallow typedef-names after we've seen any</span>
    <span class="s0"># type-specifier. These are both required by the spec.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_declaration_specifiers_no_type_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers_no_type  : type_qualifier declaration_specifiers_no_type_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'qual'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_no_type_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers_no_type  : storage_class_specifier declaration_specifiers_no_type_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'storage'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_no_type_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers_no_type  : function_specifier declaration_specifiers_no_type_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'function'</span><span class="s3">)</span>

    <span class="s0"># Without this, `typedef _Atomic(T) U` will parse incorrectly because the</span>
    <span class="s0"># _Atomic qualifier will match, instead of the specifier.</span>
    <span class="s2">def </span><span class="s1">p_declaration_specifiers_no_type_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers_no_type  : atomic_specifier declaration_specifiers_no_type_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_no_type_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers_no_type  : alignment_specifier declaration_specifiers_no_type_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'alignment'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers type_qualifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'qual'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers storage_class_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'storage'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers function_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'function'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers type_specifier_no_typeid 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : type_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers_no_type type_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_declaration_specifiers_7</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declaration_specifiers  : declaration_specifiers alignment_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'alignment'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_storage_class_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; storage_class_specifier : AUTO 
                                    | REGISTER 
                                    | STATIC 
                                    | EXTERN 
                                    | TYPEDEF 
                                    | _THREAD_LOCAL 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_function_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; function_specifier  : INLINE 
                                | _NORETURN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_type_specifier_no_typeid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; type_specifier_no_typeid  : VOID 
                                      | _BOOL 
                                      | CHAR 
                                      | SHORT 
                                      | INT 
                                      | LONG 
                                      | FLOAT 
                                      | DOUBLE 
                                      | _COMPLEX 
                                      | SIGNED 
                                      | UNSIGNED 
                                      | __INT128 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_type_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; type_specifier  : typedef_name 
                            | enum_specifier 
                            | struct_or_union_specifier 
                            | type_specifier_no_typeid 
                            | atomic_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># See section 6.7.2.4 of the C11 standard.</span>
    <span class="s2">def </span><span class="s1">p_atomic_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; atomic_specifier  : _ATOMIC LPAREN type_name RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">typ </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]</span>
        <span class="s1">typ</span><span class="s3">.</span><span class="s1">quals</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'_Atomic'</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">typ</span>

    <span class="s2">def </span><span class="s1">p_type_qualifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; type_qualifier  : CONST 
                            | RESTRICT 
                            | VOLATILE 
                            | _ATOMIC 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_init_declarator_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; init_declarator_list    : init_declarator 
                                    | init_declarator_list COMMA init_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4 </span><span class="s2">else </span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s0"># Returns a {decl=&lt;declarator&gt; : init=&lt;initializer&gt;} dictionary</span>
    <span class="s0"># If there's no initializer, uses None</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_init_declarator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; init_declarator : declarator 
                            | declarator EQUALS initializer 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">init</span><span class="s3">=(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">2 </span><span class="s2">else None</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_id_init_declarator_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; id_init_declarator_list    : id_init_declarator 
                                       | id_init_declarator_list COMMA init_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4 </span><span class="s2">else </span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_id_init_declarator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; id_init_declarator : id_declarator 
                               | id_declarator EQUALS initializer 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">init</span><span class="s3">=(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">2 </span><span class="s2">else None</span><span class="s3">))</span>

    <span class="s0"># Require at least one type specifier in a specifier-qualifier-list</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list    : specifier_qualifier_list type_specifier_no_typeid 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list    : specifier_qualifier_list type_qualifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'qual'</span><span class="s3">, </span><span class="s1">append</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list  : type_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'type'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list  : type_qualifier_list type_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">qual</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">alignment</span><span class="s3">=[], </span><span class="s1">storage</span><span class="s3">=[], </span><span class="s1">type</span><span class="s3">=[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]], </span><span class="s1">function</span><span class="s3">=[])</span>

    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list  : alignment_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">qual</span><span class="s3">=[], </span><span class="s1">alignment</span><span class="s3">=[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">storage</span><span class="s3">=[], </span><span class="s1">type</span><span class="s3">=[], </span><span class="s1">function</span><span class="s3">=[])</span>

    <span class="s2">def </span><span class="s1">p_specifier_qualifier_list_6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; specifier_qualifier_list  : specifier_qualifier_list alignment_specifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_declaration_specifier</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s4">'alignment'</span><span class="s3">)</span>

    <span class="s0"># TYPEID is allowed here (and in other struct/enum related tag names), because</span>
    <span class="s0"># struct/enum tags reside in their own namespace and can be named the same as types</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_struct_or_union_specifier_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_or_union_specifier   : struct_or_union ID 
                                        | struct_or_union TYPEID 
        &quot;&quot;&quot;</span>
        <span class="s1">klass </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_select_struct_union_class</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s0"># None means no list of members</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">klass</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">decls</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_struct_or_union_specifier_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_or_union_specifier : struct_or_union brace_open struct_declaration_list brace_close 
                                      | struct_or_union brace_open brace_close 
        &quot;&quot;&quot;</span>
        <span class="s1">klass </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_select_struct_union_class</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4</span><span class="s3">:</span>
            <span class="s0"># Empty sequence means an empty list of members</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">klass</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=[],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">klass</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>


    <span class="s2">def </span><span class="s1">p_struct_or_union_specifier_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_or_union_specifier   : struct_or_union ID brace_open struct_declaration_list brace_close 
                                        | struct_or_union ID brace_open brace_close 
                                        | struct_or_union TYPEID brace_open struct_declaration_list brace_close 
                                        | struct_or_union TYPEID brace_open brace_close 
        &quot;&quot;&quot;</span>
        <span class="s1">klass </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_select_struct_union_class</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">5</span><span class="s3">:</span>
            <span class="s0"># Empty sequence means an empty list of members</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">klass</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
                <span class="s1">decls</span><span class="s3">=[],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">klass</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
                <span class="s1">decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_struct_or_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_or_union : STRUCT 
                            | UNION 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># Combine all declarations into a single list</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_struct_declaration_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declaration_list     : struct_declaration 
                                        | struct_declaration_list struct_declaration 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">or </span><span class="s3">[]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + (</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">or </span><span class="s3">[])</span>

    <span class="s2">def </span><span class="s1">p_struct_declaration_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declaration : specifier_qualifier_list struct_declarator_list_opt SEMI 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s4">'typedef' </span><span class="s2">not in </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'storage'</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">decls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">])</span>

        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]) == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s0"># Anonymous struct/union, gcc extension, C1x feature.</span>
            <span class="s0"># Although the standard only allows structs/unions here, I see no</span>
            <span class="s0"># reason to disallow other types since some compilers have typedefs</span>
            <span class="s0"># here, and pycparser isn't about rejecting all invalid code.</span>
            <span class="s0">#</span>
            <span class="s1">node </span><span class="s3">= </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">node</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Node</span><span class="s3">):</span>
                <span class="s1">decl_type </span><span class="s3">= </span><span class="s1">node</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">decl_type </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">(</span><span class="s1">node</span><span class="s3">)</span>

            <span class="s1">decls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">decl_type</span><span class="s3">)])</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Structure/union members can have the same names as typedefs.</span>
            <span class="s0"># The trouble is that the member's name gets grouped into</span>
            <span class="s0"># specifier_qualifier_list; _build_declarations compensates.</span>
            <span class="s0">#</span>
            <span class="s1">decls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)])</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">decls</span>

    <span class="s2">def </span><span class="s1">p_struct_declaration_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declaration : SEMI 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">p_struct_declaration_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declaration : pppragma_directive 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_struct_declarator_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declarator_list  : struct_declarator 
                                    | struct_declarator_list COMMA struct_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4 </span><span class="s2">else </span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s0"># struct_declarator passes up a dict with the keys: decl (for</span>
    <span class="s0"># the underlying declarator) and bitsize (for the bitsize)</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_struct_declarator_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declarator : declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = {</span><span class="s4">'decl'</span><span class="s3">: </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'bitsize'</span><span class="s3">: </span><span class="s2">None</span><span class="s3">}</span>

    <span class="s2">def </span><span class="s1">p_struct_declarator_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; struct_declarator   : declarator COLON constant_expression 
                                | COLON constant_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = {</span><span class="s4">'decl'</span><span class="s3">: </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s4">'bitsize'</span><span class="s3">: </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]}</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = {</span><span class="s4">'decl'</span><span class="s3">: </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s4">'bitsize'</span><span class="s3">: </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]}</span>

    <span class="s2">def </span><span class="s1">p_enum_specifier_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; enum_specifier  : ENUM ID 
                            | ENUM TYPEID 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s2">None</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_enum_specifier_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; enum_specifier  : ENUM brace_open enumerator_list brace_close 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_enum_specifier_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; enum_specifier  : ENUM ID brace_open enumerator_list brace_close 
                            | ENUM TYPEID brace_open enumerator_list brace_close 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enum</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_enumerator_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; enumerator_list : enumerator 
                            | enumerator_list COMMA 
                            | enumerator_list COMMA enumerator 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">EnumeratorList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">enumerators</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_alignment_specifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; alignment_specifier  : _ALIGNAS LPAREN type_name RPAREN 
                                 | _ALIGNAS LPAREN constant_expression RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Alignas</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_enumerator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; enumerator  : ID 
                        | ID EQUALS constant_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">enumerator </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enumerator</span><span class="s3">(</span>
                        <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">enumerator </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Enumerator</span><span class="s3">(</span>
                        <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_identifier</span><span class="s3">(</span><span class="s1">enumerator</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">enumerator</span>

    <span class="s2">def </span><span class="s1">p_declarator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; declarator  : id_declarator 
                        | typeid_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_xxx_declarator_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; xxx_declarator  : direct_xxx_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_xxx_declarator_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; xxx_declarator  : pointer direct_xxx_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : yyy 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span>
            <span class="s1">declname</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">],</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">quals</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">align</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : LPAREN xxx_declarator RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : direct_xxx_declarator LBRACKET type_qualifier_list_opt assignment_expression_opt RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">quals </span><span class="s3">= (</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">5 </span><span class="s2">else </span><span class="s3">[]) </span><span class="s2">or </span><span class="s3">[]</span>
        <span class="s0"># Accept dimension qualifiers</span>
        <span class="s0"># Per C99 6.7.5.3 p7</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">5 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">dim_quals</span><span class="s3">=</span><span class="s1">quals</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : direct_xxx_declarator LBRACKET STATIC type_qualifier_list_opt assignment_expression RBRACKET 
                                    | direct_xxx_declarator LBRACKET type_qualifier_list STATIC assignment_expression RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s0"># Using slice notation for PLY objects doesn't work in Python 3 for the</span>
        <span class="s0"># version of PLY embedded with pycparser; see PLY Google Code issue 30.</span>
        <span class="s0"># Work around that here by listing the two elements separately.</span>
        <span class="s1">listed_quals </span><span class="s3">= [</span><span class="s1">item </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) </span><span class="s2">else </span><span class="s3">[</span><span class="s1">item</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">]]]</span>
        <span class="s1">dim_quals </span><span class="s3">= [</span><span class="s1">qual </span><span class="s2">for </span><span class="s1">sublist </span><span class="s2">in </span><span class="s1">listed_quals </span><span class="s2">for </span><span class="s1">qual </span><span class="s2">in </span><span class="s1">sublist</span>
            <span class="s2">if </span><span class="s1">qual </span><span class="s2">is not None</span><span class="s3">]</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">],</span>
            <span class="s1">dim_quals</span><span class="s3">=</span><span class="s1">dim_quals</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s0"># Special for VLAs</span>
    <span class="s0">#</span>
    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : direct_xxx_declarator LBRACKET type_qualifier_list_opt TIMES RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">4</span><span class="s3">)),</span>
            <span class="s1">dim_quals</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">is not None else </span><span class="s3">[],</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">parameterized</span><span class="s3">((</span><span class="s4">'id'</span><span class="s3">, </span><span class="s4">'ID'</span><span class="s3">), (</span><span class="s4">'typeid'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">), (</span><span class="s4">'typeid_noparen'</span><span class="s3">, </span><span class="s4">'TYPEID'</span><span class="s3">))</span>
    <span class="s2">def </span><span class="s1">p_direct_xxx_declarator_6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_xxx_declarator   : direct_xxx_declarator LPAREN parameter_type_list RPAREN 
                                    | direct_xxx_declarator LPAREN identifier_list_opt RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncDecl</span><span class="s3">(</span>
            <span class="s1">args</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s0"># To see why _get_yacc_lookahead_token is needed, consider:</span>
        <span class="s0">#   typedef char TT;</span>
        <span class="s0">#   void foo(int TT) { TT = 10; }</span>
        <span class="s0"># Outside the function, TT is a typedef, but inside (starting and</span>
        <span class="s0"># ending with the braces) it's a parameter.  The trouble begins with</span>
        <span class="s0"># yacc's lookahead token.  We don't know if we're declaring or</span>
        <span class="s0"># defining a function until we see LBRACE, but if we wait for yacc to</span>
        <span class="s0"># trigger a rule on that token, then TT will have already been read</span>
        <span class="s0"># and incorrectly interpreted as TYPEID.  We need to add the</span>
        <span class="s0"># parameters to the scope the moment the lexer sees LBRACE.</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_yacc_lookahead_token</span><span class="s3">().</span><span class="s1">type </span><span class="s3">== </span><span class="s4">&quot;LBRACE&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">func</span><span class="s3">.</span><span class="s1">args</span><span class="s3">.</span><span class="s1">params</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">param</span><span class="s3">, </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">EllipsisParam</span><span class="s3">): </span><span class="s2">break</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_identifier</span><span class="s3">(</span><span class="s1">param</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">param</span><span class="s3">.</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">func</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_pointer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; pointer : TIMES type_qualifier_list_opt 
                    | TIMES type_qualifier_list_opt pointer 
        &quot;&quot;&quot;</span>
        <span class="s1">coord </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s0"># Pointer decls nest from inside out. This is important when different</span>
        <span class="s0"># levels have different qualifiers. For example:</span>
        <span class="s0">#</span>
        <span class="s0">#  char * const * p;</span>
        <span class="s0">#</span>
        <span class="s0"># Means &quot;pointer to const pointer to char&quot;</span>
        <span class="s0">#</span>
        <span class="s0"># While:</span>
        <span class="s0">#</span>
        <span class="s0">#  char ** const p;</span>
        <span class="s0">#</span>
        <span class="s0"># Means &quot;const pointer to pointer to char&quot;</span>
        <span class="s0">#</span>
        <span class="s0"># So when we construct PtrDecl nestings, the leftmost pointer goes in</span>
        <span class="s0"># as the most nested type.</span>
        <span class="s1">nested_type </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">PtrDecl</span><span class="s3">(</span><span class="s1">quals</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">or </span><span class="s3">[], </span><span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">=</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">tail_type </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]</span>
            <span class="s2">while </span><span class="s1">tail_type</span><span class="s3">.</span><span class="s1">type </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">tail_type </span><span class="s3">= </span><span class="s1">tail_type</span><span class="s3">.</span><span class="s1">type</span>
            <span class="s1">tail_type</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">nested_type</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">nested_type</span>

    <span class="s2">def </span><span class="s1">p_type_qualifier_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; type_qualifier_list : type_qualifier 
                                | type_qualifier_list type_qualifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_parameter_type_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; parameter_type_list : parameter_list 
                                | parameter_list COMMA ELLIPSIS 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">params</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">EllipsisParam</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)))</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_parameter_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; parameter_list  : parameter_declaration 
                            | parameter_list COMMA parameter_declaration 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">: </span><span class="s0"># single parameter</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ParamList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">params</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># From ISO/IEC 9899:TC2, 6.7.5.3.11:</span>
    <span class="s0"># &quot;If, in a parameter declaration, an identifier can be treated either</span>
    <span class="s0">#  as a typedef name or as a parameter name, it shall be taken as a</span>
    <span class="s0">#  typedef name.&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># Inside a parameter declaration, once we've reduced declaration specifiers,</span>
    <span class="s0"># if we shift in an LPAREN and see a TYPEID, it could be either an abstract</span>
    <span class="s0"># declarator or a declarator nested inside parens. This rule tells us to</span>
    <span class="s0"># always treat it as an abstract declarator. Therefore, we only accept</span>
    <span class="s0"># `id_declarator`s and `typeid_noparen_declarator`s.</span>
    <span class="s2">def </span><span class="s1">p_parameter_declaration_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; parameter_declaration   : declaration_specifiers id_declarator 
                                    | declaration_specifiers typeid_noparen_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]:</span>
            <span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = [</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">([</span><span class="s4">'int'</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))]</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
            <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
            <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">])])[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_parameter_declaration_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; parameter_declaration   : declaration_specifiers abstract_declarator_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]:</span>
            <span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">] = [</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">([</span><span class="s4">'int'</span><span class="s3">],</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))]</span>

        <span class="s0"># Parameters can have the same names as typedefs.  The trouble is that</span>
        <span class="s0"># the parameter's name gets grouped into declaration_specifiers, making</span>
        <span class="s0"># it look like an old-style declaration; compensate.</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]) &gt; </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">) == </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">\</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_is_type_in_scope</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">].</span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]):</span>
            <span class="s1">decl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_build_declarations</span><span class="s3">(</span>
                    <span class="s1">spec</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">,</span>
                    <span class="s1">decls</span><span class="s3">=[</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">init</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)])[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s0"># This truly is an old-style parameter declaration</span>
        <span class="s0">#</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">decl </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Typename</span><span class="s3">(</span>
                <span class="s1">name</span><span class="s3">=</span><span class="s4">''</span><span class="s3">,</span>
                <span class="s1">quals</span><span class="s3">=</span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'qual'</span><span class="s3">],</span>
                <span class="s1">align</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">type</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">or </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
            <span class="s1">typename </span><span class="s3">= </span><span class="s1">spec</span><span class="s3">[</span><span class="s4">'type'</span><span class="s3">]</span>
            <span class="s1">decl </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_decl_name_type</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">, </span><span class="s1">typename</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">decl</span>

    <span class="s2">def </span><span class="s1">p_identifier_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; identifier_list : identifier 
                            | identifier_list COMMA identifier 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">: </span><span class="s0"># single parameter</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ParamList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">params</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_initializer_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; initializer : assignment_expression 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_initializer_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; initializer : brace_open initializer_list_opt brace_close 
                        | brace_open initializer_list COMMA brace_close 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">InitList</span><span class="s3">([], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_initializer_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; initializer_list    : designation_opt initializer 
                                | initializer_list COMMA designation_opt initializer 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">3</span><span class="s3">: </span><span class="s0"># single initializer</span>
            <span class="s1">init </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">is None else </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">NamedInitializer</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">InitList</span><span class="s3">([</span><span class="s1">init</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">init </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">] </span><span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">is None else </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">NamedInitializer</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">exprs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">init</span><span class="s3">)</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_designation</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; designation : designator_list EQUALS 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># Designators are represented as a list of nodes, in the order in which</span>
    <span class="s0"># they're written in the code.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_designator_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; designator_list : designator 
                            | designator_list designator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">p_designator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; designator  : LBRACKET constant_expression RBRACKET 
                        | PERIOD identifier 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_type_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; type_name   : specifier_qualifier_list abstract_declarator_opt 
        &quot;&quot;&quot;</span>
        <span class="s1">typename </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Typename</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">=</span><span class="s4">''</span><span class="s3">,</span>
            <span class="s1">quals</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'qual'</span><span class="s3">][:],</span>
            <span class="s1">align</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">or </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_fix_decl_name_type</span><span class="s3">(</span><span class="s1">typename</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'type'</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_abstract_declarator_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; abstract_declarator     : pointer 
        &quot;&quot;&quot;</span>
        <span class="s1">dummytype </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span>
            <span class="s1">decl</span><span class="s3">=</span><span class="s1">dummytype</span><span class="s3">,</span>
            <span class="s1">modifier</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_abstract_declarator_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; abstract_declarator     : pointer direct_abstract_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_abstract_declarator_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; abstract_declarator     : direct_abstract_declarator 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s0"># Creating and using direct_abstract_declarator_opt here</span>
    <span class="s0"># instead of listing both direct_abstract_declarator and the</span>
    <span class="s0"># lack of it in the beginning of _1 and _2 caused two</span>
    <span class="s0"># shift/reduce errors.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : LPAREN abstract_declarator RPAREN &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : direct_abstract_declarator LBRACKET assignment_expression_opt RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">dim_quals</span><span class="s3">=[],</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : LBRACKET type_qualifier_list_opt assignment_expression_opt RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">quals </span><span class="s3">= (</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">4 </span><span class="s2">else </span><span class="s3">[]) </span><span class="s2">or </span><span class="s3">[]</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &gt; </span><span class="s6">4 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">dim_quals</span><span class="s3">=</span><span class="s1">quals</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : direct_abstract_declarator LBRACKET TIMES RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">arr </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)),</span>
            <span class="s1">dim_quals</span><span class="s3">=[],</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">arr</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : LBRACKET TIMES RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayDecl</span><span class="s3">(</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
            <span class="s1">dim</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)),</span>
            <span class="s1">dim_quals</span><span class="s3">=[],</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : direct_abstract_declarator LPAREN parameter_type_list_opt RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncDecl</span><span class="s3">(</span>
            <span class="s1">args</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_type_modify_decl</span><span class="s3">(</span><span class="s1">decl</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">modifier</span><span class="s3">=</span><span class="s1">func</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_direct_abstract_declarator_7</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; direct_abstract_declarator  : LPAREN parameter_type_list_opt RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncDecl</span><span class="s3">(</span>
            <span class="s1">args</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">type</span><span class="s3">=</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TypeDecl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s0"># declaration is a list, statement isn't. To make it consistent, block_item</span>
    <span class="s0"># will always be a list</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_block_item</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; block_item  : declaration 
                        | statement 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">list</span><span class="s3">) </span><span class="s2">else </span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]]</span>

    <span class="s0"># Since we made block_item a list, this just combines lists</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_block_item_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; block_item_list : block_item 
                            | block_item_list block_item 
        &quot;&quot;&quot;</span>
        <span class="s0"># Empty block items (plain ';') produce [None], so ignore them</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">if </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2 </span><span class="s2">or </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] == [</span><span class="s2">None</span><span class="s3">]) </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_compound_statement_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; compound_statement : brace_open block_item_list_opt brace_close &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Compound</span><span class="s3">(</span>
            <span class="s1">block_items</span><span class="s3">=</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">],</span>
            <span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_labeled_statement_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; labeled_statement : ID COLON pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Label</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_labeled_statement_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; labeled_statement : CASE constant_expression COLON pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Case</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], [</span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">]], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_labeled_statement_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; labeled_statement : DEFAULT COLON pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Default</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">]], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_selection_statement_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; selection_statement : IF LPAREN expression RPAREN pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">If</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s2">None</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_selection_statement_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; selection_statement : IF LPAREN expression RPAREN statement ELSE pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">If</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">7</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_selection_statement_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; selection_statement : SWITCH LPAREN expression RPAREN pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">fix_switch_cases</span><span class="s3">(</span>
                <span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Switch</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">p_iteration_statement_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; iteration_statement : WHILE LPAREN expression RPAREN pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">While</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_iteration_statement_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; iteration_statement : DO pragmacomp_or_statement WHILE LPAREN expression RPAREN SEMI &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">DoWhile</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_iteration_statement_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; iteration_statement : FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">For</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">7</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">9</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_iteration_statement_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; iteration_statement : FOR LPAREN declaration expression_opt SEMI expression_opt RPAREN pragmacomp_or_statement &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">For</span><span class="s3">(</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">DeclList</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)),</span>
                         <span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">6</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">8</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_jump_statement_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; jump_statement  : GOTO ID SEMI &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Goto</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_jump_statement_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; jump_statement  : BREAK SEMI &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Break</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_jump_statement_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; jump_statement  : CONTINUE SEMI &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Continue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_jump_statement_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; jump_statement  : RETURN expression SEMI 
                            | RETURN SEMI 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Return</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4 </span><span class="s2">else None</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_expression_statement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; expression_statement : expression_opt SEMI &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">EmptyStatement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; expression  : assignment_expression 
                        | expression COMMA assignment_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ExprList</span><span class="s3">):</span>
                <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ExprList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">exprs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_parenthesized_compound_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; assignment_expression : LPAREN compound_statement RPAREN &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_typedef_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; typedef_name : TYPEID &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">IdentifierType</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">coord</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_assignment_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; assignment_expression   : conditional_expression 
                                    | unary_expression assignment_operator assignment_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Assignment</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s0"># K&amp;R2 defines these as many separate rules, to encode</span>
    <span class="s0"># precedence and associativity. Why work hard ? I'll just use</span>
    <span class="s0"># the built in precedence/associativity specification feature</span>
    <span class="s0"># of PLY. (see precedence declaration above)</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_assignment_operator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; assignment_operator : EQUALS 
                                | XOREQUAL 
                                | TIMESEQUAL 
                                | DIVEQUAL 
                                | MODEQUAL 
                                | PLUSEQUAL 
                                | MINUSEQUAL 
                                | LSHIFTEQUAL 
                                | RSHIFTEQUAL 
                                | ANDEQUAL 
                                | OREQUAL 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_constant_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; constant_expression : conditional_expression &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_conditional_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; conditional_expression  : binary_expression 
                                    | binary_expression CONDOP expression COLON conditional_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">TernaryOp</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_binary_expression</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; binary_expression   : cast_expression 
                                | binary_expression TIMES binary_expression 
                                | binary_expression DIVIDE binary_expression 
                                | binary_expression MOD binary_expression 
                                | binary_expression PLUS binary_expression 
                                | binary_expression MINUS binary_expression 
                                | binary_expression RSHIFT binary_expression 
                                | binary_expression LSHIFT binary_expression 
                                | binary_expression LT binary_expression 
                                | binary_expression LE binary_expression 
                                | binary_expression GE binary_expression 
                                | binary_expression GT binary_expression 
                                | binary_expression EQ binary_expression 
                                | binary_expression NE binary_expression 
                                | binary_expression AND binary_expression 
                                | binary_expression OR binary_expression 
                                | binary_expression XOR binary_expression 
                                | binary_expression LAND binary_expression 
                                | binary_expression LOR binary_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">BinaryOp</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_cast_expression_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; cast_expression : unary_expression &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_cast_expression_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; cast_expression : LPAREN type_name RPAREN cast_expression &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Cast</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">4</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_unary_expression_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unary_expression    : postfix_expression &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_unary_expression_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unary_expression    : PLUSPLUS unary_expression 
                                | MINUSMINUS unary_expression 
                                | unary_operator cast_expression 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">UnaryOp</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_unary_expression_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unary_expression    : SIZEOF unary_expression 
                                | SIZEOF LPAREN type_name RPAREN 
                                | _ALIGNOF LPAREN type_name RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">UnaryOp</span><span class="s3">(</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">],</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">3 </span><span class="s2">else </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">],</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_unary_operator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unary_operator  : AND 
                            | TIMES 
                            | PLUS 
                            | MINUS 
                            | NOT 
                            | LNOT 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : primary_expression &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : postfix_expression LBRACKET expression RBRACKET &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayRef</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : postfix_expression LPAREN argument_expression_list RPAREN 
                                | postfix_expression LPAREN RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncCall</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">5 </span><span class="s2">else None</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : postfix_expression PERIOD ID 
                                | postfix_expression PERIOD TYPEID 
                                | postfix_expression ARROW ID 
                                | postfix_expression ARROW TYPEID 
        &quot;&quot;&quot;</span>
        <span class="s1">field </span><span class="s3">= </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">StructRef</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">field</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : postfix_expression PLUSPLUS 
                                | postfix_expression MINUSMINUS 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">UnaryOp</span><span class="s3">(</span><span class="s4">'p' </span><span class="s3">+ </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_postfix_expression_6</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; postfix_expression  : LPAREN type_name RPAREN brace_open initializer_list brace_close 
                                | LPAREN type_name RPAREN brace_open initializer_list COMMA brace_close 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">CompoundLiteral</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">p_primary_expression_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; primary_expression  : identifier &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_primary_expression_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; primary_expression  : constant &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_primary_expression_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; primary_expression  : unified_string_literal 
                                | unified_wstring_literal 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_primary_expression_4</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; primary_expression  : LPAREN expression RPAREN &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_primary_expression_5</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; primary_expression  : OFFSETOF LPAREN type_name COMMA offsetof_member_designator RPAREN 
        &quot;&quot;&quot;</span>
        <span class="s1">coord </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">FuncCall</span><span class="s3">(</span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">coord</span><span class="s3">),</span>
                              <span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ExprList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">5</span><span class="s3">]], </span><span class="s1">coord</span><span class="s3">),</span>
                              <span class="s1">coord</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">p_offsetof_member_designator</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; offsetof_member_designator : identifier 
                                         | offsetof_member_designator PERIOD identifier 
                                         | offsetof_member_designator LBRACKET expression RBRACKET 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">4</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">StructRef</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">5</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ArrayRef</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;Unexpected parsing state. len(p): %u&quot; </span><span class="s3">% </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_argument_expression_list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; argument_expression_list    : assignment_expression 
                                        | argument_expression_list COMMA assignment_expression 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">: </span><span class="s0"># single expr</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ExprList</span><span class="s3">([</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]], </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">coord</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">exprs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">3</span><span class="s3">])</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_identifier</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; identifier  : ID &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">ID</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_constant_1</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; constant    : INT_CONST_DEC 
                        | INT_CONST_OCT 
                        | INT_CONST_HEX 
                        | INT_CONST_BIN 
                        | INT_CONST_CHAR 
        &quot;&quot;&quot;</span>
        <span class="s1">uCount </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">lCount </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][-</span><span class="s6">3</span><span class="s3">:]:</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'l'</span><span class="s3">, </span><span class="s4">'L'</span><span class="s3">):</span>
                <span class="s1">lCount </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s2">elif </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'u'</span><span class="s3">, </span><span class="s4">'U'</span><span class="s3">):</span>
                <span class="s1">uCount </span><span class="s3">+= </span><span class="s6">1</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">uCount </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
             <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Constant cannot have more than one u/U suffix.'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">lCount </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
             <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Constant cannot have more than two l/L suffix.'</span><span class="s3">)</span>
        <span class="s1">prefix </span><span class="s3">= </span><span class="s4">'unsigned ' </span><span class="s3">* </span><span class="s1">uCount </span><span class="s3">+ </span><span class="s4">'long ' </span><span class="s3">* </span><span class="s1">lCount</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span>
            <span class="s1">prefix </span><span class="s3">+ </span><span class="s4">'int'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_constant_2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; constant    : FLOAT_CONST 
                        | HEX_FLOAT_CONST 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">'x' </span><span class="s2">in </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">lower</span><span class="s3">():</span>
            <span class="s1">t </span><span class="s3">= </span><span class="s4">'float'</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'f'</span><span class="s3">, </span><span class="s4">'F'</span><span class="s3">):</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s4">'float'</span>
            <span class="s2">elif </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][-</span><span class="s6">1</span><span class="s3">] </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'l'</span><span class="s3">, </span><span class="s4">'L'</span><span class="s3">):</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s4">'long double'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s4">'double'</span>

        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span>
            <span class="s1">t</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_constant_3</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; constant    : CHAR_CONST 
                        | WCHAR_CONST 
                        | U8CHAR_CONST 
                        | U16CHAR_CONST 
                        | U32CHAR_CONST 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span>
            <span class="s4">'char'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>

    <span class="s0"># The &quot;unified&quot; string and wstring literal rules are for supporting</span>
    <span class="s0"># concatenation of adjacent string literals.</span>
    <span class="s0"># I.e. &quot;hello &quot; &quot;world&quot; is seen by the C compiler as a single string literal</span>
    <span class="s0"># with the value &quot;hello world&quot;</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">p_unified_string_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unified_string_literal  : STRING_LITERAL 
                                    | unified_string_literal STRING_LITERAL 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">: </span><span class="s0"># single literal</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span>
                <span class="s4">'string'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">value </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">value</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">][</span><span class="s6">1</span><span class="s3">:]</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_unified_wstring_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; unified_wstring_literal : WSTRING_LITERAL 
                                    | U8STRING_LITERAL 
                                    | U16STRING_LITERAL 
                                    | U32STRING_LITERAL 
                                    | unified_wstring_literal WSTRING_LITERAL 
                                    | unified_wstring_literal U8STRING_LITERAL 
                                    | unified_wstring_literal U16STRING_LITERAL 
                                    | unified_wstring_literal U32STRING_LITERAL 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s6">2</span><span class="s3">: </span><span class="s0"># single literal</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">c_ast</span><span class="s3">.</span><span class="s1">Constant</span><span class="s3">(</span>
                <span class="s4">'string'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_token_coord</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">value </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">].</span><span class="s1">value</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">()[:-</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p</span><span class="s3">[</span><span class="s6">2</span><span class="s3">][</span><span class="s6">2</span><span class="s3">:]</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">p_brace_open</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; brace_open  :   LBRACE 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">set_lineno</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_brace_close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; brace_close :   RBRACE 
        &quot;&quot;&quot;</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">set_lineno</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">(</span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">p_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5">'empty : '</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">p_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># If error recovery is added here in the future, make sure</span>
        <span class="s0"># _get_yacc_lookahead_token still works!</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">p</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span>
                <span class="s4">'before: %s' </span><span class="s3">% </span><span class="s1">p</span><span class="s3">.</span><span class="s1">value</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_coord</span><span class="s3">(</span><span class="s1">lineno</span><span class="s3">=</span><span class="s1">p</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">,</span>
                            <span class="s1">column</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">find_tok_column</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_parse_error</span><span class="s3">(</span><span class="s4">'At end of input'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">clex</span><span class="s3">.</span><span class="s1">filename</span><span class="s3">)</span>
</pre>
</body>
</html>