<html>
<head>
<title>_generated_run.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_generated_run.py</font>
</center></td></tr></table>
<pre><span class="s0"># ***********************************************************</span>
<span class="s0"># ******* WARNING: AUTOGENERATED! ALL EDITS WILL BE LOST ******</span>
<span class="s0"># *************************************************************</span>
<span class="s0"># isort: skip</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_instrumentation </span><span class="s2">import </span><span class="s1">Instrument</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_ki </span><span class="s2">import </span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_run </span><span class="s2">import </span><span class="s1">_NO_SEND</span><span class="s3">, </span><span class="s1">GLOBAL_RUN_CONTEXT</span>

<span class="s0"># fmt: off</span>


<span class="s2">def </span><span class="s1">current_statistics</span><span class="s3">():</span>
    <span class="s4">&quot;&quot;&quot;Returns an object containing run-loop-level debugging information. 
 
        Currently the following fields are defined: 
 
        * ``tasks_living`` (int): The number of tasks that have been spawned 
          and not yet exited. 
        * ``tasks_runnable`` (int): The number of tasks that are currently 
          queued on the run queue (as opposed to blocked waiting for something 
          to happen). 
        * ``seconds_to_next_deadline`` (float): The time until the next 
          pending cancel scope deadline. May be negative if the deadline has 
          expired but we haven't yet processed cancellations. May be 
          :data:`~math.inf` if there are no pending deadlines. 
        * ``run_sync_soon_queue_size`` (int): The number of 
          unprocessed callbacks queued via 
          :meth:`trio.lowlevel.TrioToken.run_sync_soon`. 
        * ``io_statistics`` (object): Some statistics from Trio's I/O 
          backend. This always has an attribute ``backend`` which is a string 
          naming which operating-system-specific I/O backend is in use; the 
          other attributes vary between backends. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">current_statistics</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">current_time</span><span class="s3">():</span>
    <span class="s4">&quot;&quot;&quot;Returns the current time according to Trio's internal clock. 
 
        Returns: 
            float: The current time. 
 
        Raises: 
            RuntimeError: if not inside a call to :func:`trio.run`. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">current_time</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">current_clock</span><span class="s3">():</span>
    <span class="s4">&quot;&quot;&quot;Returns the current :class:`~trio.abc.Clock`.&quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">current_clock</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">current_root_task</span><span class="s3">():</span>
    <span class="s4">&quot;&quot;&quot;Returns the current root :class:`Task`. 
 
        This is the task that is the ultimate parent of all other tasks. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">current_root_task</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">reschedule</span><span class="s3">(</span><span class="s1">task</span><span class="s3">, </span><span class="s1">next_send</span><span class="s3">=</span><span class="s1">_NO_SEND</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Reschedule the given task with the given 
        :class:`outcome.Outcome`. 
 
        See :func:`wait_task_rescheduled` for the gory details. 
 
        There must be exactly one call to :func:`reschedule` for every call to 
        :func:`wait_task_rescheduled`. (And when counting, keep in mind that 
        returning :data:`Abort.SUCCEEDED` from an abort callback is equivalent 
        to calling :func:`reschedule` once.) 
 
        Args: 
          task (trio.lowlevel.Task): the task to be rescheduled. Must be blocked 
              in a call to :func:`wait_task_rescheduled`. 
          next_send (outcome.Outcome): the value (or error) to return (or 
              raise) from :func:`wait_task_rescheduled`. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">reschedule</span><span class="s3">(</span><span class="s1">task</span><span class="s3">, </span><span class="s1">next_send</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">spawn_system_task</span><span class="s3">(</span><span class="s1">async_fn</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">context</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Spawn a &quot;system&quot; task. 
 
        System tasks have a few differences from regular tasks: 
 
        * They don't need an explicit nursery; instead they go into the 
          internal &quot;system nursery&quot;. 
 
        * If a system task raises an exception, then it's converted into a 
          :exc:`~trio.TrioInternalError` and *all* tasks are cancelled. If you 
          write a system task, you should be careful to make sure it doesn't 
          crash. 
 
        * System tasks are automatically cancelled when the main task exits. 
 
        * By default, system tasks have :exc:`KeyboardInterrupt` protection 
          *enabled*. If you want your task to be interruptible by control-C, 
          then you need to use :func:`disable_ki_protection` explicitly (and 
          come up with some plan for what to do with a 
          :exc:`KeyboardInterrupt`, given that system tasks aren't allowed to 
          raise exceptions). 
 
        * System tasks do not inherit context variables from their creator. 
 
        Towards the end of a call to :meth:`trio.run`, after the main 
        task and all system tasks have exited, the system nursery 
        becomes closed. At this point, new calls to 
        :func:`spawn_system_task` will raise ``RuntimeError(&quot;Nursery 
        is closed to new arrivals&quot;)`` instead of creating a system 
        task. It's possible to encounter this state either in 
        a ``finally`` block in an async generator, or in a callback 
        passed to :meth:`TrioToken.run_sync_soon` at the right moment. 
 
        Args: 
          async_fn: An async callable. 
          args: Positional arguments for ``async_fn``. If you want to pass 
              keyword arguments, use :func:`functools.partial`. 
          name: The name for this task. Only used for debugging/introspection 
              (e.g. ``repr(task_obj)``). If this isn't a string, 
              :func:`spawn_system_task` will try to make it one. A common use 
              case is if you're wrapping a function before spawning a new 
              task, you might pass the original function as the ``name=`` to 
              make debugging easier. 
          context: An optional ``contextvars.Context`` object with context variables 
              to use for this task. You would normally get a copy of the current 
              context with ``context = contextvars.copy_context()`` and then you would 
              pass that ``context`` object here. 
 
        Returns: 
          Task: the newly spawned task 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">spawn_system_task</span><span class="s3">(</span><span class="s1">async_fn</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">context</span><span class="s3">=</span><span class="s1">context</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">current_trio_token</span><span class="s3">():</span>
    <span class="s4">&quot;&quot;&quot;Retrieve the :class:`TrioToken` for the current call to 
        :func:`trio.run`. 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">current_trio_token</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s2">async def </span><span class="s1">wait_all_tasks_blocked</span><span class="s3">(</span><span class="s1">cushion</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Block until there are no runnable tasks. 
 
        This is useful in testing code when you want to give other tasks a 
        chance to &quot;settle down&quot;. The calling task is blocked, and doesn't wake 
        up until all other tasks are also blocked for at least ``cushion`` 
        seconds. (Setting a non-zero ``cushion`` is intended to handle cases 
        like two tasks talking to each other over a local socket, where we 
        want to ignore the potential brief moment between a send and receive 
        when all tasks are blocked.) 
 
        Note that ``cushion`` is measured in *real* time, not the Trio clock 
        time. 
 
        If there are multiple tasks blocked in :func:`wait_all_tasks_blocked`, 
        then the one with the shortest ``cushion`` is the one woken (and 
        this task becoming unblocked resets the timers for the remaining 
        tasks). If there are multiple tasks that have exactly the same 
        ``cushion``, then all are woken. 
 
        You should also consider :class:`trio.testing.Sequencer`, which 
        provides a more explicit way to control execution ordering within a 
        test, and will often produce more readable tests. 
 
        Example: 
          Here's an example of one way to test that Trio's locks are fair: we 
          take the lock in the parent, start a child, wait for the child to be 
          blocked waiting for the lock (!), and then check that we can't 
          release and immediately re-acquire the lock:: 
 
             async def lock_taker(lock): 
                 await lock.acquire() 
                 lock.release() 
 
             async def test_lock_fairness(): 
                 lock = trio.Lock() 
                 await lock.acquire() 
                 async with trio.open_nursery() as nursery: 
                     nursery.start_soon(lock_taker, lock) 
                     # child hasn't run yet, we have the lock 
                     assert lock.locked() 
                     assert lock._owner is trio.lowlevel.current_task() 
                     await trio.testing.wait_all_tasks_blocked() 
                     # now the child has run and is blocked on lock.acquire(), we 
                     # still have the lock 
                     assert lock.locked() 
                     assert lock._owner is trio.lowlevel.current_task() 
                     lock.release() 
                     try: 
                         # The child has a prior claim, so we can't have it 
                         lock.acquire_nowait() 
                     except trio.WouldBlock: 
                         assert lock._owner is not trio.lowlevel.current_task() 
                         print(&quot;PASS&quot;) 
                     else: 
                         print(&quot;FAIL&quot;) 
 
        &quot;&quot;&quot;</span>
    <span class="s1">locals</span><span class="s3">()[</span><span class="s1">LOCALS_KEY_KI_PROTECTION_ENABLED</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return await </span><span class="s1">GLOBAL_RUN_CONTEXT</span><span class="s3">.</span><span class="s1">runner</span><span class="s3">.</span><span class="s1">wait_all_tasks_blocked</span><span class="s3">(</span><span class="s1">cushion</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s5">&quot;must be called from async context&quot;</span><span class="s3">)</span>


<span class="s0"># fmt: on</span>
</pre>
</body>
</html>