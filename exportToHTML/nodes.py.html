<html>
<head>
<title>nodes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
nodes.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">MutableMapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Set</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code </span><span class="s0">import </span><span class="s1">getfslineno</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code</span><span class="s2">.</span><span class="s1">code </span><span class="s0">import </span><span class="s1">ExceptionInfo</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code</span><span class="s2">.</span><span class="s1">code </span><span class="s0">import </span><span class="s1">TerminalRepr</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code</span><span class="s2">.</span><span class="s1">code </span><span class="s0">import </span><span class="s1">Traceback</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">compat </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">compat </span><span class="s0">import </span><span class="s1">LEGACY_PATH</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">config </span><span class="s0">import </span><span class="s1">ConftestImportFailure</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">deprecated </span><span class="s0">import </span><span class="s1">FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">deprecated </span><span class="s0">import </span><span class="s1">NODE_CTOR_FSPATH_ARG</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">structures </span><span class="s0">import </span><span class="s1">Mark</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">structures </span><span class="s0">import </span><span class="s1">MarkDecorator</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">structures </span><span class="s0">import </span><span class="s1">NodeKeywords</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">outcomes </span><span class="s0">import </span><span class="s1">fail</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">absolutepath</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">commonpath</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">stash </span><span class="s0">import </span><span class="s1">Stash</span>
<span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">warning_types </span><span class="s0">import </span><span class="s1">PytestWarning</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s3"># Imported here due to circular import.</span>
    <span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">main </span><span class="s0">import </span><span class="s1">Session</span>
    <span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">_code</span><span class="s2">.</span><span class="s1">code </span><span class="s0">import </span><span class="s1">_TracebackStyle</span>


<span class="s1">SEP </span><span class="s2">= </span><span class="s4">&quot;/&quot;</span>

<span class="s1">tracebackcutdir </span><span class="s2">= </span><span class="s1">Path</span><span class="s2">(</span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">__file__</span><span class="s2">).</span><span class="s1">parent</span>


<span class="s0">def </span><span class="s1">iterparentnodeids</span><span class="s2">(</span><span class="s1">nodeid</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
    <span class="s5">&quot;&quot;&quot;Return the parent node IDs of a given node ID, inclusive. 
 
    For the node ID 
 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source&quot; 
 
    the result would be 
 
        &quot;&quot; 
        &quot;testing&quot; 
        &quot;testing/code&quot; 
        &quot;testing/code/test_excinfo.py&quot; 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo&quot; 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source&quot; 
 
    Note that / components are only considered until the first ::. 
    &quot;&quot;&quot;</span>
    <span class="s1">pos </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">first_colons</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">] = </span><span class="s1">nodeid</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s4">&quot;::&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">first_colons </span><span class="s2">== -</span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">first_colons </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s3"># The root Session node - always present.</span>
    <span class="s0">yield </span><span class="s4">&quot;&quot;</span>
    <span class="s3"># Eagerly consume SEP parts until first colons.</span>
    <span class="s0">while True</span><span class="s2">:</span>
        <span class="s1">at </span><span class="s2">= </span><span class="s1">nodeid</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s1">SEP</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">first_colons</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">at </span><span class="s2">== -</span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">at </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">nodeid</span><span class="s2">[:</span><span class="s1">at</span><span class="s2">]</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">at </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">SEP</span><span class="s2">)</span>
    <span class="s3"># Eagerly consume :: parts.</span>
    <span class="s0">while True</span><span class="s2">:</span>
        <span class="s1">at </span><span class="s2">= </span><span class="s1">nodeid</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s4">&quot;::&quot;</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">at </span><span class="s2">== -</span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">at </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">nodeid</span><span class="s2">[:</span><span class="s1">at</span><span class="s2">]</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">at </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s4">&quot;::&quot;</span><span class="s2">)</span>
    <span class="s3"># The node ID itself.</span>
    <span class="s0">if </span><span class="s1">nodeid</span><span class="s2">:</span>
        <span class="s0">yield </span><span class="s1">nodeid</span>


<span class="s0">def </span><span class="s1">_check_path</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">: </span><span class="s1">LEGACY_PATH</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">Path</span><span class="s2">(</span><span class="s1">fspath</span><span class="s2">) != </span><span class="s1">path</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">f&quot;Path(</span><span class="s0">{</span><span class="s1">fspath</span><span class="s0">!r}</span><span class="s4">) != </span><span class="s0">{</span><span class="s1">path</span><span class="s0">!r}\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;if both path and fspath are given they need to be equal&quot;</span>
        <span class="s2">)</span>


<span class="s0">def </span><span class="s1">_imply_path</span><span class="s2">(</span>
    <span class="s1">node_type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s4">&quot;Node&quot;</span><span class="s2">],</span>
    <span class="s1">path</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Path</span><span class="s2">],</span>
    <span class="s1">fspath</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">LEGACY_PATH</span><span class="s2">],</span>
<span class="s2">) </span><span class="s1">-&gt; Path</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">fspath </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s1">NODE_CTOR_FSPATH_ARG</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                <span class="s1">node_type_name</span><span class="s2">=</span><span class="s1">node_type</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
            <span class="s2">),</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">6</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">fspath </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">_check_path</span><span class="s2">(</span><span class="s1">path</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">fspath </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">Path</span><span class="s2">(</span><span class="s1">fspath</span><span class="s2">)</span>


<span class="s1">_NodeType </span><span class="s2">= </span><span class="s1">TypeVar</span><span class="s2">(</span><span class="s4">&quot;_NodeType&quot;</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">=</span><span class="s4">&quot;Node&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">NodeMeta</span><span class="s2">(</span><span class="s1">type</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">k</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s1">msg </span><span class="s2">= (</span>
            <span class="s4">&quot;Direct construction of {name} has been deprecated, please use {name}.from_parent.</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;See &quot;</span>
            <span class="s4">&quot;https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent&quot;</span>
            <span class="s4">&quot; for more details.&quot;</span>
        <span class="s2">).</span><span class="s1">format</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__module__</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s1">fail</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">pytrace</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_create</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">k</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__call__</span><span class="s2">(*</span><span class="s1">k</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s1">sig </span><span class="s2">= </span><span class="s1">signature</span><span class="s2">(</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;__init__&quot;</span><span class="s2">))</span>
            <span class="s1">known_kw </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kw</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">}</span>
            <span class="s0">from </span><span class="s2">.</span><span class="s1">warning_types </span><span class="s0">import </span><span class="s1">PytestDeprecationWarning</span>

            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s1">PytestDeprecationWarning</span><span class="s2">(</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s4">is not using a cooperative constructor and only takes </span><span class="s0">{</span><span class="s1">set</span><span class="s2">(</span><span class="s1">known_kw</span><span class="s2">)</span><span class="s0">}</span><span class="s4">.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;See https://docs.pytest.org/en/stable/deprecations.html&quot;</span>
                    <span class="s4">&quot;#constructors-of-custom-pytest-node-subclasses-should-take-kwargs &quot;</span>
                    <span class="s4">&quot;for more details.&quot;</span>
                <span class="s2">)</span>
            <span class="s2">)</span>

            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">__call__</span><span class="s2">(*</span><span class="s1">k</span><span class="s2">, **</span><span class="s1">known_kw</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">Node</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">NodeMeta</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot;Base class of :class:`Collector` and :class:`Item`, the components of 
    the test collection tree. 
 
    ``Collector``\'s are the internal nodes of the tree, and ``Item``\'s are the 
    leaf nodes. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Implemented in the legacypath plugin.</span>
    <span class="s3">#: A ``LEGACY_PATH`` copy of the :attr:`path` attribute. Intended for usage</span>
    <span class="s3">#: for methods not migrated to ``pathlib.Path`` yet, such as</span>
    <span class="s3">#: :meth:`Item.reportinfo`. Will be deprecated in a future release, prefer</span>
    <span class="s3">#: using :attr:`path` instead.</span>
    <span class="s1">fspath</span><span class="s2">: </span><span class="s1">LEGACY_PATH</span>

    <span class="s3"># Use __slots__ to make attribute access faster.</span>
    <span class="s3"># Note that __dict__ is still available.</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span>
        <span class="s4">&quot;name&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;parent&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;config&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;session&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;path&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;_nodeid&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;_store&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;__dict__&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s4">&quot;Optional[Node]&quot; </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">config</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Config</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">session</span><span class="s2">: </span><span class="s4">&quot;Optional[Session]&quot; </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">fspath</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">LEGACY_PATH</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Path</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">nodeid</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">#: A unique name within the scope of the parent node.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s1">name</span>

        <span class="s3">#: The parent collector node.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">parent </span><span class="s2">= </span><span class="s1">parent</span>

        <span class="s0">if </span><span class="s1">config</span><span class="s2">:</span>
            <span class="s3">#: The pytest config object.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">: </span><span class="s1">Config </span><span class="s2">= </span><span class="s1">config</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">parent</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;config or parent must be provided&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">config </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">config</span>

        <span class="s0">if </span><span class="s1">session</span><span class="s2">:</span>
            <span class="s3">#: The pytest session this node is part of.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">: </span><span class="s1">Session </span><span class="s2">= </span><span class="s1">session</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">parent</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;session or parent must be provided&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">session </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">session</span>

        <span class="s0">if </span><span class="s1">path </span><span class="s0">is None and </span><span class="s1">fspath </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">path </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s4">&quot;path&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s3">#: Filesystem path where this node was collected from (can be None).</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path </span><span class="s2">= </span><span class="s1">_imply_path</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">path</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">=</span><span class="s1">fspath</span><span class="s2">)</span>

        <span class="s3"># The explicit annotation is to avoid publicly exposing NodeKeywords.</span>
        <span class="s3">#: Keywords/markers collected from all scopes.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">keywords</span><span class="s2">: </span><span class="s1">MutableMapping</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Any</span><span class="s2">] = </span><span class="s1">NodeKeywords</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s3">#: The marker objects belonging to this node.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">own_markers</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">Mark</span><span class="s2">] = []</span>

        <span class="s3">#: Allow adding of extra keywords to use for matching.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">extra_keyword_matches</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s4">&quot;::()&quot; </span><span class="s0">not in </span><span class="s1">nodeid</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_nodeid </span><span class="s2">= </span><span class="s1">nodeid</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;nodeid or parent must be provided&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_nodeid </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">nodeid </span><span class="s2">+ </span><span class="s4">&quot;::&quot; </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span>

        <span class="s3">#: A place where plugins can store information on the node for their</span>
        <span class="s3">#: own use.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">stash</span><span class="s2">: </span><span class="s1">Stash </span><span class="s2">= </span><span class="s1">Stash</span><span class="s2">()</span>
        <span class="s3"># Deprecated alias. Was never public. Can be removed in a few releases.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_store </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">stash</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_parent</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">: </span><span class="s4">&quot;Node&quot;</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Public constructor for Nodes. 
 
        This indirection got introduced in order to enable removing 
        the fragile logic from the node constructors. 
 
        Subclasses can use ``super().from_parent(...)`` when overriding the 
        construction. 
 
        :param parent: The parent node of this Node. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">&quot;config&quot; </span><span class="s0">in </span><span class="s1">kw</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;config is not a valid argument for from_parent&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s4">&quot;session&quot; </span><span class="s0">in </span><span class="s1">kw</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;session is not a valid argument for from_parent&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_create</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">=</span><span class="s1">parent</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ihook</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;fspath-sensitive hook proxy used to call pytest hooks.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">.</span><span class="s1">gethookproxy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">path</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s4">&quot;&lt;{} {}&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">warn</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">warning</span><span class="s2">: </span><span class="s1">Warning</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Issue a warning for this Node. 
 
        Warnings will be displayed after the test session, unless explicitly suppressed. 
 
        :param Warning warning: 
            The warning instance to issue. 
 
        :raises ValueError: If ``warning`` instance is not a subclass of Warning. 
 
        Example usage: 
 
        .. code-block:: python 
 
            node.warn(PytestWarning(&quot;some message&quot;)) 
            node.warn(UserWarning(&quot;some message&quot;)) 
 
        .. versionchanged:: 6.2 
            Any subclass of :class:`Warning` is now accepted, rather than only 
            :class:`PytestWarning &lt;pytest.PytestWarning&gt;` subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s3"># enforce type checks here to avoid getting a generic type error later otherwise.</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">warning</span><span class="s2">, </span><span class="s1">Warning</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;warning must be an instance of Warning or subclass, got {!r}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
                    <span class="s1">warning</span>
                <span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">lineno </span><span class="s2">= </span><span class="s1">get_fslocation_from_item</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">lineno </span><span class="s0">is not None</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn_explicit</span><span class="s2">(</span>
            <span class="s1">warning</span><span class="s2">,</span>
            <span class="s1">category</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
            <span class="s1">filename</span><span class="s2">=</span><span class="s1">str</span><span class="s2">(</span><span class="s1">path</span><span class="s2">),</span>
            <span class="s1">lineno</span><span class="s2">=</span><span class="s1">lineno </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s3"># Methods for ordering nodes.</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nodeid</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;A ::-separated string denoting its collection tree address.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nodeid</span>

    <span class="s0">def </span><span class="s1">__hash__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_nodeid</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">setup</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">teardown</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">listchain</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; List</span><span class="s2">[</span><span class="s4">&quot;Node&quot;</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Return list of all parent collectors up to self, starting from 
        the root of collection tree. 
 
        :returns: The nodes. 
        &quot;&quot;&quot;</span>
        <span class="s1">chain </span><span class="s2">= []</span>
        <span class="s1">item</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Node</span><span class="s2">] = </span><span class="s1">self</span>
        <span class="s0">while </span><span class="s1">item </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">chain</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">item</span><span class="s2">)</span>
            <span class="s1">item </span><span class="s2">= </span><span class="s1">item</span><span class="s2">.</span><span class="s1">parent</span>
        <span class="s1">chain</span><span class="s2">.</span><span class="s1">reverse</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">chain</span>

    <span class="s0">def </span><span class="s1">add_marker</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">marker</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">MarkDecorator</span><span class="s2">], </span><span class="s1">append</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Dynamically add a marker object to the node. 
 
        :param marker: 
            The marker. 
        :param append: 
            Whether to append the marker, or prepend it. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">mark </span><span class="s0">import </span><span class="s1">MARK_GEN</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">marker</span><span class="s2">, </span><span class="s1">MarkDecorator</span><span class="s2">):</span>
            <span class="s1">marker_ </span><span class="s2">= </span><span class="s1">marker</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">marker</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">marker_ </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">MARK_GEN</span><span class="s2">, </span><span class="s1">marker</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;is not a string or pytest.mark.* Marker&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">keywords</span><span class="s2">[</span><span class="s1">marker_</span><span class="s2">.</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">marker_</span>
        <span class="s0">if </span><span class="s1">append</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">own_markers</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">marker_</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">own_markers</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">marker_</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">iter_markers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">Mark</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Iterate over all markers of the node. 
 
        :param name: If given, filter the results by the name attribute. 
        :returns: An iterator of the markers of the node. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iter_markers_with_node</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">iter_markers_with_node</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s4">&quot;Node&quot;</span><span class="s2">, </span><span class="s1">Mark</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot;Iterate over all markers of the node. 
 
        :param name: If given, filter the results by the name attribute. 
        :returns: An iterator of (node, mark) tuples. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">listchain</span><span class="s2">()):</span>
            <span class="s0">for </span><span class="s1">mark </span><span class="s0">in </span><span class="s1">node</span><span class="s2">.</span><span class="s1">own_markers</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">is None or </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) == </span><span class="s1">name</span><span class="s2">:</span>
                    <span class="s0">yield </span><span class="s1">node</span><span class="s2">, </span><span class="s1">mark</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">get_closest_marker</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; Optional</span><span class="s2">[</span><span class="s1">Mark</span><span class="s2">]:</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">get_closest_marker</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">default</span><span class="s2">: </span><span class="s1">Mark</span><span class="s2">) </span><span class="s1">-&gt; Mark</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">get_closest_marker</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">default</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Mark</span><span class="s2">] = </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; Optional</span><span class="s2">[</span><span class="s1">Mark</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Return the first marker matching the name, from closest (for 
        example function) to farther level (for example module level). 
 
        :param default: Fallback return value if no marker was found. 
        :param name: Name to filter by. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">next</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">iter_markers</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">), </span><span class="s1">default</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">listextrakeywords</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Return a set of all extra keywords in self and any parents.&quot;&quot;&quot;</span>
        <span class="s1">extra_keywords</span><span class="s2">: </span><span class="s1">Set</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">listchain</span><span class="s2">():</span>
            <span class="s1">extra_keywords</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">item</span><span class="s2">.</span><span class="s1">extra_keyword_matches</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">extra_keywords</span>

    <span class="s0">def </span><span class="s1">listnames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; List</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">name </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">listchain</span><span class="s2">()]</span>

    <span class="s0">def </span><span class="s1">addfinalizer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fin</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[[], </span><span class="s1">object</span><span class="s2">]) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Register a function to be called without arguments when this node is 
        finalized. 
 
        This method can only be called when this node is active 
        in a setup chain, for example during self.setup(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">.</span><span class="s1">_setupstate</span><span class="s2">.</span><span class="s1">addfinalizer</span><span class="s2">(</span><span class="s1">fin</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">getparent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[</span><span class="s1">_NodeType</span><span class="s2">]) </span><span class="s1">-&gt; Optional</span><span class="s2">[</span><span class="s1">_NodeType</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Get the next parent node (including self) which is an instance of 
        the given class. 
 
        :param cls: The node class to search for. 
        :returns: The node, if found. 
        &quot;&quot;&quot;</span>
        <span class="s1">current</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Node</span><span class="s2">] = </span><span class="s1">self</span>
        <span class="s0">while </span><span class="s1">current </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">current</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">):</span>
            <span class="s1">current </span><span class="s2">= </span><span class="s1">current</span><span class="s2">.</span><span class="s1">parent</span>
        <span class="s0">assert </span><span class="s1">current </span><span class="s0">is None or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">current</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">current</span>

    <span class="s0">def </span><span class="s1">_traceback_filter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">excinfo</span><span class="s2">: </span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">]) </span><span class="s1">-&gt; Traceback</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">traceback</span>

    <span class="s0">def </span><span class="s1">_repr_failure_py</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">excinfo</span><span class="s2">: </span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">],</span>
        <span class="s1">style</span><span class="s2">: </span><span class="s4">&quot;Optional[_TracebackStyle]&quot; </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; TerminalRepr</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">_pytest</span><span class="s2">.</span><span class="s1">fixtures </span><span class="s0">import </span><span class="s1">FixtureLookupError</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ConftestImportFailure</span><span class="s2">):</span>
            <span class="s1">excinfo </span><span class="s2">= </span><span class="s1">ExceptionInfo</span><span class="s2">.</span><span class="s1">from_exc_info</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">excinfo</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">fail</span><span class="s2">.</span><span class="s1">Exception</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">pytrace</span><span class="s2">:</span>
                <span class="s1">style </span><span class="s2">= </span><span class="s4">&quot;value&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">FixtureLookupError</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">formatrepr</span><span class="s2">()</span>

        <span class="s1">tbfilter</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">bool</span><span class="s2">, </span><span class="s1">Callable</span><span class="s2">[[</span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">]], </span><span class="s1">Traceback</span><span class="s2">]]</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span><span class="s4">&quot;fulltrace&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s1">style </span><span class="s2">= </span><span class="s4">&quot;long&quot;</span>
            <span class="s1">tbfilter </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">tbfilter </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_traceback_filter</span>
            <span class="s0">if </span><span class="s1">style </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
                <span class="s1">style </span><span class="s2">= </span><span class="s4">&quot;long&quot;</span>
        <span class="s3"># XXX should excinfo.getrepr record all data and toterminal() process it?</span>
        <span class="s0">if </span><span class="s1">style </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span><span class="s4">&quot;tbstyle&quot;</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s2">) == </span><span class="s4">&quot;short&quot;</span><span class="s2">:</span>
                <span class="s1">style </span><span class="s2">= </span><span class="s4">&quot;short&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">style </span><span class="s2">= </span><span class="s4">&quot;long&quot;</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span><span class="s4">&quot;verbose&quot;</span><span class="s2">, </span><span class="s6">0</span><span class="s2">) &gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">truncate_locals </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">truncate_locals </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s3"># excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.</span>
        <span class="s3"># It is possible for a fixture/test to change the CWD while this code runs, which</span>
        <span class="s3"># would then result in the user seeing confusing paths in the failure message.</span>
        <span class="s3"># To fix this, if the CWD changed, always display the full absolute path.</span>
        <span class="s3"># It will be better to just always display paths relative to invocation_dir, but</span>
        <span class="s3"># this requires a lot of plumbing (#6428).</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">abspath </span><span class="s2">= </span><span class="s1">Path</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">getcwd</span><span class="s2">()) != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">invocation_params</span><span class="s2">.</span><span class="s1">dir</span>
        <span class="s0">except </span><span class="s1">OSError</span><span class="s2">:</span>
            <span class="s1">abspath </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">getrepr</span><span class="s2">(</span>
            <span class="s1">funcargs</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">abspath</span><span class="s2">=</span><span class="s1">abspath</span><span class="s2">,</span>
            <span class="s1">showlocals</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span><span class="s4">&quot;showlocals&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">),</span>
            <span class="s1">style</span><span class="s2">=</span><span class="s1">style</span><span class="s2">,</span>
            <span class="s1">tbfilter</span><span class="s2">=</span><span class="s1">tbfilter</span><span class="s2">,</span>
            <span class="s1">truncate_locals</span><span class="s2">=</span><span class="s1">truncate_locals</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">repr_failure</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">excinfo</span><span class="s2">: </span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">],</span>
        <span class="s1">style</span><span class="s2">: </span><span class="s4">&quot;Optional[_TracebackStyle]&quot; </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">TerminalRepr</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Return a representation of a collection or test failure. 
 
        .. seealso:: :ref:`non-python tests` 
 
        :param excinfo: Exception information for the failure. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_repr_failure_py</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">, </span><span class="s1">style</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">get_fslocation_from_item</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s4">&quot;Node&quot;</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Path</span><span class="s2">], </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">]]:</span>
    <span class="s5">&quot;&quot;&quot;Try to extract the actual location from a node, depending on available attributes: 
 
    * &quot;location&quot;: a pair (path, lineno) 
    * &quot;obj&quot;: a Python object that the node wraps. 
    * &quot;fspath&quot;: just a path 
 
    :rtype: A tuple of (str|Path, int) with filename and 0-based line number. 
    &quot;&quot;&quot;</span>
    <span class="s3"># See Item.location.</span>
    <span class="s1">location</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">str</span><span class="s2">]] = </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s4">&quot;location&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">location </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">location</span><span class="s2">[:</span><span class="s6">2</span><span class="s2">]</span>
    <span class="s1">obj </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s4">&quot;obj&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">obj </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">getfslineno</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">node</span><span class="s2">, </span><span class="s4">&quot;fspath&quot;</span><span class="s2">, </span><span class="s4">&quot;unknown location&quot;</span><span class="s2">), -</span><span class="s6">1</span>


<span class="s0">class </span><span class="s1">Collector</span><span class="s2">(</span><span class="s1">Node</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Base class of all collectors. 
 
    Collector create children through `collect()` and thus iteratively build 
    the collection tree. 
    &quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">CollectError</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;An error during collection, contains a custom message.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">collect</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Iterable</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s4">&quot;Item&quot;</span><span class="s2">, </span><span class="s4">&quot;Collector&quot;</span><span class="s2">]]:</span>
        <span class="s5">&quot;&quot;&quot;Collect children (items and collectors) for this collector.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;abstract&quot;</span><span class="s2">)</span>

    <span class="s3"># TODO: This omits the style= parameter which breaks Liskov Substitution.</span>
    <span class="s0">def </span><span class="s1">repr_failure</span><span class="s2">(  </span><span class="s3"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">excinfo</span><span class="s2">: </span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">TerminalRepr</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Return a representation of a collection failure. 
 
        :param excinfo: Exception information for the failure. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">CollectError</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span>
            <span class="s4">&quot;fulltrace&quot;</span><span class="s2">, </span><span class="s0">False</span>
        <span class="s2">):</span>
            <span class="s1">exc </span><span class="s2">= </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span>
            <span class="s0">return </span><span class="s1">str</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>

        <span class="s3"># Respect explicit tbstyle option, but default to &quot;short&quot;</span>
        <span class="s3"># (_repr_failure_py uses &quot;long&quot; with &quot;fulltrace&quot; option always).</span>
        <span class="s1">tbstyle </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">getoption</span><span class="s2">(</span><span class="s4">&quot;tbstyle&quot;</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">tbstyle </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
            <span class="s1">tbstyle </span><span class="s2">= </span><span class="s4">&quot;short&quot;</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_repr_failure_py</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">, </span><span class="s1">style</span><span class="s2">=</span><span class="s1">tbstyle</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_traceback_filter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">excinfo</span><span class="s2">: </span><span class="s1">ExceptionInfo</span><span class="s2">[</span><span class="s1">BaseException</span><span class="s2">]) </span><span class="s1">-&gt; Traceback</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;path&quot;</span><span class="s2">):</span>
            <span class="s1">traceback </span><span class="s2">= </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">traceback</span>
            <span class="s1">ntraceback </span><span class="s2">= </span><span class="s1">traceback</span><span class="s2">.</span><span class="s1">cut</span><span class="s2">(</span><span class="s1">path</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">path</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">ntraceback </span><span class="s2">== </span><span class="s1">traceback</span><span class="s2">:</span>
                <span class="s1">ntraceback </span><span class="s2">= </span><span class="s1">ntraceback</span><span class="s2">.</span><span class="s1">cut</span><span class="s2">(</span><span class="s1">excludepath</span><span class="s2">=</span><span class="s1">tracebackcutdir</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">traceback</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">excinfo</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">traceback</span>


<span class="s0">def </span><span class="s1">_check_initialpaths_for_relpath</span><span class="s2">(</span><span class="s1">session</span><span class="s2">: </span><span class="s4">&quot;Session&quot;</span><span class="s2">, </span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">) </span><span class="s1">-&gt; Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]:</span>
    <span class="s0">for </span><span class="s1">initial_path </span><span class="s0">in </span><span class="s1">session</span><span class="s2">.</span><span class="s1">_initialpaths</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">commonpath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">, </span><span class="s1">initial_path</span><span class="s2">) == </span><span class="s1">initial_path</span><span class="s2">:</span>
            <span class="s1">rel </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">path</span><span class="s2">.</span><span class="s1">relative_to</span><span class="s2">(</span><span class="s1">initial_path</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s4">&quot;&quot; </span><span class="s0">if </span><span class="s1">rel </span><span class="s2">== </span><span class="s4">&quot;.&quot; </span><span class="s0">else </span><span class="s1">rel</span>
    <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">FSCollector</span><span class="s2">(</span><span class="s1">Collector</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Base class for filesystem collectors.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fspath</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">LEGACY_PATH</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path_or_parent</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">Path</span><span class="s2">, </span><span class="s1">Node</span><span class="s2">]] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Path</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Node</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">config</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Config</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">session</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s4">&quot;Session&quot;</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">nodeid</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">path_or_parent</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">path_or_parent</span><span class="s2">, </span><span class="s1">Node</span><span class="s2">):</span>
                <span class="s0">assert </span><span class="s1">parent </span><span class="s0">is None</span>
                <span class="s1">parent </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">FSCollector</span><span class="s2">, </span><span class="s1">path_or_parent</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">path_or_parent</span><span class="s2">, </span><span class="s1">Path</span><span class="s2">):</span>
                <span class="s0">assert </span><span class="s1">path </span><span class="s0">is None</span>
                <span class="s1">path </span><span class="s2">= </span><span class="s1">path_or_parent</span>

        <span class="s1">path </span><span class="s2">= </span><span class="s1">_imply_path</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">path</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">=</span><span class="s1">fspath</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">path</span><span class="s2">.</span><span class="s1">name</span>
            <span class="s0">if </span><span class="s1">parent </span><span class="s0">is not None and </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">path </span><span class="s2">!= </span><span class="s1">path</span><span class="s2">:</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">rel </span><span class="s2">= </span><span class="s1">path</span><span class="s2">.</span><span class="s1">relative_to</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">path</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">name </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">rel</span><span class="s2">)</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">name</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">sep</span><span class="s2">, </span><span class="s1">SEP</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">path </span><span class="s2">= </span><span class="s1">path</span>

        <span class="s0">if </span><span class="s1">session </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">parent </span><span class="s0">is not None</span>
            <span class="s1">session </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">session</span>

        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">nodeid </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">relative_to</span><span class="s2">(</span><span class="s1">session</span><span class="s2">.</span><span class="s1">config</span><span class="s2">.</span><span class="s1">rootpath</span><span class="s2">))</span>
            <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
                <span class="s1">nodeid </span><span class="s2">= </span><span class="s1">_check_initialpaths_for_relpath</span><span class="s2">(</span><span class="s1">session</span><span class="s2">, </span><span class="s1">path</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">and </span><span class="s1">os</span><span class="s2">.</span><span class="s1">sep </span><span class="s2">!= </span><span class="s1">SEP</span><span class="s2">:</span>
                <span class="s1">nodeid </span><span class="s2">= </span><span class="s1">nodeid</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">sep</span><span class="s2">, </span><span class="s1">SEP</span><span class="s2">)</span>

        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">parent</span><span class="s2">=</span><span class="s1">parent</span><span class="s2">,</span>
            <span class="s1">config</span><span class="s2">=</span><span class="s1">config</span><span class="s2">,</span>
            <span class="s1">session</span><span class="s2">=</span><span class="s1">session</span><span class="s2">,</span>
            <span class="s1">nodeid</span><span class="s2">=</span><span class="s1">nodeid</span><span class="s2">,</span>
            <span class="s1">path</span><span class="s2">=</span><span class="s1">path</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_parent</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">fspath</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">LEGACY_PATH</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Path</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kw</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;The public constructor.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">from_parent</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">=</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">=</span><span class="s1">fspath</span><span class="s2">, </span><span class="s1">path</span><span class="s2">=</span><span class="s1">path</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">gethookproxy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fspath</span><span class="s2">: </span><span class="s4">&quot;os.PathLike[str]&quot;</span><span class="s2">):</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">.</span><span class="s1">gethookproxy</span><span class="s2">(</span><span class="s1">fspath</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">isinitpath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">: </span><span class="s1">Union</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s4">&quot;os.PathLike[str]&quot;</span><span class="s2">]) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">.</span><span class="s1">isinitpath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">File</span><span class="s2">(</span><span class="s1">FSCollector</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Base class for collecting tests from a file. 
 
    :ref:`non-python tests`. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Item</span><span class="s2">(</span><span class="s1">Node</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Base class of all test invocation items. 
 
    Note that for a single function there might be multiple test invocation items. 
    &quot;&quot;&quot;</span>

    <span class="s1">nextitem </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">config</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Config</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">session</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s4">&quot;Session&quot;</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">nodeid</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kw</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3"># The first two arguments are intentionally passed positionally,</span>
        <span class="s3"># to keep plugins who define a node type which inherits from</span>
        <span class="s3"># (pytest.Item, pytest.File) working (see issue #8435).</span>
        <span class="s3"># They can be made kwargs when the deprecation above is done.</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">parent</span><span class="s2">,</span>
            <span class="s1">config</span><span class="s2">=</span><span class="s1">config</span><span class="s2">,</span>
            <span class="s1">session</span><span class="s2">=</span><span class="s1">session</span><span class="s2">,</span>
            <span class="s1">nodeid</span><span class="s2">=</span><span class="s1">nodeid</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">kw</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_report_sections</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]] = []</span>

        <span class="s3">#: A list of tuples (name, value) that holds user defined properties</span>
        <span class="s3">#: for this test.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">user_properties</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">object</span><span class="s2">]] = []</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_item_and_collector_diamond_inheritance</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_check_item_and_collector_diamond_inheritance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if the current type inherits from both File and Collector 
        at the same time, emitting a warning accordingly (#8447). 
        &quot;&quot;&quot;</span>
        <span class="s1">cls </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s3"># We inject an attribute in the type to avoid issuing this warning</span>
        <span class="s3"># for the same class more than once, which is not helpful.</span>
        <span class="s3"># It is a hack, but was deemed acceptable in order to avoid</span>
        <span class="s3"># flooding the user in the common case.</span>
        <span class="s1">attr_name </span><span class="s2">= </span><span class="s4">&quot;_pytest_diamond_inheritance_warning_shown&quot;</span>
        <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s0">False</span><span class="s2">):</span>
            <span class="s0">return</span>
        <span class="s1">setattr</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s0">True</span><span class="s2">)</span>

        <span class="s1">problems </span><span class="s2">= </span><span class="s4">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span>
            <span class="s1">base</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__bases__ </span><span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">base</span><span class="s2">, </span><span class="s1">Collector</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">problems</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">is an Item subclass and should not be a collector, &quot;</span>
                <span class="s4">f&quot;however its bases </span><span class="s0">{</span><span class="s1">problems</span><span class="s0">} </span><span class="s4">are collectors.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Please split the Collectors and the Item into separate node types.</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Pytest Doc example: https://docs.pytest.org/en/latest/example/nonpython.html</span><span class="s0">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;example pull request on a plugin: https://github.com/asmeurer/pytest-flakes/pull/40/&quot;</span><span class="s2">,</span>
                <span class="s1">PytestWarning</span><span class="s2">,</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">runtest</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Run the test case for this item. 
 
        Must be implemented by subclasses. 
 
        .. seealso:: :ref:`non-python tests` 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;runtest must be implemented by Item subclass&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">add_report_section</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">when</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">content</span><span class="s2">: </span><span class="s1">str</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s5">&quot;&quot;&quot;Add a new report section, similar to what's done internally to add 
        stdout and stderr captured output:: 
 
            item.add_report_section(&quot;call&quot;, &quot;stdout&quot;, &quot;report section contents&quot;) 
 
        :param str when: 
            One of the possible capture states, ``&quot;setup&quot;``, ``&quot;call&quot;``, ``&quot;teardown&quot;``. 
        :param str key: 
            Name of the section, can be customized at will. Pytest uses ``&quot;stdout&quot;`` and 
            ``&quot;stderr&quot;`` internally. 
        :param str content: 
            The full contents as a string. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_report_sections</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">when</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">content</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">reportinfo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s4">&quot;os.PathLike[str]&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">], </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot;Get location information for this item for test reports. 
 
        Returns a tuple with three elements: 
 
        - The path of the test (default ``self.path``) 
        - The 0-based line number of the test (default ``None``) 
        - A name of the test to be shown (default ``&quot;&quot;``) 
 
        .. seealso:: :ref:`non-python tests` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">path</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s4">&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">cached_property</span>
    <span class="s0">def </span><span class="s1">location</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Tuple</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">int</span><span class="s2">], </span><span class="s1">str</span><span class="s2">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns a tuple of ``(relfspath, lineno, testname)`` for this item 
        where ``relfspath`` is file path relative to ``config.rootpath`` 
        and lineno is a 0-based line number. 
        &quot;&quot;&quot;</span>
        <span class="s1">location </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reportinfo</span><span class="s2">()</span>
        <span class="s1">path </span><span class="s2">= </span><span class="s1">absolutepath</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">fspath</span><span class="s2">(</span><span class="s1">location</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]))</span>
        <span class="s1">relfspath </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">session</span><span class="s2">.</span><span class="s1">_node_location_to_relpath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">type</span><span class="s2">(</span><span class="s1">location</span><span class="s2">[</span><span class="s6">2</span><span class="s2">]) </span><span class="s0">is </span><span class="s1">str</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">relfspath</span><span class="s2">, </span><span class="s1">location</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">location</span><span class="s2">[</span><span class="s6">2</span><span class="s2">])</span>
</pre>
</body>
</html>