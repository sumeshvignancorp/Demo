<html>
<head>
<title>_sync.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_sync.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>

<span class="s0">import </span><span class="s1">attr</span>

<span class="s0">import </span><span class="s1">trio</span>

<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">ParkingLot</span><span class="s2">, </span><span class="s1">enable_ki_protection</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">Final</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">frozen</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">_EventStatistics</span><span class="s2">:</span>
    <span class="s1">tasks_waiting </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">eq</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">hash</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">Event</span><span class="s2">(</span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A waitable boolean value useful for inter-task synchronization, 
    inspired by :class:`threading.Event`. 
 
    An event object has an internal boolean flag, representing whether 
    the event has happened yet. The flag is initially False, and the 
    :meth:`wait` method waits until the flag is True. If the flag is 
    already True, then :meth:`wait` returns immediately. (If the event has 
    already happened, there's nothing to wait for.) The :meth:`set` method 
    sets the flag to True, and wakes up any waiters. 
 
    This behavior is useful because it helps avoid race conditions and 
    lost wakeups: it doesn't matter whether :meth:`set` gets called just 
    before or after :meth:`wait`. If you want a lower-level wakeup 
    primitive that doesn't have this protection, consider :class:`Condition` 
    or :class:`trio.lowlevel.ParkingLot`. 
 
    .. note:: Unlike `threading.Event`, `trio.Event` has no 
       `~threading.Event.clear` method. In Trio, once an `Event` has happened, 
       it cannot un-happen. If you need to represent a series of events, 
       consider creating a new `Event` object for each one (they're cheap!), 
       or other synchronization methods like :ref:`channels &lt;channels&gt;` or 
       `trio.lowlevel.ParkingLot`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_tasks </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">(</span><span class="s1">factory</span><span class="s2">=</span><span class="s1">set</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">_flag </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">(</span><span class="s1">default</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">is_set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return the current value of the internal flag.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_flag</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Set the internal flag value to True, and wake any waiting tasks.&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_flag</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_flag </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">for </span><span class="s1">task </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tasks</span><span class="s2">:</span>
                <span class="s1">_core</span><span class="s2">.</span><span class="s1">reschedule</span><span class="s2">(</span><span class="s1">task</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_tasks</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">wait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Block until the internal flag value becomes True. 
 
        If it's already True, then this method returns immediately. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_flag</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">task </span><span class="s2">= </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_tasks</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">task</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">abort_fn</span><span class="s2">(</span><span class="s1">_</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_tasks</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">task</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">Abort</span><span class="s2">.</span><span class="s1">SUCCEEDED</span>

            <span class="s0">await </span><span class="s1">_core</span><span class="s2">.</span><span class="s1">wait_task_rescheduled</span><span class="s2">(</span><span class="s1">abort_fn</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">statistics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return an object containing debugging information. 
 
        Currently the following fields are defined: 
 
        * ``tasks_waiting``: The number of tasks blocked on this event's 
          :meth:`wait` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_EventStatistics</span><span class="s2">(</span><span class="s1">tasks_waiting</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tasks</span><span class="s2">))</span>


<span class="s0">class </span><span class="s1">AsyncContextManagerMixin</span><span class="s2">:</span>
    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">__aenter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">__aexit__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">release</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">frozen</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">_CapacityLimiterStatistics</span><span class="s2">:</span>
    <span class="s1">borrowed_tokens </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">total_tokens </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">borrowers </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">tasks_waiting </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">CapacityLimiter</span><span class="s2">(</span><span class="s1">AsyncContextManagerMixin</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;An object for controlling access to a resource with limited capacity. 
 
    Sometimes you need to put a limit on how many tasks can do something at 
    the same time. For example, you might want to use some threads to run 
    multiple blocking I/O operations in parallel... but if you use too many 
    threads at once, then your system can become overloaded and it'll actually 
    make things slower. One popular solution is to impose a policy like &quot;run 
    up to 40 threads at the same time, but no more&quot;. But how do you implement 
    a policy like this? 
 
    That's what :class:`CapacityLimiter` is for. You can think of a 
    :class:`CapacityLimiter` object as a sack that starts out holding some fixed 
    number of tokens:: 
 
       limit = trio.CapacityLimiter(40) 
 
    Then tasks can come along and borrow a token out of the sack:: 
 
       # Borrow a token: 
       async with limit: 
           # We are holding a token! 
           await perform_expensive_operation() 
       # Exiting the 'async with' block puts the token back into the sack 
 
    And crucially, if you try to borrow a token but the sack is empty, then 
    you have to wait for another task to finish what it's doing and put its 
    token back first before you can take it and continue. 
 
    Another way to think of it: a :class:`CapacityLimiter` is like a sofa with a 
    fixed number of seats, and if they're all taken then you have to wait for 
    someone to get up before you can sit down. 
 
    By default, :func:`trio.to_thread.run_sync` uses a 
    :class:`CapacityLimiter` to limit the number of threads running at once; 
    see `trio.to_thread.current_default_thread_limiter` for details. 
 
    If you're familiar with semaphores, then you can think of this as a 
    restricted semaphore that's specialized for one common use case, with 
    additional error checking. For a more traditional semaphore, see 
    :class:`Semaphore`. 
 
    .. note:: 
 
       Don't confuse this with the `&quot;leaky bucket&quot; 
       &lt;https://en.wikipedia.org/wiki/Leaky_bucket&gt;`__ or `&quot;token bucket&quot; 
       &lt;https://en.wikipedia.org/wiki/Token_bucket&gt;`__ algorithms used to 
       limit bandwidth usage on networks. The basic idea of using tokens to 
       track a resource limit is similar, but this is a very simple sack where 
       tokens aren't automatically created or destroyed over time; they're 
       just borrowed and then put back. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">total_tokens</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot </span><span class="s2">= </span><span class="s1">ParkingLot</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s4"># Maps tasks attempting to acquire -&gt; borrower, to handle on-behalf-of</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pending_borrowers </span><span class="s2">= {}</span>
        <span class="s4"># invoke the property setter for validation</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">total_tokens </span><span class="s2">= </span><span class="s1">total_tokens</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens </span><span class="s2">== </span><span class="s1">total_tokens</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s5">&quot;&lt;trio.CapacityLimiter at {:#x}, {}/{} with {} waiting&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
            <span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">total_tokens</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The total capacity available. 
 
        You can change :attr:`total_tokens` by assigning to this attribute. If 
        you make it larger, then the appropriate number of waiting tasks will 
        be woken immediately to take the new tokens. If you decrease 
        total_tokens below the number of tasks that are currently using the 
        resource, then all current tasks will be allowed to finish as normal, 
        but no new tasks will be allowed in until the total number of tasks 
        drops below the new total_tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens</span>

    <span class="s2">@</span><span class="s1">total_tokens</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s0">def </span><span class="s1">total_tokens</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">new_total_tokens</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">new_total_tokens</span><span class="s2">, </span><span class="s1">int</span><span class="s2">) </span><span class="s0">and </span><span class="s1">new_total_tokens </span><span class="s2">!= </span><span class="s1">math</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;total_tokens must be an int or math.inf&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">new_total_tokens </span><span class="s2">&lt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;total_tokens must be &gt;= 1&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens </span><span class="s2">= </span><span class="s1">new_total_tokens</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_wake_waiters</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_wake_waiters</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">available </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">woken </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">unpark</span><span class="s2">(</span><span class="s1">count</span><span class="s2">=</span><span class="s1">available</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pending_borrowers</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">woken</span><span class="s2">))</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">borrowed_tokens</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The amount of capacity that's currently in use.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">available_tokens</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The amount of capacity that's available to use.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">total_tokens </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">borrowed_tokens</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">acquire_nowait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Borrow a token from the sack, without blocking. 
 
        Raises: 
          WouldBlock: if no tokens are available. 
          RuntimeError: if the current task already holds one of this sack's 
              tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">acquire_on_behalf_of_nowait</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">())</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">acquire_on_behalf_of_nowait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Borrow a token from the sack on behalf of ``borrower``, without 
        blocking. 
 
        Args: 
          borrower: A :class:`trio.lowlevel.Task` or arbitrary opaque object 
             used to record who is borrowing this token. This is used by 
             :func:`trio.to_thread.run_sync` to allow threads to &quot;hold 
             tokens&quot;, with the intention in the future of using it to `allow 
             deadlock detection and other useful things 
             &lt;https://github.com/python-trio/trio/issues/182&gt;`__ 
 
        Raises: 
          WouldBlock: if no tokens are available. 
          RuntimeError: if ``borrower`` already holds one of this sack's 
              tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">borrower </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s5">&quot;this borrower is already holding one of this CapacityLimiter's tokens&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">borrower</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">acquire</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Borrow a token from the sack, blocking if necessary. 
 
        Raises: 
          RuntimeError: if the current task already holds one of this sack's 
              tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">acquire_on_behalf_of</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">())</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">acquire_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Borrow a token from the sack on behalf of ``borrower``, blocking if 
        necessary. 
 
        Args: 
          borrower: A :class:`trio.lowlevel.Task` or arbitrary opaque object 
             used to record who is borrowing this token; see 
             :meth:`acquire_on_behalf_of_nowait` for details. 
 
        Raises: 
          RuntimeError: if ``borrower`` task already holds one of this sack's 
             tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">acquire_on_behalf_of_nowait</span><span class="s2">(</span><span class="s1">borrower</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span><span class="s2">:</span>
            <span class="s1">task </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_pending_borrowers</span><span class="s2">[</span><span class="s1">task</span><span class="s2">] = </span><span class="s1">borrower</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">park</span><span class="s2">()</span>
            <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_pending_borrowers</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">task</span><span class="s2">)</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">release</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Put a token back into the sack. 
 
        Raises: 
          RuntimeError: if the current task has not acquired one of this 
              sack's tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">release_on_behalf_of</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">())</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">release_on_behalf_of</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">borrower</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Put a token back into the sack on behalf of ``borrower``. 
 
        Raises: 
          RuntimeError: if the given borrower has not acquired one of this 
              sack's tokens. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">borrower </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s5">&quot;this borrower isn't holding any of this CapacityLimiter's tokens&quot;</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">.</span><span class="s1">remove</span><span class="s2">(</span><span class="s1">borrower</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_wake_waiters</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">statistics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return an object containing debugging information. 
 
        Currently the following fields are defined: 
 
        * ``borrowed_tokens``: The number of tokens currently borrowed from 
          the sack. 
        * ``total_tokens``: The total number of tokens in the sack. Usually 
          this will be larger than ``borrowed_tokens``, but it's possibly for 
          it to be smaller if :attr:`total_tokens` was recently decreased. 
        * ``borrowers``: A list of all tasks or other entities that currently 
          hold a token. 
        * ``tasks_waiting``: The number of tasks blocked on this 
          :class:`CapacityLimiter`\'s :meth:`acquire` or 
          :meth:`acquire_on_behalf_of` methods. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_CapacityLimiterStatistics</span><span class="s2">(</span>
            <span class="s1">borrowed_tokens</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">),</span>
            <span class="s1">total_tokens</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_total_tokens</span><span class="s2">,</span>
            <span class="s4"># Use a list instead of a frozenset just in case we start to allow</span>
            <span class="s4"># one borrower to hold multiple tokens in the future</span>
            <span class="s1">borrowers</span><span class="s2">=</span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_borrowers</span><span class="s2">),</span>
            <span class="s1">tasks_waiting</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">),</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">Semaphore</span><span class="s2">(</span><span class="s1">AsyncContextManagerMixin</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A `semaphore &lt;https://en.wikipedia.org/wiki/Semaphore_(programming)&gt;`__. 
 
    A semaphore holds an integer value, which can be incremented by 
    calling :meth:`release` and decremented by calling :meth:`acquire` – but 
    the value is never allowed to drop below zero. If the value is zero, then 
    :meth:`acquire` will block until someone calls :meth:`release`. 
 
    If you're looking for a :class:`Semaphore` to limit the number of tasks 
    that can access some resource simultaneously, then consider using a 
    :class:`CapacityLimiter` instead. 
 
    This object's interface is similar to, but different from, that of 
    :class:`threading.Semaphore`. 
 
    A :class:`Semaphore` object can be used as an async context manager; it 
    blocks on entry but not on exit. 
 
    Args: 
      initial_value (int): A non-negative integer giving semaphore's initial 
        value. 
      max_value (int or None): If given, makes this a &quot;bounded&quot; semaphore that 
        raises an error if the value is about to exceed the given 
        ``max_value``. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">initial_value</span><span class="s2">, *, </span><span class="s1">max_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">initial_value</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;initial_value must be an int&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">initial_value </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;initial value must be &gt;= 0&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">max_value </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">max_value</span><span class="s2">, </span><span class="s1">int</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;max_value must be None or an int&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">max_value </span><span class="s2">&lt; </span><span class="s1">initial_value</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;max_values must be &gt;= initial_value&quot;</span><span class="s2">)</span>

        <span class="s4"># Invariants:</span>
        <span class="s4"># bool(self._lot) implies self._value == 0</span>
        <span class="s4"># (or equivalently: self._value &gt; 0 implies not self._lot)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">ParkingLot</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s1">initial_value</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value </span><span class="s2">= </span><span class="s1">max_value</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">max_value_str </span><span class="s2">= </span><span class="s5">&quot;&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">max_value_str </span><span class="s2">= </span><span class="s5">f&quot;, max_value=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value</span><span class="s0">}</span><span class="s5">&quot;</span>
        <span class="s0">return </span><span class="s5">&quot;&lt;trio.Semaphore({}{}) at {:#x}&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">, </span><span class="s1">max_value_str</span><span class="s2">, </span><span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The current value of the semaphore.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">max_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The maximum allowed value. May be None to indicate no limit.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">acquire_nowait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Attempt to decrement the semaphore value, without blocking. 
 
        Raises: 
          WouldBlock: if the value is zero. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s0">assert not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">-= </span><span class="s6">1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">acquire</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Decrement the semaphore value, blocking if necessary to avoid 
        letting it drop below zero. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">acquire_nowait</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">park</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">release</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Increment the semaphore value, possibly waking a task blocked in 
        :meth:`acquire`. 
 
        Raises: 
          ValueError: if incrementing the value would cause it to exceed 
              :attr:`max_value`. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">== </span><span class="s6">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">unpark</span><span class="s2">(</span><span class="s1">count</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value </span><span class="s0">is not None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_value</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;semaphore released too many times&quot;</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">+= </span><span class="s6">1</span>

    <span class="s0">def </span><span class="s1">statistics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return an object containing debugging information. 
 
        Currently the following fields are defined: 
 
        * ``tasks_waiting``: The number of tasks blocked on this semaphore's 
          :meth:`acquire` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">statistics</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">frozen</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">_LockStatistics</span><span class="s2">:</span>
    <span class="s1">locked </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">owner </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">tasks_waiting </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">eq</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">hash</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">repr</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">_LockImpl</span><span class="s2">(</span><span class="s1">AsyncContextManagerMixin</span><span class="s2">):</span>
    <span class="s1">_lot </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">(</span><span class="s1">factory</span><span class="s2">=</span><span class="s1">ParkingLot</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">_owner </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">(</span><span class="s1">default</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">init</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locked</span><span class="s2">():</span>
            <span class="s1">s1 </span><span class="s2">= </span><span class="s5">&quot;locked&quot;</span>
            <span class="s1">s2 </span><span class="s2">= </span><span class="s5">f&quot; with </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">)</span><span class="s0">} </span><span class="s5">waiters&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">s1 </span><span class="s2">= </span><span class="s5">&quot;unlocked&quot;</span>
            <span class="s1">s2 </span><span class="s2">= </span><span class="s5">&quot;&quot;</span>
        <span class="s0">return </span><span class="s5">&quot;&lt;{} {} object at {:#x}{}&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span>
            <span class="s1">s1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">s2</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">locked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Check whether the lock is currently held. 
 
        Returns: 
          bool: True if the lock is held, False otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner </span><span class="s0">is not None</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">acquire_nowait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Attempt to acquire the lock, without blocking. 
 
        Raises: 
          WouldBlock: if the lock is held. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">task </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner </span><span class="s0">is </span><span class="s1">task</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;attempt to re-acquire an already held Lock&quot;</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner </span><span class="s0">is None and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">:</span>
            <span class="s4"># No-one owns it</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_owner </span><span class="s2">= </span><span class="s1">task</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">acquire</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Acquire the lock, blocking if necessary.&quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">checkpoint_if_cancelled</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">acquire_nowait</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">WouldBlock</span><span class="s2">:</span>
            <span class="s4"># NOTE: it's important that the contended acquire path is just</span>
            <span class="s4"># &quot;_lot.park()&quot;, because that's how Condition.wait() acquires the</span>
            <span class="s4"># lock as well.</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">park</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">cancel_shielded_checkpoint</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">release</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Release the lock. 
 
        Raises: 
          RuntimeError: if the calling task does not hold the lock. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">task </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;can't release a Lock you don't own&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">:</span>
            <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">,) = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">unpark</span><span class="s2">(</span><span class="s1">count</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_owner </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">statistics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return an object containing debugging information. 
 
        Currently the following fields are defined: 
 
        * ``locked``: boolean indicating whether the lock is held. 
        * ``owner``: the :class:`trio.lowlevel.Task` currently holding the lock, 
          or None if the lock is not held. 
        * ``tasks_waiting``: The number of tasks blocked on this lock's 
          :meth:`acquire` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_LockStatistics</span><span class="s2">(</span>
            <span class="s1">locked</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locked</span><span class="s2">(), </span><span class="s1">owner</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">, </span><span class="s1">tasks_waiting</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">)</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">Lock</span><span class="s2">(</span><span class="s1">_LockImpl</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A classic `mutex 
    &lt;https://en.wikipedia.org/wiki/Lock_(computer_science)&gt;`__. 
 
    This is a non-reentrant, single-owner lock. Unlike 
    :class:`threading.Lock`, only the owner of the lock is allowed to release 
    it. 
 
    A :class:`Lock` object can be used as an async context manager; it 
    blocks on entry but not on exit. 
 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">StrictFIFOLock</span><span class="s2">(</span><span class="s1">_LockImpl</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">r&quot;&quot;&quot;A variant of :class:`Lock` where tasks are guaranteed to acquire the 
    lock in strict first-come-first-served order. 
 
    An example of when this is useful is if you're implementing something like 
    :class:`trio.SSLStream` or an HTTP/2 server using `h2 
    &lt;https://hyper-h2.readthedocs.io/&gt;`__, where you have multiple concurrent 
    tasks that are interacting with a shared state machine, and at 
    unpredictable moments the state machine requests that a chunk of data be 
    sent over the network. (For example, when using h2 simply reading incoming 
    data can occasionally `create outgoing data to send 
    &lt;https://http2.github.io/http2-spec/#PING&gt;`__.) The challenge is to make 
    sure that these chunks are sent in the correct order, without being 
    garbled. 
 
    One option would be to use a regular :class:`Lock`, and wrap it around 
    every interaction with the state machine:: 
 
        # This approach is sometimes workable but often sub-optimal; see below 
        async with lock: 
            state_machine.do_something() 
            if state_machine.has_data_to_send(): 
                await conn.sendall(state_machine.get_data_to_send()) 
 
    But this can be problematic. If you're using h2 then *usually* reading 
    incoming data doesn't create the need to send any data, so we don't want 
    to force every task that tries to read from the network to sit and wait 
    a potentially long time for ``sendall`` to finish. And in some situations 
    this could even potentially cause a deadlock, if the remote peer is 
    waiting for you to read some data before it accepts the data you're 
    sending. 
 
    :class:`StrictFIFOLock` provides an alternative. We can rewrite our 
    example like:: 
 
        # Note: no awaits between when we start using the state machine and 
        # when we block to take the lock! 
        state_machine.do_something() 
        if state_machine.has_data_to_send(): 
            # Notice that we fetch the data to send out of the state machine 
            # *before* sleeping, so that other tasks won't see it. 
            chunk = state_machine.get_data_to_send() 
            async with strict_fifo_lock: 
                await conn.sendall(chunk) 
 
    First we do all our interaction with the state machine in a single 
    scheduling quantum (notice there are no ``await``\s in there), so it's 
    automatically atomic with respect to other tasks. And then if and only if 
    we have data to send, we get in line to send it – and 
    :class:`StrictFIFOLock` guarantees that each task will send its data in 
    the same order that the state machine generated it. 
 
    Currently, :class:`StrictFIFOLock` is identical to :class:`Lock`, 
    but (a) this may not always be true in the future, especially if Trio ever 
    implements `more sophisticated scheduling policies 
    &lt;https://github.com/python-trio/trio/issues/32&gt;`__, and (b) the above code 
    is relying on a pretty subtle property of its lock. Using a 
    :class:`StrictFIFOLock` acts as an executable reminder that you're relying 
    on this property. 
 
    &quot;&quot;&quot;</span>


<span class="s2">@</span><span class="s1">attr</span><span class="s2">.</span><span class="s1">s</span><span class="s2">(</span><span class="s1">frozen</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">_ConditionStatistics</span><span class="s2">:</span>
    <span class="s1">tasks_waiting </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>
    <span class="s1">lock_statistics </span><span class="s2">= </span><span class="s1">attr</span><span class="s2">.</span><span class="s1">ib</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">Condition</span><span class="s2">(</span><span class="s1">AsyncContextManagerMixin</span><span class="s2">, </span><span class="s1">metaclass</span><span class="s2">=</span><span class="s1">Final</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;A classic `condition variable 
    &lt;https://en.wikipedia.org/wiki/Monitor_(synchronization)&gt;`__, similar to 
    :class:`threading.Condition`. 
 
    A :class:`Condition` object can be used as an async context manager to 
    acquire the underlying lock; it blocks on entry but not on exit. 
 
    Args: 
      lock (Lock): the lock object to use. If given, must be a 
          :class:`trio.Lock`. If None, a new :class:`Lock` will be allocated 
          and used. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lock</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">lock </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">lock </span><span class="s2">= </span><span class="s1">Lock</span><span class="s2">()</span>
        <span class="s0">if not </span><span class="s1">type</span><span class="s2">(</span><span class="s1">lock</span><span class="s2">) </span><span class="s0">is </span><span class="s1">Lock</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;lock must be a trio.Lock&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lock </span><span class="s2">= </span><span class="s1">lock</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">ParkingLot</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">locked</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Check whether the underlying lock is currently held. 
 
        Returns: 
          bool: True if the lock is held, False otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">locked</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">acquire_nowait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Attempt to acquire the underlying lock, without blocking. 
 
        Raises: 
          WouldBlock: if the lock is currently held. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">acquire_nowait</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">acquire</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Acquire the underlying lock, blocking if necessary.&quot;&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">release</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Release the underlying lock.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">release</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">wait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Wait for another task to call :meth:`notify` or 
        :meth:`notify_all`. 
 
        When calling this method, you must hold the lock. It releases the lock 
        while waiting, and then re-acquires it before waking up. 
 
        There is a subtlety with how this method interacts with cancellation: 
        when cancelled it will block to re-acquire the lock before raising 
        :exc:`Cancelled`. This may cause cancellation to be less prompt than 
        expected. The advantage is that it makes code like this work:: 
 
           async with condition: 
               await condition.wait() 
 
        If we didn't re-acquire the lock before waking up, and :meth:`wait` 
        were cancelled here, then we'd crash in ``condition.__aexit__`` when 
        we tried to release the lock we no longer held. 
 
        Raises: 
          RuntimeError: if the calling task does not hold the lock. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">() </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;must hold the lock to wait&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">release</span><span class="s2">()</span>
        <span class="s4"># NOTE: we go to sleep on self._lot, but we'll wake up on</span>
        <span class="s4"># self._lock._lot. That's all that's required to acquire a Lock.</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">park</span><span class="s2">()</span>
        <span class="s0">except</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">(</span><span class="s1">shield</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">acquire</span><span class="s2">()</span>
            <span class="s0">raise</span>

    <span class="s0">def </span><span class="s1">notify</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Wake one or more tasks that are blocked in :meth:`wait`. 
 
        Args: 
          n (int): The number of tasks to wake. 
 
        Raises: 
          RuntimeError: if the calling task does not hold the lock. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">() </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;must hold the lock to notify&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">repark</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">, </span><span class="s1">count</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">notify_all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Wake all tasks that are currently blocked in :meth:`wait`. 
 
        Raises: 
          RuntimeError: if the calling task does not hold the lock. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">current_task</span><span class="s2">() </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">_owner</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s5">&quot;must hold the lock to notify&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">.</span><span class="s1">repark_all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">statistics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">r&quot;&quot;&quot;Return an object containing debugging information. 
 
        Currently the following fields are defined: 
 
        * ``tasks_waiting``: The number of tasks blocked on this condition's 
          :meth:`wait` method. 
        * ``lock_statistics``: The result of calling the underlying 
          :class:`Lock`\s  :meth:`~Lock.statistics` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_ConditionStatistics</span><span class="s2">(</span>
            <span class="s1">tasks_waiting</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lot</span><span class="s2">), </span><span class="s1">lock_statistics</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_lock</span><span class="s2">.</span><span class="s1">statistics</span><span class="s2">()</span>
        <span class="s2">)</span>
</pre>
</body>
</html>