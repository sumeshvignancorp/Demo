<html>
<head>
<title>monkeypatch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
monkeypatch.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Monkeypatching and mocking functionality.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">MutableMapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">_pytest</span><span class="s3">.</span><span class="s1">compat </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">_pytest</span><span class="s3">.</span><span class="s1">fixtures </span><span class="s2">import </span><span class="s1">fixture</span>
<span class="s2">from </span><span class="s1">_pytest</span><span class="s3">.</span><span class="s1">warning_types </span><span class="s2">import </span><span class="s1">PytestWarning</span>

<span class="s1">RE_IMPORT_ERROR_NAME </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r&quot;^No module named (.*)$&quot;</span><span class="s3">)</span>


<span class="s1">K </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;K&quot;</span><span class="s3">)</span>
<span class="s1">V </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;V&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">monkeypatch</span><span class="s3">() </span><span class="s1">-&gt; Generator</span><span class="s3">[</span><span class="s4">&quot;MonkeyPatch&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;A convenient fixture for monkey-patching. 
 
    The fixture provides these methods to modify objects, dictionaries, or 
    :data:`os.environ`: 
 
    * :meth:`monkeypatch.setattr(obj, name, value, raising=True) &lt;pytest.MonkeyPatch.setattr&gt;` 
    * :meth:`monkeypatch.delattr(obj, name, raising=True) &lt;pytest.MonkeyPatch.delattr&gt;` 
    * :meth:`monkeypatch.setitem(mapping, name, value) &lt;pytest.MonkeyPatch.setitem&gt;` 
    * :meth:`monkeypatch.delitem(obj, name, raising=True) &lt;pytest.MonkeyPatch.delitem&gt;` 
    * :meth:`monkeypatch.setenv(name, value, prepend=None) &lt;pytest.MonkeyPatch.setenv&gt;` 
    * :meth:`monkeypatch.delenv(name, raising=True) &lt;pytest.MonkeyPatch.delenv&gt;` 
    * :meth:`monkeypatch.syspath_prepend(path) &lt;pytest.MonkeyPatch.syspath_prepend&gt;` 
    * :meth:`monkeypatch.chdir(path) &lt;pytest.MonkeyPatch.chdir&gt;` 
    * :meth:`monkeypatch.context() &lt;pytest.MonkeyPatch.context&gt;` 
 
    All modifications will be undone after the requesting test function or 
    fixture has finished. The ``raising`` parameter determines if a :class:`KeyError` 
    or :class:`AttributeError` will be raised if the set/deletion operation does not have the 
    specified target. 
 
    To undo modifications done by the fixture in a contained scope, 
    use :meth:`context() &lt;pytest.MonkeyPatch.context&gt;`. 
    &quot;&quot;&quot;</span>
    <span class="s1">mpatch </span><span class="s3">= </span><span class="s1">MonkeyPatch</span><span class="s3">()</span>
    <span class="s2">yield </span><span class="s1">mpatch</span>
    <span class="s1">mpatch</span><span class="s3">.</span><span class="s1">undo</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; object</span><span class="s3">:</span>
    <span class="s5"># Simplified from zope.dottedname.</span>
    <span class="s1">parts </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">)</span>

    <span class="s1">used </span><span class="s3">= </span><span class="s1">parts</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">found</span><span class="s3">: </span><span class="s1">object </span><span class="s3">= </span><span class="s1">__import__</span><span class="s3">(</span><span class="s1">used</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts</span><span class="s3">:</span>
        <span class="s1">used </span><span class="s3">+= </span><span class="s4">&quot;.&quot; </span><span class="s3">+ </span><span class="s1">part</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">found </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">found</span><span class="s3">, </span><span class="s1">part</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s5"># We use explicit un-nesting of the handling block in order</span>
        <span class="s5"># to avoid nested exceptions.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">__import__</span><span class="s3">(</span><span class="s1">used</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">ex</span><span class="s3">:</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">ex</span><span class="s3">).</span><span class="s1">split</span><span class="s3">()[-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">expected </span><span class="s3">== </span><span class="s1">used</span><span class="s3">:</span>
                <span class="s2">raise</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span><span class="s4">f&quot;import error in </span><span class="s2">{</span><span class="s1">used</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">ex</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">ex</span>
        <span class="s1">found </span><span class="s3">= </span><span class="s1">annotated_getattr</span><span class="s3">(</span><span class="s1">found</span><span class="s3">, </span><span class="s1">part</span><span class="s3">, </span><span class="s1">used</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">found</span>


<span class="s2">def </span><span class="s1">annotated_getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">ann</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; object</span><span class="s3">:</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">obj </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span>
            <span class="s4">&quot;{!r} object at {} has no attribute {!r}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">type</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">ann</span><span class="s3">, </span><span class="s1">name</span>
            <span class="s3">)</span>
        <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">return </span><span class="s1">obj</span>


<span class="s2">def </span><span class="s1">derive_importpath</span><span class="s3">(</span><span class="s1">import_path</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]:</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">import_path</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">or </span><span class="s4">&quot;.&quot; </span><span class="s2">not in </span><span class="s1">import_path</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">f&quot;must be absolute import path string, not </span><span class="s2">{</span><span class="s1">import_path</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s1">module</span><span class="s3">, </span><span class="s1">attr </span><span class="s3">= </span><span class="s1">import_path</span><span class="s3">.</span><span class="s1">rsplit</span><span class="s3">(</span><span class="s4">&quot;.&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">target </span><span class="s3">= </span><span class="s1">resolve</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">raising</span><span class="s3">:</span>
        <span class="s1">annotated_getattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">ann</span><span class="s3">=</span><span class="s1">module</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">target</span>


<span class="s2">class </span><span class="s1">Notset</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;notset&gt;&quot;</span>


<span class="s1">notset </span><span class="s3">= </span><span class="s1">Notset</span><span class="s3">()</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">MonkeyPatch</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Helper to conveniently monkeypatch attributes/items/environment 
    variables/syspath. 
 
    Returned by the :fixture:`monkeypatch` fixture. 
 
    .. versionchanged:: 6.2 
        Can now also be used directly as `pytest.MonkeyPatch()`, for when 
        the fixture is not available. In this case, use 
        :meth:`with MonkeyPatch.context() as mp: &lt;context&gt;` or remember to call 
        :meth:`undo` explicitly. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setattr</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]] = []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setitem</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">], </span><span class="s1">object</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]] = []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]] = </span><span class="s2">None</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s3">@</span><span class="s1">contextmanager</span>
    <span class="s2">def </span><span class="s1">context</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s1">-&gt; Generator</span><span class="s3">[</span><span class="s4">&quot;MonkeyPatch&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Context manager that returns a new :class:`MonkeyPatch` object 
        which undoes any patching done inside the ``with`` block upon exit. 
 
        Example: 
 
        .. code-block:: python 
 
            import functools 
 
 
            def test_partial(monkeypatch): 
                with monkeypatch.context() as m: 
                    m.setattr(functools, &quot;partial&quot;, 3) 
 
        Useful in situations where it is desired to undo some patches before the test ends, 
        such as mocking ``stdlib`` functions that might break pytest itself if mocked (for examples 
        of this see :issue:`3290`). 
        &quot;&quot;&quot;</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">()</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">m</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">m</span><span class="s3">.</span><span class="s1">undo</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">setattr</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">object</span><span class="s3">,</span>
        <span class="s1">value</span><span class="s3">: </span><span class="s1">Notset </span><span class="s3">= ...,</span>
        <span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">setattr</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">object</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">value</span><span class="s3">: </span><span class="s1">object</span><span class="s3">,</span>
        <span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">setattr</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">],</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">str</span><span class="s3">],</span>
        <span class="s1">value</span><span class="s3">: </span><span class="s1">object </span><span class="s3">= </span><span class="s1">notset</span><span class="s3">,</span>
        <span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Set attribute value on target, memorizing the old value. 
 
        For example: 
 
        .. code-block:: python 
 
            import os 
 
            monkeypatch.setattr(os, &quot;getcwd&quot;, lambda: &quot;/&quot;) 
 
        The code above replaces the :func:`os.getcwd` function by a ``lambda`` which 
        always returns ``&quot;/&quot;``. 
 
        For convenience, you can specify a string as ``target`` which 
        will be interpreted as a dotted import path, with the last part 
        being the attribute name: 
 
        .. code-block:: python 
 
            monkeypatch.setattr(&quot;os.getcwd&quot;, lambda: &quot;/&quot;) 
 
        Raises :class:`AttributeError` if the attribute does not exist, unless 
        ``raising`` is set to False. 
 
        **Where to patch** 
 
        ``monkeypatch.setattr`` works by (temporarily) changing the object that a name points to with another one. 
        There can be many names pointing to any individual object, so for patching to work you must ensure 
        that you patch the name used by the system under test. 
 
        See the section :ref:`Where to patch &lt;python:where-to-patch&gt;` in the :mod:`unittest.mock` 
        docs for a complete explanation, which is meant for :func:`unittest.mock.patch` but 
        applies to ``monkeypatch.setattr`` as well. 
        &quot;&quot;&quot;</span>
        <span class="s1">__tracebackhide__ </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">import </span><span class="s1">inspect</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">Notset</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">&quot;use setattr(target, name, value) or &quot;</span>
                    <span class="s4">&quot;setattr(target, value) with target being a dotted &quot;</span>
                    <span class="s4">&quot;import string&quot;</span>
                <span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">name</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">target </span><span class="s3">= </span><span class="s1">derive_importpath</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">&quot;use setattr(target, name, value) with name being a string or &quot;</span>
                    <span class="s4">&quot;setattr(target, value) with target being a dotted &quot;</span>
                    <span class="s4">&quot;import string&quot;</span>
                <span class="s3">)</span>

        <span class="s1">oldval </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">raising </span><span class="s2">and </span><span class="s1">oldval </span><span class="s2">is </span><span class="s1">notset</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">target</span><span class="s2">!r} </span><span class="s4">has no attribute </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>

        <span class="s5"># avoid class descriptors like staticmethod/classmethod</span>
        <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isclass</span><span class="s3">(</span><span class="s1">target</span><span class="s3">):</span>
            <span class="s1">oldval </span><span class="s3">= </span><span class="s1">target</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setattr</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">oldval</span><span class="s3">))</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">delattr</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">target</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">str</span><span class="s3">],</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Notset</span><span class="s3">] = </span><span class="s1">notset</span><span class="s3">,</span>
        <span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Delete attribute ``name`` from ``target``. 
 
        If no ``name`` is specified and ``target`` is a string 
        it will be interpreted as a dotted import path with the 
        last part being the attribute name. 
 
        Raises AttributeError it the attribute does not exist, unless 
        ``raising`` is set to False. 
        &quot;&quot;&quot;</span>
        <span class="s1">__tracebackhide__ </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">import </span><span class="s1">inspect</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Notset</span><span class="s3">):</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                    <span class="s4">&quot;use delattr(target, name) or &quot;</span>
                    <span class="s4">&quot;delattr(target) with target being a dotted &quot;</span>
                    <span class="s4">&quot;import string&quot;</span>
                <span class="s3">)</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">target </span><span class="s3">= </span><span class="s1">derive_importpath</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">raising</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">oldval </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)</span>
            <span class="s5"># Avoid class descriptors like staticmethod/classmethod.</span>
            <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isclass</span><span class="s3">(</span><span class="s1">target</span><span class="s3">):</span>
                <span class="s1">oldval </span><span class="s3">= </span><span class="s1">target</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_setattr</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">oldval</span><span class="s3">))</span>
            <span class="s1">delattr</span><span class="s3">(</span><span class="s1">target</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dic</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">K</span><span class="s3">, </span><span class="s1">V</span><span class="s3">], </span><span class="s1">name</span><span class="s3">: </span><span class="s1">K</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">V</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Set dictionary entry ``name`` to value.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setitem</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">dic</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">dic</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)))</span>
        <span class="s5"># Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict</span>
        <span class="s1">dic</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">value  </span><span class="s5"># type: ignore[index]</span>

    <span class="s2">def </span><span class="s1">delitem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dic</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">K</span><span class="s3">, </span><span class="s1">V</span><span class="s3">], </span><span class="s1">name</span><span class="s3">: </span><span class="s1">K</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Delete ``name`` from dict. 
 
        Raises ``KeyError`` if it doesn't exist, unless ``raising`` is set to 
        False. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">dic</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">raising</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">KeyError</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_setitem</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">dic</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">dic</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">notset</span><span class="s3">)))</span>
            <span class="s5"># Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict</span>
            <span class="s2">del </span><span class="s1">dic</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]  </span><span class="s5"># type: ignore[attr-defined]</span>

    <span class="s2">def </span><span class="s1">setenv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">prepend</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Set environment variable ``name`` to ``value``. 
 
        If ``prepend`` is a character, read the current environment variable 
        value and prepend the ``value`` adjoined with the ``prepend`` 
        character. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(  </span><span class="s5"># type: ignore[unreachable]</span>
                <span class="s1">PytestWarning</span><span class="s3">(</span>
                    <span class="s4">&quot;Value of environment variable {name} type should be str, but got &quot;</span>
                    <span class="s4">&quot;{value!r} (type: {type}); converted to str implicitly&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">=</span><span class="s1">value</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s1">type</span><span class="s3">(</span><span class="s1">value</span><span class="s3">).</span><span class="s1">__name__</span>
                    <span class="s3">)</span>
                <span class="s3">),</span>
                <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">prepend </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">:</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">value </span><span class="s3">+ </span><span class="s1">prepend </span><span class="s3">+ </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">setitem</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">delenv</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Delete ``name`` from the environment. 
 
        Raises ``KeyError`` if it does not exist, unless ``raising`` is set to 
        False. 
        &quot;&quot;&quot;</span>
        <span class="s1">environ</span><span class="s3">: </span><span class="s1">MutableMapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">] = </span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">delitem</span><span class="s3">(</span><span class="s1">environ</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">raising</span><span class="s3">=</span><span class="s1">raising</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">syspath_prepend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Prepend ``path`` to ``sys.path`` list of import locations.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span><span class="s3">[:]</span>
        <span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">str</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>

        <span class="s5"># https://github.com/pypa/setuptools/blob/d8b901bc/docs/pkg_resources.txt#L162-L171</span>
        <span class="s5"># this is only needed when pkg_resources was already loaded by the namespace package</span>
        <span class="s2">if </span><span class="s4">&quot;pkg_resources&quot; </span><span class="s2">in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s1">pkg_resources </span><span class="s2">import </span><span class="s1">fixup_namespace_packages</span>

            <span class="s1">fixup_namespace_packages</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">path</span><span class="s3">))</span>

        <span class="s5"># A call to syspathinsert() usually means that the caller wants to</span>
        <span class="s5"># import some dynamically created files, thus with python3 we</span>
        <span class="s5"># invalidate its import caches.</span>
        <span class="s5"># This is especially important when any namespace package is in use,</span>
        <span class="s5"># since then the mtime based FileFinder cache (that gets created in</span>
        <span class="s5"># this case already) gets not invalidated when writing the new files</span>
        <span class="s5"># quickly afterwards.</span>
        <span class="s2">from </span><span class="s1">importlib </span><span class="s2">import </span><span class="s1">invalidate_caches</span>

        <span class="s1">invalidate_caches</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">chdir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s4">&quot;os.PathLike[str]&quot;</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Change the current working directory to the specified path. 
 
        :param path: 
            The path to change into. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getcwd</span><span class="s3">()</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">chdir</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">undo</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Undo previous changes. 
 
        This call consumes the undo stack. Calling it a second time has no 
        effect unless you do more monkeypatching after the undo call. 
 
        There is generally no need to call `undo()`, since it is 
        called automatically during tear-down. 
 
        .. note:: 
            The same `monkeypatch` fixture is used across a 
            single test function invocation. If `monkeypatch` is used both by 
            the test function itself and one of the test fixtures, 
            calling `undo()` will undo all of the changes made in 
            both functions. 
 
            Prefer to use :meth:`context() &lt;pytest.MonkeyPatch.context&gt;` instead. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_setattr</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is not </span><span class="s1">notset</span><span class="s3">:</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">delattr</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setattr</span><span class="s3">[:] = []</span>
        <span class="s2">for </span><span class="s1">dictionary</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_setitem</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s2">is </span><span class="s1">notset</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s5"># Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict</span>
                    <span class="s2">del </span><span class="s1">dictionary</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]  </span><span class="s5"># type: ignore[attr-defined]</span>
                <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                    <span class="s2">pass  </span><span class="s5"># Was already deleted, so we have the desired state.</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># Not all Mapping types support indexing, but MutableMapping doesn't support TypedDict</span>
                <span class="s1">dictionary</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value  </span><span class="s5"># type: ignore[index]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setitem</span><span class="s3">[:] = []</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span><span class="s3">[:] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_savesyspath </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">os</span><span class="s3">.</span><span class="s1">chdir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_cwd </span><span class="s3">= </span><span class="s2">None</span>
</pre>
</body>
</html>