<html>
<head>
<title>vengine_gen.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vengine_gen.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># DEPRECATED: implementation for ffi.verify()</span>
<span class="s0">#</span>
<span class="s2">import </span><span class="s1">sys</span><span class="s3">, </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">types</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">model</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">error </span><span class="s2">import </span><span class="s1">VerificationError</span>


<span class="s2">class </span><span class="s1">VGenericEngine</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s1">_class_key </span><span class="s3">= </span><span class="s4">'g'</span>
    <span class="s1">_gen_python_module </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">verifier</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">verifier </span><span class="s3">= </span><span class="s1">verifier</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi </span><span class="s3">= </span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">ffi</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">patch_extension_kwds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s0"># add 'export_symbols' to the dictionary.  Note that we add the</span>
        <span class="s0"># list before filling it.  When we fill it, it will thus also show</span>
        <span class="s0"># up in kwds['export_symbols'].</span>
        <span class="s1">kwds</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">'export_symbols'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">find_module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">so_suffixes</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">so_suffix </span><span class="s2">in </span><span class="s1">so_suffixes</span><span class="s3">:</span>
            <span class="s1">basename </span><span class="s3">= </span><span class="s1">module_name </span><span class="s3">+ </span><span class="s1">so_suffix</span>
            <span class="s2">if </span><span class="s1">path </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">path </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">path</span>
            <span class="s2">for </span><span class="s1">dirname </span><span class="s2">in </span><span class="s1">path</span><span class="s3">:</span>
                <span class="s1">filename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">, </span><span class="s1">basename</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">):</span>
                    <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">collect_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass      </span><span class="s0"># not needed in the generic engine</span>

    <span class="s2">def </span><span class="s1">_prnt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">what</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s1">what </span><span class="s3">+ </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">write_source_to_f</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s0"># first paste some standard set of lines that are mostly '#include'</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s1">cffimod_header</span><span class="s3">)</span>
        <span class="s0"># then paste the C source given by the user, verbatim.</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">preamble</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># call generate_gen_xxx_decl(), for every xxx found from</span>
        <span class="s0"># ffi._parser._declarations.  This generates all the functions.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate</span><span class="s3">(</span><span class="s4">'decl'</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># on Windows, distutils insists on putting init_cffi_xyz in</span>
        <span class="s0"># 'export_symbols', so instead of fighting it, just give up and</span>
        <span class="s0"># give it one</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">'win32'</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">,):</span>
                <span class="s1">prefix </span><span class="s3">= </span><span class="s4">'PyInit_'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">prefix </span><span class="s3">= </span><span class="s4">'init'</span>
            <span class="s1">modname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">get_module_name</span><span class="s3">()</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">&quot;void %s%s(void) { }</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">modname</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">load_library</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s0"># import it with the CFFI backend</span>
        <span class="s1">backend </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_backend</span>
        <span class="s0"># needs to make a path that contains '/', on Posix</span>
        <span class="s1">filename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">curdir</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">verifier</span><span class="s3">.</span><span class="s1">modulefilename</span><span class="s3">)</span>
        <span class="s1">module </span><span class="s3">= </span><span class="s1">backend</span><span class="s3">.</span><span class="s1">load_library</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># call loading_gen_struct() to get the struct layout inferred by</span>
        <span class="s0"># the C compiler</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_load</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">'loading'</span><span class="s3">)</span>

        <span class="s0"># build the FFILibrary class and instance, this is a module subclass</span>
        <span class="s0"># because modules are expected to have usually-constant-attributes and</span>
        <span class="s0"># in PyPy this means the JIT is able to treat attributes as constant,</span>
        <span class="s0"># which we want.</span>
        <span class="s2">class </span><span class="s1">FFILibrary</span><span class="s3">(</span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
            <span class="s1">_cffi_generic_module </span><span class="s3">= </span><span class="s1">module</span>
            <span class="s1">_cffi_ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
            <span class="s1">_cffi_dir </span><span class="s3">= []</span>
            <span class="s2">def </span><span class="s1">__dir__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">FFILibrary</span><span class="s3">.</span><span class="s1">_cffi_dir</span>
        <span class="s1">library </span><span class="s3">= </span><span class="s1">FFILibrary</span><span class="s3">(</span><span class="s4">&quot;&quot;</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s0"># finally, call the loaded_gen_xxx() functions.  This will set</span>
        <span class="s0"># up the 'library' object.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_load</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s4">'loaded'</span><span class="s3">, </span><span class="s1">library</span><span class="s3">=</span><span class="s1">library</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">library</span>

    <span class="s2">def </span><span class="s1">_get_declarations</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">lst </span><span class="s3">= [(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">) </span><span class="s2">for </span><span class="s3">(</span><span class="s1">key</span><span class="s3">, (</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">qual</span><span class="s3">)) </span><span class="s2">in</span>
                                <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_parser</span><span class="s3">.</span><span class="s1">_declarations</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()]</span>
        <span class="s1">lst</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">lst</span>

    <span class="s2">def </span><span class="s1">_generate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">step_name</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_declarations</span><span class="s3">():</span>
            <span class="s1">kind</span><span class="s3">, </span><span class="s1">realname </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">'_generate_gen_%s_%s' </span><span class="s3">% (</span><span class="s1">kind</span><span class="s3">,</span>
                                                                <span class="s1">step_name</span><span class="s3">))</span>
            <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                    <span class="s4">&quot;not implemented in verify(): %r&quot; </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">realname</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">model</span><span class="s3">.</span><span class="s1">attach_exception_info</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_load</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">step_name</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_declarations</span><span class="s3">():</span>
            <span class="s1">kind</span><span class="s3">, </span><span class="s1">realname </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">method </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s4">'_%s_gen_%s' </span><span class="s3">% (</span><span class="s1">step_name</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">))</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">method</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">realname</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">model</span><span class="s3">.</span><span class="s1">attach_exception_info</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">_generate_nothing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_loaded_noop</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s0"># ----------</span>
    <span class="s0"># typedefs: generates no code so far</span>

    <span class="s1">_generate_gen_typedef_decl   </span><span class="s3">= </span><span class="s1">_generate_nothing</span>
    <span class="s1">_loading_gen_typedef         </span><span class="s3">= </span><span class="s1">_loaded_noop</span>
    <span class="s1">_loaded_gen_typedef          </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s0"># ----------</span>
    <span class="s0"># function declarations</span>

    <span class="s2">def </span><span class="s1">_generate_gen_function_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s0"># cannot support vararg functions better than this: check for its</span>
            <span class="s0"># exact type (including the fixed arguments), and build it as a</span>
            <span class="s0"># constant function pointer (no _cffi_f_%s wrapper)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">numargs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">argnames </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">type </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">indirection </span><span class="s3">= </span><span class="s4">''</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">type</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                <span class="s1">indirection </span><span class="s3">= </span><span class="s4">'*'</span>
            <span class="s1">argnames</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'%sx%d' </span><span class="s3">% (</span><span class="s1">indirection</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s4">'argument of %s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s1">arglist </span><span class="s3">= [</span><span class="s1">type</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' %s' </span><span class="s3">% </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">context</span><span class="s3">)</span>
                   <span class="s2">for </span><span class="s1">type</span><span class="s3">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, </span><span class="s1">argnames</span><span class="s3">)]</span>
        <span class="s1">tpresult </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tpresult</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
            <span class="s1">arglist</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">tpresult</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' *r'</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>
            <span class="s1">tpresult </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">void_type</span>
        <span class="s1">arglist </span><span class="s3">= </span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">arglist</span><span class="s3">) </span><span class="s2">or </span><span class="s4">'void'</span>
        <span class="s1">wrappername </span><span class="s3">= </span><span class="s4">'_cffi_f_%s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">wrappername</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">abi</span><span class="s3">:</span>
            <span class="s1">abi </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">abi </span><span class="s3">+ </span><span class="s4">' '</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">abi </span><span class="s3">= </span><span class="s4">''</span>
        <span class="s1">funcdecl </span><span class="s3">= </span><span class="s4">' %s%s(%s)' </span><span class="s3">% (</span><span class="s1">abi</span><span class="s3">, </span><span class="s1">wrappername</span><span class="s3">, </span><span class="s1">arglist</span><span class="s3">)</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s4">'result of %s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s1">tpresult</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s1">funcdecl</span><span class="s3">, </span><span class="s1">context</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
            <span class="s1">result_code </span><span class="s3">= </span><span class="s4">'*r = '</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">VoidType</span><span class="s3">):</span>
            <span class="s1">result_code </span><span class="s3">= </span><span class="s4">'return '</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result_code </span><span class="s3">= </span><span class="s4">''</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s%s(%s);' </span><span class="s3">% (</span><span class="s1">result_code</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">argnames</span><span class="s3">)))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s1">_loading_gen_function </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_function</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">:</span>
            <span class="s1">newfunction </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">indirections </span><span class="s3">= []</span>
            <span class="s1">base_tp </span><span class="s3">= </span><span class="s1">tp</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">any</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">) </span><span class="s2">for </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">)</span>
                    <span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">)):</span>
                <span class="s1">indirect_args </span><span class="s3">= []</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">args</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                        <span class="s1">typ </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
                        <span class="s1">indirections</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">i</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">))</span>
                    <span class="s1">indirect_args</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">typ</span><span class="s3">)</span>
                <span class="s1">indirect_result </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">result</span>
                <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">indirect_result</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">indirect_result</span><span class="s3">.</span><span class="s1">fldtypes </span><span class="s2">is None</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;'%s' is used as result type, &quot;</span>
                                        <span class="s4">&quot;but is opaque&quot; </span><span class="s3">% (</span>
                                            <span class="s1">indirect_result</span><span class="s3">.</span><span class="s1">_get_c_name</span><span class="s3">(),))</span>
                    <span class="s1">indirect_result </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">indirect_result</span><span class="s3">)</span>
                    <span class="s1">indirect_args</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">indirect_result</span><span class="s3">)</span>
                    <span class="s1">indirections</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, (</span><span class="s4">&quot;result&quot;</span><span class="s3">, </span><span class="s1">indirect_result</span><span class="s3">))</span>
                    <span class="s1">indirect_result </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">void_type</span>
                <span class="s1">tp </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">FunctionPtrType</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">indirect_args</span><span class="s3">),</span>
                                           <span class="s1">indirect_result</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">ellipsis</span><span class="s3">)</span>
            <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">wrappername </span><span class="s3">= </span><span class="s4">'_cffi_f_%s' </span><span class="s3">% </span><span class="s1">name</span>
            <span class="s1">newfunction </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">wrappername</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">typ </span><span class="s2">in </span><span class="s1">indirections</span><span class="s3">:</span>
                <span class="s1">newfunction </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_struct_wrapper</span><span class="s3">(</span><span class="s1">newfunction</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">typ</span><span class="s3">,</span>
                                                        <span class="s1">base_tp</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">newfunction</span><span class="s3">)</span>
        <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_make_struct_wrapper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">oldfunc</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">base_tp</span><span class="s3">):</span>
        <span class="s1">backend </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_backend</span>
        <span class="s1">BType </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s4">&quot;result&quot;</span><span class="s3">:</span>
            <span class="s1">ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
            <span class="s2">def </span><span class="s1">newfunc</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">new</span><span class="s3">(</span><span class="s1">BType</span><span class="s3">)</span>
                <span class="s1">oldfunc</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">res</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">newfunc</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
                <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">] + (</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">newp</span><span class="s3">(</span><span class="s1">BType</span><span class="s3">, </span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]),) + </span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:]</span>
                <span class="s2">return </span><span class="s1">oldfunc</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">newfunc</span><span class="s3">.</span><span class="s1">_cffi_base_type </span><span class="s3">= </span><span class="s1">base_tp</span>
        <span class="s2">return </span><span class="s1">newfunc</span>

    <span class="s0"># ----------</span>
    <span class="s0"># named structs</span>

    <span class="s2">def </span><span class="s1">_generate_gen_struct_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">name </span><span class="s3">== </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'struct'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loading_gen_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'struct'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_struct</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_gen_union_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">name </span><span class="s3">== </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'union'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loading_gen_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">'union'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">checkfuncname </span><span class="s3">= </span><span class="s4">'_cffi_check_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">layoutfuncname </span><span class="s3">= </span><span class="s4">'_cffi_layout_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">cname </span><span class="s3">= (</span><span class="s4">'%s %s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)).</span><span class="s1">strip</span><span class="s3">()</span>
        <span class="s0">#</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'static void %s(%s *p)' </span><span class="s3">% (</span><span class="s1">checkfuncname</span><span class="s3">, </span><span class="s1">cname</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* only to generate compile-time warnings or errors */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)p;'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">)</span>
                <span class="s2">and </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()) </span><span class="s2">or </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s0"># accept all integers, but complain on float or double</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  (void)((p-&gt;%s) &lt;&lt; 1);' </span><span class="s3">% </span><span class="s1">fname</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># only accept exactly the type declared.</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  { %s = &amp;p-&gt;%s; (void)tmp; }' </span><span class="s3">% (</span>
                        <span class="s1">ftype</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">'*tmp'</span><span class="s3">, </span><span class="s4">'field %r'</span><span class="s3">%</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">quals</span><span class="s3">=</span><span class="s1">fqual</span><span class="s3">),</span>
                        <span class="s1">fname</span><span class="s3">))</span>
                <span class="s2">except </span><span class="s1">VerificationError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* %s */' </span><span class="s3">% </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">))   </span><span class="s0"># cannot verify it, ignore</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">layoutfuncname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'intptr_t %s(intptr_t i)' </span><span class="s3">% (</span><span class="s1">layoutfuncname</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  struct _cffi_aligncheck { char x; %s y; };' </span><span class="s3">% </span><span class="s1">cname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  static intptr_t nums[] = {'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    sizeof(%s),' </span><span class="s3">% </span><span class="s1">cname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    offsetof(struct _cffi_aligncheck, y),'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s2">continue      </span><span class="s0"># xxx ignore fbitsize for now</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    offsetof(%s, %s),' </span><span class="s3">% (</span><span class="s1">cname</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">length </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    0,  /* %s */' </span><span class="s3">% </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">_get_c_name</span><span class="s3">())</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    sizeof(((%s *)0)-&gt;%s),' </span><span class="s3">% (</span><span class="s1">cname</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    -1'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  };'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return nums[i];'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  /* the next line is not executed, but compiled */'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  %s(0);' </span><span class="s3">% (</span><span class="s1">checkfuncname</span><span class="s3">,))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">layoutfuncname </span><span class="s3">= </span><span class="s4">'_cffi_layout_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s0">#</span>
        <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;intptr_t(*)(intptr_t)&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">layoutfuncname</span><span class="s3">)</span>
        <span class="s1">layout </span><span class="s3">= []</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">function</span><span class="s3">(</span><span class="s1">num</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">: </span><span class="s2">break</span>
            <span class="s1">layout</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">num </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s0"># use the function()'s sizes and offsets to guide the</span>
            <span class="s0"># layout of the struct</span>
            <span class="s1">totalsize </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">totalalignment </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">fieldofs </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">2</span><span class="s3">::</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">fieldsize </span><span class="s3">= </span><span class="s1">layout</span><span class="s3">[</span><span class="s5">3</span><span class="s3">::</span><span class="s5">2</span><span class="s3">]</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">force_flatten</span><span class="s3">()</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fieldofs</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fieldsize</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames</span><span class="s3">)</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">fixedlayout </span><span class="s3">= </span><span class="s1">fieldofs</span><span class="s3">, </span><span class="s1">fieldsize</span><span class="s3">, </span><span class="s1">totalsize</span><span class="s3">, </span><span class="s1">totalalignment</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">cname </span><span class="s3">= (</span><span class="s4">'%s %s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)).</span><span class="s1">strip</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">[</span><span class="s1">tp</span><span class="s3">] = </span><span class="s1">layout</span><span class="s3">, </span><span class="s1">cname</span>

    <span class="s2">def </span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">fldnames </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return     </span><span class="s0"># nothing to do with opaque structs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)   </span><span class="s0"># force 'fixedlayout' to be considered</span>

        <span class="s2">if </span><span class="s1">tp </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">:</span>
            <span class="s0"># check that the layout sizes and offsets match the real ones</span>
            <span class="s2">def </span><span class="s1">check</span><span class="s3">(</span><span class="s1">realvalue</span><span class="s3">, </span><span class="s1">expectedvalue</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">realvalue </span><span class="s3">!= </span><span class="s1">expectedvalue</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                        <span class="s4">&quot;%s (we have %d, but C compiler says %d)&quot;</span>
                        <span class="s3">% (</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">expectedvalue</span><span class="s3">, </span><span class="s1">realvalue</span><span class="s3">))</span>
            <span class="s1">ffi </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span>
            <span class="s1">BStruct </span><span class="s3">= </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">layout</span><span class="s3">, </span><span class="s1">cname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_struct_pending_verification</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">), </span><span class="s4">&quot;wrong total size&quot;</span><span class="s3">)</span>
            <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">alignof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">), </span><span class="s4">&quot;wrong total alignment&quot;</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">2</span>
            <span class="s2">for </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fbitsize</span><span class="s3">, </span><span class="s1">fqual </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumfields</span><span class="s3">():</span>
                <span class="s2">if </span><span class="s1">fbitsize </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">continue        </span><span class="s0"># xxx ignore fbitsize for now</span>
                <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">offsetof</span><span class="s3">(</span><span class="s1">BStruct</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">),</span>
                      <span class="s4">&quot;wrong offset for field %r&quot; </span><span class="s3">% (</span><span class="s1">fname</span><span class="s3">,))</span>
                <span class="s2">if </span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">BField </span><span class="s3">= </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">)</span>
                    <span class="s1">check</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BField</span><span class="s3">),</span>
                          <span class="s4">&quot;wrong size for field %r&quot; </span><span class="s3">% (</span><span class="s1">fname</span><span class="s3">,))</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s5">2</span>
            <span class="s2">assert </span><span class="s1">i </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">layout</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># 'anonymous' declarations.  These are produced for anonymous structs</span>
    <span class="s0"># or unions; the 'name' is obtained by a typedef.</span>

    <span class="s2">def </span><span class="s1">_generate_gen_anonymous_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_enum_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_struct_or_union_decl</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loading_gen_anonymous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_gen_enum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loading_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_anonymous</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">EnumType</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_gen_enum</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, **</span><span class="s1">kwds</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_loaded_struct_or_union</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># constants, likely declared with '#define'</span>

    <span class="s2">def </span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s4">'const'</span><span class="s3">,</span>
                            <span class="s1">check_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_%s_%s' </span><span class="s3">% (</span><span class="s1">category</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">check_value </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">is_int</span>
            <span class="s2">assert </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'const'</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'int %s(char *out_error)' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">check_value</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return 0;'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_int</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'const'</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'int %s(long long *out_value)' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  *out_value = (long long)(%s);' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return (%s) &lt;= 0;' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">tp </span><span class="s2">is not None</span>
            <span class="s2">assert </span><span class="s1">check_value </span><span class="s2">is None</span>
            <span class="s2">if </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'var'</span><span class="s3">:</span>
                <span class="s1">ampersand </span><span class="s3">= </span><span class="s4">'&amp;'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">ampersand </span><span class="s3">= </span><span class="s4">''</span>
            <span class="s1">extra </span><span class="s3">= </span><span class="s4">''</span>
            <span class="s2">if </span><span class="s1">category </span><span class="s3">== </span><span class="s4">'const' </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                <span class="s1">extra </span><span class="s3">= </span><span class="s4">'const *'</span>
                <span class="s1">ampersand </span><span class="s3">= </span><span class="s4">'&amp;'</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">' %s%s(void)' </span><span class="s3">% (</span><span class="s1">extra</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">), </span><span class="s1">name</span><span class="s3">))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return (%s%s);' </span><span class="s3">% (</span><span class="s1">ampersand</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_generate_gen_constant_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">is_int </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">)</span>

    <span class="s1">_loading_gen_constant </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">check_value</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_const_%s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">check_value </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">is_int</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_load_known_int_constant</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">check_value</span>
        <span class="s2">elif </span><span class="s1">is_int</span><span class="s3">:</span>
            <span class="s1">BType </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;long long*&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;int(*)(long long*)&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
            <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">new</span><span class="s3">(</span><span class="s1">BType</span><span class="s3">)</span>
            <span class="s1">negative </span><span class="s3">= </span><span class="s1">function</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">negative</span><span class="s3">:</span>
                <span class="s1">BLongLong </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;long long&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">value </span><span class="s3">+= (</span><span class="s5">1 </span><span class="s3">&lt;&lt; (</span><span class="s5">8</span><span class="s3">*</span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BLongLong</span><span class="s3">)))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">check_value </span><span class="s2">is None</span>
            <span class="s1">fntypeextra </span><span class="s3">= </span><span class="s4">'(*)(void)'</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                <span class="s1">fntypeextra </span><span class="s3">= </span><span class="s4">'*' </span><span class="s3">+ </span><span class="s1">fntypeextra</span>
            <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s1">fntypeextra</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">function</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">StructOrUnion</span><span class="s3">):</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">value</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s1">is_int </span><span class="s3">= </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PrimitiveType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">is_integer_type</span><span class="s3">()</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s1">is_int</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># enums</span>

    <span class="s2">def </span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if ((%s) &gt; 0 || (long)(%s) != %dL) {' </span><span class="s3">% (</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  if ((%s) &lt;= 0 || (unsigned long)(%s) != %dUL) {' </span><span class="s3">% (</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    char buf[64];'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    if ((%s) &lt;= 0)' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'        sprintf(buf, &quot;%%ld&quot;, (long)(%s));' </span><span class="s3">% </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    else'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'        sprintf(buf, &quot;%%lu&quot;, (unsigned long)(%s));' </span><span class="s3">%</span>
             <span class="s1">name</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    sprintf(out_error, &quot;%s has the real value %s, not %s&quot;,'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'            &quot;%s&quot;, buf, &quot;%d&quot;);' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">[:</span><span class="s5">100</span><span class="s3">], </span><span class="s1">value</span><span class="s3">))</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'    return -1;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  }'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_load_known_int_constant</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">):</span>
        <span class="s1">BType </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;char[]&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">&quot;int(*)(char*)&quot;</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">new</span><span class="s3">(</span><span class="s1">BType</span><span class="s3">, </span><span class="s5">256</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">function</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">error </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">string</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&gt;= (</span><span class="s5">3</span><span class="s3">,):</span>
                <span class="s1">error </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">error</span><span class="s3">, </span><span class="s4">'utf-8'</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span><span class="s1">error</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_enum_funcname</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s0"># &quot;$enum_$1&quot; =&gt; &quot;___D_enum____D_1&quot;</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">'$'</span><span class="s3">, </span><span class="s4">'___D_'</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s4">'_cffi_e_%s_%s' </span><span class="s3">% (</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_generate_gen_enum_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">=</span><span class="s4">'enum'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0">#</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_enum_funcname</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'int %s(char *out_error)' </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'{'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_int_constant_value</span><span class="s3">(</span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'  return 0;'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">(</span><span class="s4">'}'</span><span class="s3">)</span>
        <span class="s1">prnt</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_loading_gen_enum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">=</span><span class="s4">'enum'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">:</span>
            <span class="s1">enumvalues </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
                          <span class="s2">for </span><span class="s1">enumerator </span><span class="s2">in </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">]</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">enumvalues</span><span class="s3">)</span>
            <span class="s1">tp</span><span class="s3">.</span><span class="s1">partial_resolved </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">funcname </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_enum_funcname</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_load_known_int_constant</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_enum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumerators</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">enumvalues</span><span class="s3">):</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">enumerator</span><span class="s3">, </span><span class="s1">enumvalue</span><span class="s3">)</span>
            <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">enumerator</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># macros: for now only for integers</span>

    <span class="s2">def </span><span class="s1">_generate_gen_macro_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp </span><span class="s3">== </span><span class="s4">'...'</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s1">tp     </span><span class="s0"># an integer</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">check_value</span><span class="s3">=</span><span class="s1">check_value</span><span class="s3">)</span>

    <span class="s1">_loading_gen_macro </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_macro</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">tp </span><span class="s3">== </span><span class="s4">'...'</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">check_value </span><span class="s3">= </span><span class="s1">tp     </span><span class="s0"># an integer</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">,</span>
                                    <span class="s1">check_value</span><span class="s3">=</span><span class="s1">check_value</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
        <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s0"># ----------</span>
    <span class="s0"># global variables</span>

    <span class="s2">def </span><span class="s1">_generate_gen_variable_decl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length_is_unknown</span><span class="s3">():</span>
                <span class="s1">prnt </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_prnt</span>
                <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_sizeof_%s' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">export_symbols</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">funcname</span><span class="s3">)</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">&quot;size_t %s(void)&quot; </span><span class="s3">% </span><span class="s1">funcname</span><span class="s3">)</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">&quot;{&quot;</span><span class="s3">)</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">&quot;  return sizeof(%s);&quot; </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,))</span>
                <span class="s1">prnt</span><span class="s3">(</span><span class="s4">&quot;}&quot;</span><span class="s3">)</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp_ptr</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_generate_gen_const</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp_ptr</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s4">'var'</span><span class="s3">)</span>

    <span class="s1">_loading_gen_variable </span><span class="s3">= </span><span class="s1">_loaded_noop</span>

    <span class="s2">def </span><span class="s1">_loaded_gen_variable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">library</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">, </span><span class="s1">model</span><span class="s3">.</span><span class="s1">ArrayType</span><span class="s3">):   </span><span class="s0"># int a[5] is &quot;constant&quot; in the</span>
                                              <span class="s0"># sense that &quot;a=...&quot; is forbidden</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length_is_unknown</span><span class="s3">():</span>
                <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_sizeof_%s' </span><span class="s3">% (</span><span class="s1">name</span><span class="s3">,)</span>
                <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s4">'size_t(*)(void)'</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">function</span><span class="s3">()</span>
                <span class="s1">BItemType </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
                <span class="s1">length</span><span class="s3">, </span><span class="s1">rest </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">BItemType</span><span class="s3">))</span>
                <span class="s2">if </span><span class="s1">rest </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">VerificationError</span><span class="s3">(</span>
                        <span class="s4">&quot;bad size: %r does not seem to be an array of %s&quot; </span><span class="s3">%</span>
                        <span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">))</span>
                <span class="s1">tp </span><span class="s3">= </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">resolve_length</span><span class="s3">(</span><span class="s1">length</span><span class="s3">)</span>
            <span class="s1">tp_ptr </span><span class="s3">= </span><span class="s1">model</span><span class="s3">.</span><span class="s1">PointerType</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">item</span><span class="s3">)</span>
            <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_load_constant</span><span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tp_ptr</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">module</span><span class="s3">)</span>
            <span class="s0"># 'value' is a &lt;cdata 'type *'&gt; which we have to replace with</span>
            <span class="s0"># a &lt;cdata 'type[N]'&gt; if the N is actually known</span>
            <span class="s2">if </span><span class="s1">tp</span><span class="s3">.</span><span class="s1">length </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">BArray </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_get_cached_btype</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
                <span class="s1">value </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">BArray</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)</span>
            <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s0"># remove ptr=&lt;cdata 'int *'&gt; from the library instance, and replace</span>
        <span class="s0"># it by a property on the class, which reads/writes into ptr[0].</span>
        <span class="s1">funcname </span><span class="s3">= </span><span class="s4">'_cffi_var_%s' </span><span class="s3">% </span><span class="s1">name</span>
        <span class="s1">BFunc </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ffi</span><span class="s3">.</span><span class="s1">_typeof_locked</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">.</span><span class="s1">get_c_name</span><span class="s3">(</span><span class="s4">'*(*)(void)'</span><span class="s3">, </span><span class="s1">name</span><span class="s3">))[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">function </span><span class="s3">= </span><span class="s1">module</span><span class="s3">.</span><span class="s1">load_function</span><span class="s3">(</span><span class="s1">BFunc</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">)</span>
        <span class="s1">ptr </span><span class="s3">= </span><span class="s1">function</span><span class="s3">()</span>
        <span class="s2">def </span><span class="s1">getter</span><span class="s3">(</span><span class="s1">library</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">ptr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">def </span><span class="s1">setter</span><span class="s3">(</span><span class="s1">library</span><span class="s3">, </span><span class="s1">value</span><span class="s3">):</span>
            <span class="s1">ptr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">value</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">), </span><span class="s1">name</span><span class="s3">, </span><span class="s1">property</span><span class="s3">(</span><span class="s1">getter</span><span class="s3">, </span><span class="s1">setter</span><span class="s3">))</span>
        <span class="s1">type</span><span class="s3">(</span><span class="s1">library</span><span class="s3">).</span><span class="s1">_cffi_dir</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

<span class="s1">cffimod_header </span><span class="s3">= </span><span class="s4">r''' 
#include &lt;stdio.h&gt; 
#include &lt;stddef.h&gt; 
#include &lt;stdarg.h&gt; 
#include &lt;errno.h&gt; 
#include &lt;sys/types.h&gt;   /* XXX for ssize_t on some platforms */ 
 
/* this block of #ifs should be kept exactly identical between 
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py 
   and cffi/_cffi_include.h */ 
#if defined(_MSC_VER) 
# include &lt;malloc.h&gt;   /* for alloca() */ 
# if _MSC_VER &lt; 1600   /* MSVC &lt; 2010 */ 
   typedef __int8 int8_t; 
   typedef __int16 int16_t; 
   typedef __int32 int32_t; 
   typedef __int64 int64_t; 
   typedef unsigned __int8 uint8_t; 
   typedef unsigned __int16 uint16_t; 
   typedef unsigned __int32 uint32_t; 
   typedef unsigned __int64 uint64_t; 
   typedef __int8 int_least8_t; 
   typedef __int16 int_least16_t; 
   typedef __int32 int_least32_t; 
   typedef __int64 int_least64_t; 
   typedef unsigned __int8 uint_least8_t; 
   typedef unsigned __int16 uint_least16_t; 
   typedef unsigned __int32 uint_least32_t; 
   typedef unsigned __int64 uint_least64_t; 
   typedef __int8 int_fast8_t; 
   typedef __int16 int_fast16_t; 
   typedef __int32 int_fast32_t; 
   typedef __int64 int_fast64_t; 
   typedef unsigned __int8 uint_fast8_t; 
   typedef unsigned __int16 uint_fast16_t; 
   typedef unsigned __int32 uint_fast32_t; 
   typedef unsigned __int64 uint_fast64_t; 
   typedef __int64 intmax_t; 
   typedef unsigned __int64 uintmax_t; 
# else 
#  include &lt;stdint.h&gt; 
# endif 
# if _MSC_VER &lt; 1800   /* MSVC &lt; 2013 */ 
#  ifndef __cplusplus 
    typedef unsigned char _Bool; 
#  endif 
# endif 
#else 
# include &lt;stdint.h&gt; 
# if (defined (__SVR4) &amp;&amp; defined (__sun)) || defined(_AIX) || defined(__hpux) 
#  include &lt;alloca.h&gt; 
# endif 
#endif 
'''</span>
</pre>
</body>
</html>