<html>
<head>
<title>_hooks.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_hooks.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Internal hook annotation, representation and calling machinery. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">ModuleType</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">AbstractSet</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Final</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypedDict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_result </span><span class="s2">import </span><span class="s1">Result</span>


<span class="s1">_T </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_T&quot;</span><span class="s3">)</span>
<span class="s1">_F </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_F&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">object</span><span class="s3">])</span>
<span class="s1">_Namespace </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">ModuleType</span><span class="s3">, </span><span class="s1">type</span><span class="s3">]</span>
<span class="s1">_Plugin </span><span class="s3">= </span><span class="s1">object</span>
<span class="s1">_HookExec </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[</span>
    <span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s4">&quot;HookImpl&quot;</span><span class="s3">], </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">], </span><span class="s1">bool</span><span class="s3">],</span>
    <span class="s1">Union</span><span class="s3">[</span><span class="s1">object</span><span class="s3">, </span><span class="s1">List</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]],</span>
<span class="s3">]</span>
<span class="s1">_HookImplFunction </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">, </span><span class="s1">Generator</span><span class="s3">[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">Result</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">], </span><span class="s2">None</span><span class="s3">]]]</span>


<span class="s2">class </span><span class="s1">HookspecOpts</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Options for a hook specification.&quot;&quot;&quot;</span>

    <span class="s5">#: Whether the hook is :ref:`first result only &lt;firstresult&gt;`.</span>
    <span class="s1">firstresult</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether the hook is :ref:`historic &lt;historic&gt;`.</span>
    <span class="s1">historic</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether the hook :ref:`warns when implemented &lt;warn_on_impl&gt;`.</span>
    <span class="s1">warn_on_impl</span><span class="s3">: </span><span class="s1">Warning </span><span class="s3">| </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">HookimplOpts</span><span class="s3">(</span><span class="s1">TypedDict</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Options for a hook implementation.&quot;&quot;&quot;</span>

    <span class="s5">#: Whether the hook implementation is a :ref:`wrapper &lt;hookwrapper&gt;`.</span>
    <span class="s1">wrapper</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether the hook implementation is an :ref:`old-style wrapper</span>
    <span class="s5">#: &lt;old_style_hookwrappers&gt;`.</span>
    <span class="s1">hookwrapper</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether validation against a hook specification is :ref:`optional</span>
    <span class="s5">#: &lt;optionalhook&gt;`.</span>
    <span class="s1">optionalhook</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether to try to order this hook implementation :ref:`first</span>
    <span class="s5">#: &lt;callorder&gt;`.</span>
    <span class="s1">tryfirst</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: Whether to try to order this hook implementation :ref:`last</span>
    <span class="s5">#: &lt;callorder&gt;`.</span>
    <span class="s1">trylast</span><span class="s3">: </span><span class="s1">bool</span>
    <span class="s5">#: The name of the hook specification to match, see :ref:`specname`.</span>
    <span class="s1">specname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">HookspecMarker</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Decorator for marking functions as hook specifications. 
 
    Instantiate it with a project_name to get a decorator. 
    Calling :meth:`PluginManager.add_hookspecs` later will discover all marked 
    functions if the :class:`PluginManager` uses the same project name. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;project_name&quot;</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">project_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">project_name</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">project_name</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s1">_F</span><span class="s3">,</span>
        <span class="s1">firstresult</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">historic</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">warn_on_impl</span><span class="s3">: </span><span class="s1">Warning </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _F</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload  </span><span class="s5"># noqa: F811</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(  </span><span class="s5"># noqa: F811</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">firstresult</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">historic</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">warn_on_impl</span><span class="s3">: </span><span class="s1">Warning </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_F</span><span class="s3">], </span><span class="s1">_F</span><span class="s3">]:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(  </span><span class="s5"># noqa: F811</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s1">_F </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">firstresult</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">historic</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">warn_on_impl</span><span class="s3">: </span><span class="s1">Warning </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _F </span><span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_F</span><span class="s3">], </span><span class="s1">_F</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;If passed a function, directly sets attributes on the function 
        which will make it discoverable to :meth:`PluginManager.add_hookspecs`. 
 
        If passed no function, returns a decorator which can be applied to a 
        function later using the attributes supplied. 
 
        :param firstresult: 
            If ``True``, the 1:N hook call (N being the number of registered 
            hook implementation functions) will stop at I&lt;=N when the I'th 
            function returns a non-``None`` result. See :ref:`firstresult`. 
 
        :param historic: 
            If ``True``, every call to the hook will be memorized and replayed 
            on plugins registered after the call was made. See :ref:`historic`. 
 
        :param warn_on_impl: 
            If given, every implementation of this hook will trigger the given 
            warning. See :ref:`warn_on_impl`. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">setattr_hookspec_opts</span><span class="s3">(</span><span class="s1">func</span><span class="s3">: </span><span class="s1">_F</span><span class="s3">) </span><span class="s1">-&gt; _F</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">historic </span><span class="s2">and </span><span class="s1">firstresult</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;cannot have a historic firstresult hook&quot;</span><span class="s3">)</span>
            <span class="s1">opts</span><span class="s3">: </span><span class="s1">HookspecOpts </span><span class="s3">= {</span>
                <span class="s4">&quot;firstresult&quot;</span><span class="s3">: </span><span class="s1">firstresult</span><span class="s3">,</span>
                <span class="s4">&quot;historic&quot;</span><span class="s3">: </span><span class="s1">historic</span><span class="s3">,</span>
                <span class="s4">&quot;warn_on_impl&quot;</span><span class="s3">: </span><span class="s1">warn_on_impl</span><span class="s3">,</span>
            <span class="s3">}</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">project_name </span><span class="s3">+ </span><span class="s4">&quot;_spec&quot;</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">func</span>

        <span class="s2">if </span><span class="s1">function </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">setattr_hookspec_opts</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">setattr_hookspec_opts</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">HookimplMarker</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Decorator for marking functions as hook implementations. 
 
    Instantiate it with a ``project_name`` to get a decorator. 
    Calling :meth:`PluginManager.register` later will discover all marked 
    functions if the :class:`PluginManager` uses the same project name. 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;project_name&quot;</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">project_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">project_name</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">project_name</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s1">_F</span><span class="s3">,</span>
        <span class="s1">hookwrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">optionalhook</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">tryfirst</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">trylast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">specname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">wrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; _F</span><span class="s3">:</span>
        <span class="s3">...</span>

    <span class="s3">@</span><span class="s1">overload  </span><span class="s5"># noqa: F811</span>
    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(  </span><span class="s5"># noqa: F811</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">hookwrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">optionalhook</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">tryfirst</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">trylast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
        <span class="s1">specname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= ...,</span>
        <span class="s1">wrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= ...,</span>
    <span class="s3">) </span><span class="s1">-&gt; Callable</span><span class="s3">[[</span><span class="s1">_F</span><span class="s3">], </span><span class="s1">_F</span><span class="s3">]:</span>
        <span class="s3">...</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(  </span><span class="s5"># noqa: F811</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s1">_F </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">hookwrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">optionalhook</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">tryfirst</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">trylast</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">specname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">wrapper</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _F </span><span class="s3">| </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">_F</span><span class="s3">], </span><span class="s1">_F</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;If passed a function, directly sets attributes on the function 
        which will make it discoverable to :meth:`PluginManager.register`. 
 
        If passed no function, returns a decorator which can be applied to a 
        function later using the attributes supplied. 
 
        :param optionalhook: 
            If ``True``, a missing matching hook specification will not result 
            in an error (by default it is an error if no matching spec is 
            found). See :ref:`optionalhook`. 
 
        :param tryfirst: 
            If ``True``, this hook implementation will run as early as possible 
            in the chain of N hook implementations for a specification. See 
            :ref:`callorder`. 
 
        :param trylast: 
            If ``True``, this hook implementation will run as late as possible 
            in the chain of N hook implementations for a specification. See 
            :ref:`callorder`. 
 
        :param wrapper: 
            If ``True`` (&quot;new-style hook wrapper&quot;), the hook implementation 
            needs to execute exactly one ``yield``. The code before the 
            ``yield`` is run early before any non-hook-wrapper function is run. 
            The code after the ``yield`` is run after all non-hook-wrapper 
            functions have run. The ``yield`` receives the result value of the 
            inner calls, or raises the exception of inner calls (including 
            earlier hook wrapper calls). The return value of the function 
            becomes the return value of the hook, and a raised exception becomes 
            the exception of the hook. See :ref:`hookwrapper`. 
 
        :param hookwrapper: 
            If ``True`` (&quot;old-style hook wrapper&quot;), the hook implementation 
            needs to execute exactly one ``yield``. The code before the 
            ``yield`` is run early before any non-hook-wrapper function is run. 
            The code after the ``yield`` is run after all non-hook-wrapper 
            function have run  The ``yield`` receives a :class:`Result` object 
            representing the exception or result outcome of the inner calls 
            (including earlier hook wrapper calls). This option is mutually 
            exclusive with ``wrapper``. See :ref:`old_style_hookwrapper`. 
 
        :param specname: 
            If provided, the given name will be used instead of the function 
            name when matching this hook implementation to a hook specification 
            during registration. See :ref:`specname`. 
 
        .. versionadded:: 1.2.0 
            The ``wrapper`` parameter. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">setattr_hookimpl_opts</span><span class="s3">(</span><span class="s1">func</span><span class="s3">: </span><span class="s1">_F</span><span class="s3">) </span><span class="s1">-&gt; _F</span><span class="s3">:</span>
            <span class="s1">opts</span><span class="s3">: </span><span class="s1">HookimplOpts </span><span class="s3">= {</span>
                <span class="s4">&quot;wrapper&quot;</span><span class="s3">: </span><span class="s1">wrapper</span><span class="s3">,</span>
                <span class="s4">&quot;hookwrapper&quot;</span><span class="s3">: </span><span class="s1">hookwrapper</span><span class="s3">,</span>
                <span class="s4">&quot;optionalhook&quot;</span><span class="s3">: </span><span class="s1">optionalhook</span><span class="s3">,</span>
                <span class="s4">&quot;tryfirst&quot;</span><span class="s3">: </span><span class="s1">tryfirst</span><span class="s3">,</span>
                <span class="s4">&quot;trylast&quot;</span><span class="s3">: </span><span class="s1">trylast</span><span class="s3">,</span>
                <span class="s4">&quot;specname&quot;</span><span class="s3">: </span><span class="s1">specname</span><span class="s3">,</span>
            <span class="s3">}</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">project_name </span><span class="s3">+ </span><span class="s4">&quot;_impl&quot;</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">func</span>

        <span class="s2">if </span><span class="s1">function </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">setattr_hookimpl_opts</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">setattr_hookimpl_opts</span><span class="s3">(</span><span class="s1">function</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">normalize_hookimpl_opts</span><span class="s3">(</span><span class="s1">opts</span><span class="s3">: </span><span class="s1">HookimplOpts</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;tryfirst&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;trylast&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;wrapper&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;hookwrapper&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;optionalhook&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">opts</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s4">&quot;specname&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>


<span class="s1">_PYPY </span><span class="s3">= </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">, </span><span class="s4">&quot;pypy_version_info&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">varnames</span><span class="s3">(</span><span class="s1">func</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; tuple</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...], </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...]]:</span>
    <span class="s0">&quot;&quot;&quot;Return tuple of positional and keywrord argument names for a function, 
    method, class or callable. 
 
    In case of a class, its ``__init__`` method is considered. 
    For methods the ``self`` parameter is not included. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isclass</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__init__</span>
        <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(), ()</span>
    <span class="s2">elif not </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">isroutine</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):  </span><span class="s5"># callable object?</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s4">&quot;__call__&quot;</span><span class="s3">, </span><span class="s1">func</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(), ()</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s5"># func MUST be a function or method here or we won't parse any args.</span>
        <span class="s1">sig </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span>
            <span class="s1">func</span><span class="s3">.</span><span class="s1">__func__ </span><span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">ismethod</span><span class="s3">(</span><span class="s1">func</span><span class="s3">) </span><span class="s2">else </span><span class="s1">func  </span><span class="s5"># type:ignore[arg-type]</span>
        <span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(), ()</span>

    <span class="s1">_valid_param_kinds </span><span class="s3">= (</span>
        <span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_ONLY</span><span class="s3">,</span>
        <span class="s1">inspect</span><span class="s3">.</span><span class="s1">Parameter</span><span class="s3">.</span><span class="s1">POSITIONAL_OR_KEYWORD</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">_valid_params </span><span class="s3">= {</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">param</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">param </span><span class="s2">in </span><span class="s1">sig</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">param</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s1">_valid_param_kinds</span>
    <span class="s3">}</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">_valid_params</span><span class="s3">)</span>
    <span class="s1">defaults </span><span class="s3">= (</span>
        <span class="s1">tuple</span><span class="s3">(</span>
            <span class="s1">param</span><span class="s3">.</span><span class="s1">default</span>
            <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">_valid_params</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">param</span><span class="s3">.</span><span class="s1">default </span><span class="s2">is not </span><span class="s1">param</span><span class="s3">.</span><span class="s1">empty</span>
        <span class="s3">)</span>
        <span class="s2">or None</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">defaults</span><span class="s3">:</span>
        <span class="s1">index </span><span class="s3">= -</span><span class="s1">len</span><span class="s3">(</span><span class="s1">defaults</span><span class="s3">)</span>
        <span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[:</span><span class="s1">index</span><span class="s3">], </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s1">index</span><span class="s3">:])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">kwargs </span><span class="s3">= ()</span>

    <span class="s5"># strip any implicit instance arg</span>
    <span class="s5"># pypy3 uses &quot;obj&quot; instead of &quot;self&quot; for default dunder methods</span>
    <span class="s2">if not </span><span class="s1">_PYPY</span><span class="s3">:</span>
        <span class="s1">implicit_names</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...] = (</span><span class="s4">&quot;self&quot;</span><span class="s3">,)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">implicit_names </span><span class="s3">= (</span><span class="s4">&quot;self&quot;</span><span class="s3">, </span><span class="s4">&quot;obj&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">args</span><span class="s3">:</span>
        <span class="s1">qualname</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s4">&quot;__qualname__&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">ismethod</span><span class="s3">(</span><span class="s1">func</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s4">&quot;.&quot; </span><span class="s2">in </span><span class="s1">qualname </span><span class="s2">and </span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">in </span><span class="s1">implicit_names</span><span class="s3">):</span>
            <span class="s1">args </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>

    <span class="s2">return </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">HookRelay</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Hook holder object for performing 1:N hook calls where N is the number 
    of registered plugins.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span><span class="s4">&quot;__dict__&quot;</span><span class="s3">,)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>

        <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; HookCaller</span><span class="s3">:</span>
            <span class="s3">...</span>


<span class="s5"># Historical name (pluggy&lt;=1.2), kept for backward compatibility.</span>
<span class="s1">_HookRelay </span><span class="s3">= </span><span class="s1">HookRelay</span>


<span class="s1">_CallHistory </span><span class="s3">= </span><span class="s1">List</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">], </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s2">None</span><span class="s3">]]]]</span>


<span class="s2">class </span><span class="s1">HookCaller</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;A caller of all registered implementations of a hook specification.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;name&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;spec&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_hookexec&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_hookimpls&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_call_history&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">hook_execute</span><span class="s3">: </span><span class="s1">_HookExec</span><span class="s3">,</span>
        <span class="s1">specmodule_or_class</span><span class="s3">: </span><span class="s1">_Namespace </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">spec_opts</span><span class="s3">: </span><span class="s1">HookspecOpts </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="s5">#: Name of the hook getting called.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_execute</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">: </span><span class="s1">Final</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">HookImpl</span><span class="s3">]] = []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history</span><span class="s3">: </span><span class="s1">_CallHistory </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s5"># TODO: Document, or make private.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">: </span><span class="s1">HookSpec </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">specmodule_or_class </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">spec_opts </span><span class="s2">is not None</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">set_specification</span><span class="s3">(</span><span class="s1">specmodule_or_class</span><span class="s3">, </span><span class="s1">spec_opts</span><span class="s3">)</span>

    <span class="s5"># TODO: Document, or make private.</span>
    <span class="s2">def </span><span class="s1">has_spec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec </span><span class="s2">is not None</span>

    <span class="s5"># TODO: Document, or make private.</span>
    <span class="s2">def </span><span class="s1">set_specification</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">specmodule_or_class</span><span class="s3">: </span><span class="s1">_Namespace</span><span class="s3">,</span>
        <span class="s1">spec_opts</span><span class="s3">: </span><span class="s1">HookspecOpts</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;Hook </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">name</span><span class="s2">!r} </span><span class="s4">is already registered &quot;</span>
                <span class="s4">f&quot;within namespace </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">namespace</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">spec </span><span class="s3">= </span><span class="s1">HookSpec</span><span class="s3">(</span><span class="s1">specmodule_or_class</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">spec_opts</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">spec_opts</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;historic&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history </span><span class="s3">= []</span>

    <span class="s2">def </span><span class="s1">is_historic</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Whether this caller is :ref:`historic &lt;historic&gt;`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">_remove_plugin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">plugin</span><span class="s3">: </span><span class="s1">_Plugin</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">method</span><span class="s3">.</span><span class="s1">plugin </span><span class="s3">== </span><span class="s1">plugin</span><span class="s3">:</span>
                <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s2">return</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;plugin </span><span class="s2">{</span><span class="s1">plugin</span><span class="s2">!r} </span><span class="s4">not found&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_hookimpls</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">HookImpl</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Get all registered hook implementations for this hook.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_add_hookimpl</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">hookimpl</span><span class="s3">: </span><span class="s1">HookImpl</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Add an implementation to the callback chain.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">method </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">method</span><span class="s3">.</span><span class="s1">hookwrapper </span><span class="s2">or </span><span class="s1">method</span><span class="s3">.</span><span class="s1">wrapper</span><span class="s3">:</span>
                <span class="s1">splitpoint </span><span class="s3">= </span><span class="s1">i</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">splitpoint </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">hookimpl</span><span class="s3">.</span><span class="s1">hookwrapper </span><span class="s2">or </span><span class="s1">hookimpl</span><span class="s3">.</span><span class="s1">wrapper</span><span class="s3">:</span>
            <span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">= </span><span class="s1">splitpoint</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">start</span><span class="s3">, </span><span class="s1">end </span><span class="s3">= </span><span class="s6">0</span><span class="s3">, </span><span class="s1">splitpoint</span>

        <span class="s2">if </span><span class="s1">hookimpl</span><span class="s3">.</span><span class="s1">trylast</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">hookimpl</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hookimpl</span><span class="s3">.</span><span class="s1">tryfirst</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">end</span><span class="s3">, </span><span class="s1">hookimpl</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># find last non-tryfirst method</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s6">1</span>
            <span class="s2">while </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s1">start </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">tryfirst</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">-= </span><span class="s6">1</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">hookimpl</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;HookCaller </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>

    <span class="s2">def </span><span class="s1">_verify_all_args_are_provided</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5"># This is written to avoid expensive operations when not needed.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">argnames</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">argname </span><span class="s2">not in </span><span class="s1">kwargs</span><span class="s3">:</span>
                    <span class="s1">notincall </span><span class="s3">= </span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span>
                        <span class="s1">repr</span><span class="s3">(</span><span class="s1">argname</span><span class="s3">)</span>
                        <span class="s2">for </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">argnames</span>
                        <span class="s5"># Avoid self.spec.argnames - kwargs.keys() - doesn't preserve order.</span>
                        <span class="s2">if </span><span class="s1">argname </span><span class="s2">not in </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>
                    <span class="s3">)</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s4">&quot;Argument(s) {} which are declared in the hookspec &quot;</span>
                        <span class="s4">&quot;cannot be found in this hook call&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">notincall</span><span class="s3">),</span>
                        <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s2">break</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Call the hook. 
 
        Only accepts keyword arguments, which should match the hook 
        specification. 
 
        Returns the result(s) of calling all registered plugins, see 
        :ref:`calling`. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_historic</span><span class="s3">()</span>
        <span class="s3">), </span><span class="s4">&quot;Cannot directly call a historic hook - use call_historic instead.&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_verify_all_args_are_provided</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">firstresult </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">opts</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;firstresult&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec </span><span class="s2">else False</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">firstresult</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">call_historic</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">result_callback</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">Any</span><span class="s3">], </span><span class="s2">None</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">] | </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Call the hook with given ``kwargs`` for all registered plugins and 
        for all plugins which will be registered afterwards, see 
        :ref:`historic`. 
 
        :param result_callback: 
            If provided, will be called for each non-``None`` result obtained 
            from a hook implementation. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history </span><span class="s2">is not None</span>
        <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s3">{}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_verify_all_args_are_provided</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">result_callback</span><span class="s3">))</span>
        <span class="s5"># Historizing hooks don't return results.</span>
        <span class="s5"># Remember firstresult isn't compatible with historic.</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result_callback </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">list</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">res</span><span class="s3">:</span>
                <span class="s1">result_callback</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">call_extra</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">methods</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">object</span><span class="s3">]], </span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">object</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Call the hook with some additional temporarily participating 
        methods using the specified ``kwargs`` as call parameters, see 
        :ref:`call_extra`.&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_historic</span><span class="s3">()</span>
        <span class="s3">), </span><span class="s4">&quot;Cannot directly call a historic hook - use call_historic instead.&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_verify_all_args_are_provided</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">opts</span><span class="s3">: </span><span class="s1">HookimplOpts </span><span class="s3">= {</span>
            <span class="s4">&quot;wrapper&quot;</span><span class="s3">: </span><span class="s2">False</span><span class="s3">,</span>
            <span class="s4">&quot;hookwrapper&quot;</span><span class="s3">: </span><span class="s2">False</span><span class="s3">,</span>
            <span class="s4">&quot;optionalhook&quot;</span><span class="s3">: </span><span class="s2">False</span><span class="s3">,</span>
            <span class="s4">&quot;trylast&quot;</span><span class="s3">: </span><span class="s2">False</span><span class="s3">,</span>
            <span class="s4">&quot;tryfirst&quot;</span><span class="s3">: </span><span class="s2">False</span><span class="s3">,</span>
            <span class="s4">&quot;specname&quot;</span><span class="s3">: </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">}</span>
        <span class="s1">hookimpls </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookimpls</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">methods</span><span class="s3">:</span>
            <span class="s1">hookimpl </span><span class="s3">= </span><span class="s1">HookImpl</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s4">&quot;&lt;temp&gt;&quot;</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">)</span>
            <span class="s5"># Find last non-tryfirst nonwrapper method.</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">hookimpls</span><span class="s3">) - </span><span class="s6">1</span>
            <span class="s2">while </span><span class="s3">(</span>
                <span class="s1">i </span><span class="s3">&gt;= </span><span class="s6">0</span>
                <span class="s2">and </span><span class="s1">hookimpls</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">tryfirst</span>
                <span class="s2">and not </span><span class="s3">(</span><span class="s1">hookimpls</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">hookwrapper </span><span class="s2">or </span><span class="s1">hookimpls</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">wrapper</span><span class="s3">)</span>
            <span class="s3">):</span>
                <span class="s1">i </span><span class="s3">-= </span><span class="s6">1</span>
            <span class="s1">hookimpls</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">hookimpl</span><span class="s3">)</span>
        <span class="s1">firstresult </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec</span><span class="s3">.</span><span class="s1">opts</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;firstresult&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">spec </span><span class="s2">else False</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">hookimpls</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">firstresult</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_maybe_apply_history</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">HookImpl</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Apply call history to a new hookimpl if it is marked as historic.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_historic</span><span class="s3">():</span>
            <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history </span><span class="s2">is not None</span>
            <span class="s2">for </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">result_callback </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_call_history</span><span class="s3">:</span>
                <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, [</span><span class="s1">method</span><span class="s3">], </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">res </span><span class="s2">and </span><span class="s1">result_callback </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s5"># XXX: remember firstresult isn't compat with historic</span>
                    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)</span>
                    <span class="s1">result_callback</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>


<span class="s5"># Historical name (pluggy&lt;=1.2), kept for backward compatibility.</span>
<span class="s1">_HookCaller </span><span class="s3">= </span><span class="s1">HookCaller</span>


<span class="s2">class </span><span class="s1">_SubsetHookCaller</span><span class="s3">(</span><span class="s1">HookCaller</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A proxy to another HookCaller which manages calls to all registered 
    plugins except the ones from remove_plugins.&quot;&quot;&quot;</span>

    <span class="s5"># This class is unusual: in inhertits from `HookCaller` so all of</span>
    <span class="s5"># the *code* runs in the class, but it delegates all underlying *data*</span>
    <span class="s5"># to the original HookCaller.</span>
    <span class="s5"># `subset_hook_caller` used to be implemented by creating a full-fledged</span>
    <span class="s5"># HookCaller, copying all hookimpls from the original. This had problems</span>
    <span class="s5"># with memory leaks (#346) and historic calls (#347), which make a proxy</span>
    <span class="s5"># approach better.</span>
    <span class="s5"># An alternative implementation is to use a `_getattr__`/`__getattribute__`</span>
    <span class="s5"># proxy, however that adds more overhead and is more tricky to implement.</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;_orig&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;_remove_plugins&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">orig</span><span class="s3">: </span><span class="s1">HookCaller</span><span class="s3">, </span><span class="s1">remove_plugins</span><span class="s3">: </span><span class="s1">AbstractSet</span><span class="s3">[</span><span class="s1">_Plugin</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_orig </span><span class="s3">= </span><span class="s1">orig</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_remove_plugins </span><span class="s3">= </span><span class="s1">remove_plugins</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">orig</span><span class="s3">.</span><span class="s1">name  </span><span class="s5"># type: ignore[misc]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_hookexec </span><span class="s3">= </span><span class="s1">orig</span><span class="s3">.</span><span class="s1">_hookexec  </span><span class="s5"># type: ignore[misc]</span>

    <span class="s3">@</span><span class="s1">property  </span><span class="s5"># type: ignore[misc]</span>
    <span class="s2">def </span><span class="s1">_hookimpls</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; list</span><span class="s3">[</span><span class="s1">HookImpl</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s1">impl</span>
            <span class="s2">for </span><span class="s1">impl </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig</span><span class="s3">.</span><span class="s1">_hookimpls</span>
            <span class="s2">if </span><span class="s1">impl</span><span class="s3">.</span><span class="s1">plugin </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_remove_plugins</span>
        <span class="s3">]</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">spec</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; HookSpec </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:  </span><span class="s5"># type: ignore[override]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig</span><span class="s3">.</span><span class="s1">spec</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_call_history</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _CallHistory </span><span class="s3">| </span><span class="s2">None</span><span class="s3">:  </span><span class="s5"># type: ignore[override]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_orig</span><span class="s3">.</span><span class="s1">_call_history</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;_SubsetHookCaller </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">HookImpl</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;A hook implementation in a :class:`HookCaller`.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;argnames&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;kwargnames&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;plugin&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;opts&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;plugin_name&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;wrapper&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;hookwrapper&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;optionalhook&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;tryfirst&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;trylast&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">plugin</span><span class="s3">: </span><span class="s1">_Plugin</span><span class="s3">,</span>
        <span class="s1">plugin_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">function</span><span class="s3">: </span><span class="s1">_HookImplFunction</span><span class="s3">[</span><span class="s1">object</span><span class="s3">],</span>
        <span class="s1">hook_impl_opts</span><span class="s3">: </span><span class="s1">HookimplOpts</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="s5">#: The hook implementation function.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">function</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">function</span>
        <span class="s1">argnames</span><span class="s3">, </span><span class="s1">kwargnames </span><span class="s3">= </span><span class="s1">varnames</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s5">#: The positional parameter names of ``function```.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">argnames</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">argnames</span>
        <span class="s5">#: The keyword parameter names of ``function```.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kwargnames</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">kwargnames</span>
        <span class="s5">#: The plugin which defined this hook implementation.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">plugin</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">plugin</span>
        <span class="s5">#: The :class:`HookimplOpts` used to configure this hook implementation.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">opts</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span>
        <span class="s5">#: The name of the plugin which defined this hook implementation.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">plugin_name</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">plugin_name</span>
        <span class="s5">#: Whether the hook implementation is a :ref:`wrapper &lt;hookwrapper&gt;`.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">wrapper</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span><span class="s3">[</span><span class="s4">&quot;wrapper&quot;</span><span class="s3">]</span>
        <span class="s5">#: Whether the hook implementation is an :ref:`old-style wrapper</span>
        <span class="s5">#: &lt;old_style_hookwrappers&gt;`.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">hookwrapper</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span><span class="s3">[</span><span class="s4">&quot;hookwrapper&quot;</span><span class="s3">]</span>
        <span class="s5">#: Whether validation against a hook specification is :ref:`optional</span>
        <span class="s5">#: &lt;optionalhook&gt;`.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">optionalhook</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span><span class="s3">[</span><span class="s4">&quot;optionalhook&quot;</span><span class="s3">]</span>
        <span class="s5">#: Whether to try to order this hook implementation :ref:`first</span>
        <span class="s5">#: &lt;callorder&gt;`.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tryfirst</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span><span class="s3">[</span><span class="s4">&quot;tryfirst&quot;</span><span class="s3">]</span>
        <span class="s5">#: Whether to try to order this hook implementation :ref:`last</span>
        <span class="s5">#: &lt;callorder&gt;`.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">trylast</span><span class="s3">: </span><span class="s1">Final </span><span class="s3">= </span><span class="s1">hook_impl_opts</span><span class="s3">[</span><span class="s4">&quot;trylast&quot;</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;HookImpl plugin_name=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">plugin_name</span><span class="s2">!r}</span><span class="s4">, plugin=</span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">plugin</span><span class="s2">!r}</span><span class="s4">&gt;&quot;</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">class </span><span class="s1">HookSpec</span><span class="s3">:</span>
    <span class="s1">__slots__ </span><span class="s3">= (</span>
        <span class="s4">&quot;namespace&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;function&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;name&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;argnames&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;kwargnames&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;opts&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;warn_on_impl&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">namespace</span><span class="s3">: </span><span class="s1">_Namespace</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">: </span><span class="s1">HookspecOpts</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">namespace </span><span class="s3">= </span><span class="s1">namespace</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">function</span><span class="s3">: </span><span class="s1">Callable</span><span class="s3">[..., </span><span class="s1">object</span><span class="s3">] = </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">namespace</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">argnames</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">kwargnames </span><span class="s3">= </span><span class="s1">varnames</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">function</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">opts </span><span class="s3">= </span><span class="s1">opts</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">warn_on_impl </span><span class="s3">= </span><span class="s1">opts</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;warn_on_impl&quot;</span><span class="s3">)</span>
</pre>
</body>
</html>