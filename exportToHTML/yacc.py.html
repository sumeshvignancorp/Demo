<html>
<head>
<title>yacc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
yacc.py</font>
</center></td></tr></table>
<pre><span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># ply: yacc.py</span>
<span class="s0">#</span>
<span class="s0"># Copyright (C) 2001-2017</span>
<span class="s0"># David M. Beazley (Dabeaz LLC)</span>
<span class="s0"># All rights reserved.</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0"># * Redistributions of source code must retain the above copyright notice,</span>
<span class="s0">#   this list of conditions and the following disclaimer.</span>
<span class="s0"># * Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="s0">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="s0">#   and/or other materials provided with the distribution.</span>
<span class="s0"># * Neither the name of the David Beazley or Dabeaz LLC may be used to</span>
<span class="s0">#   endorse or promote products derived from this software without</span>
<span class="s0">#  specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#</span>
<span class="s0"># This implements an LR parser that is constructed from grammar rules defined</span>
<span class="s0"># as Python functions. The grammer is specified by supplying the BNF inside</span>
<span class="s0"># Python documentation strings.  The inspiration for this technique was borrowed</span>
<span class="s0"># from John Aycock's Spark parsing system.  PLY might be viewed as cross between</span>
<span class="s0"># Spark and the GNU bison utility.</span>
<span class="s0">#</span>
<span class="s0"># The current implementation is only somewhat object-oriented. The</span>
<span class="s0"># LR parser itself is defined in terms of an object (which allows multiple</span>
<span class="s0"># parsers to co-exist).  However, most of the variables used during table</span>
<span class="s0"># construction are defined in terms of global variables.  Users shouldn't</span>
<span class="s0"># notice unless they are trying to define multiple parsers at the same</span>
<span class="s0"># time using threads (in which case they should have their head examined).</span>
<span class="s0">#</span>
<span class="s0"># This implementation supports both SLR and LALR(1) parsing.  LALR(1)</span>
<span class="s0"># support was originally implemented by Elias Ioup (ezioup@alumni.uchicago.edu),</span>
<span class="s0"># using the algorithm found in Aho, Sethi, and Ullman &quot;Compilers: Principles,</span>
<span class="s0"># Techniques, and Tools&quot; (The Dragon Book).  LALR(1) has since been replaced</span>
<span class="s0"># by the more efficient DeRemer and Pennello algorithm.</span>
<span class="s0">#</span>
<span class="s0"># :::::::: WARNING :::::::</span>
<span class="s0">#</span>
<span class="s0"># Construction of LR parsing tables is fairly complicated and expensive.</span>
<span class="s0"># To make this module run fast, a *LOT* of work has been put into</span>
<span class="s0"># optimization---often at the expensive of readability and what might</span>
<span class="s0"># consider to be good Python &quot;coding style.&quot;   Modify the code at your</span>
<span class="s0"># own risk!</span>
<span class="s0"># ----------------------------------------------------------------------------</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">base64</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s1">__version__    </span><span class="s3">= </span><span class="s4">'3.10'</span>
<span class="s1">__tabversion__ </span><span class="s3">= </span><span class="s4">'3.10'</span>

<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0">#                     === User configurable parameters ===</span>
<span class="s0">#</span>
<span class="s0"># Change these to modify the default behavior of yacc (if you wish)</span>
<span class="s0">#-----------------------------------------------------------------------------</span>

<span class="s1">yaccdebug   </span><span class="s3">= </span><span class="s2">True             </span><span class="s0"># Debugging mode.  If set, yacc generates a</span>
                               <span class="s0"># a 'parser.out' file in the current directory</span>

<span class="s1">debug_file  </span><span class="s3">= </span><span class="s4">'parser.out'     </span><span class="s0"># Default name of the debugging file</span>
<span class="s1">tab_module  </span><span class="s3">= </span><span class="s4">'parsetab'       </span><span class="s0"># Default name of the table module</span>
<span class="s1">default_lr  </span><span class="s3">= </span><span class="s4">'LALR'           </span><span class="s0"># Default LR table generation method</span>

<span class="s1">error_count </span><span class="s3">= </span><span class="s5">3                </span><span class="s0"># Number of symbols that must be shifted to leave recovery mode</span>

<span class="s1">yaccdevel   </span><span class="s3">= </span><span class="s2">False            </span><span class="s0"># Set to True if developing yacc.  This turns off optimized</span>
                               <span class="s0"># implementations of certain functions.</span>

<span class="s1">resultlimit </span><span class="s3">= </span><span class="s5">40               </span><span class="s0"># Size limit of results when running in debug mode.</span>

<span class="s1">pickle_protocol </span><span class="s3">= </span><span class="s5">0            </span><span class="s0"># Protocol to use when writing pickle files</span>

<span class="s0"># String type-checking compatibility</span>
<span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">3</span><span class="s3">:</span>
    <span class="s1">string_types </span><span class="s3">= </span><span class="s1">basestring</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">string_types </span><span class="s3">= </span><span class="s1">str</span>

<span class="s1">MAXINT </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">maxsize</span>

<span class="s0"># This object is a stand-in for a logging object created by the</span>
<span class="s0"># logging module.   PLY will use this by default to create things</span>
<span class="s0"># such as the parser.out file.  If a user wants more detailed</span>
<span class="s0"># information, they can create their own logging object and pass</span>
<span class="s0"># it into PLY.</span>

<span class="s2">class </span><span class="s1">PlyLogger</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">f </span><span class="s3">= </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">debug</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">((</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">args</span><span class="s3">) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s1">info </span><span class="s3">= </span><span class="s1">debug</span>

    <span class="s2">def </span><span class="s1">warning</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'WARNING: ' </span><span class="s3">+ (</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">args</span><span class="s3">) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'ERROR: ' </span><span class="s3">+ (</span><span class="s1">msg </span><span class="s3">% </span><span class="s1">args</span><span class="s3">) + </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s1">critical </span><span class="s3">= </span><span class="s1">debug</span>

<span class="s0"># Null logger is used when no output is generated. Does nothing.</span>
<span class="s2">class </span><span class="s1">NullLogger</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__getattribute__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span>

<span class="s0"># Exception raised for yacc-related errors</span>
<span class="s2">class </span><span class="s1">YaccError</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">pass</span>

<span class="s0"># Format the result message that the parser produces when running in debug mode.</span>
<span class="s2">def </span><span class="s1">format_result</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
    <span class="s1">repr_str </span><span class="s3">= </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s2">in </span><span class="s1">repr_str</span><span class="s3">:</span>
        <span class="s1">repr_str </span><span class="s3">= </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">repr_str</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">repr_str</span><span class="s3">) &gt; </span><span class="s1">resultlimit</span><span class="s3">:</span>
        <span class="s1">repr_str </span><span class="s3">= </span><span class="s1">repr_str</span><span class="s3">[:</span><span class="s1">resultlimit</span><span class="s3">] + </span><span class="s4">' ...'</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s4">'&lt;%s @ 0x%x&gt; (%s)' </span><span class="s3">% (</span><span class="s1">type</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">id</span><span class="s3">(</span><span class="s1">r</span><span class="s3">), </span><span class="s1">repr_str</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">result</span>

<span class="s0"># Format stack entries when the parser is running in debug mode</span>
<span class="s2">def </span><span class="s1">format_stack_entry</span><span class="s3">(</span><span class="s1">r</span><span class="s3">):</span>
    <span class="s1">repr_str </span><span class="s3">= </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s2">in </span><span class="s1">repr_str</span><span class="s3">:</span>
        <span class="s1">repr_str </span><span class="s3">= </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">repr_str</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">repr_str</span><span class="s3">) &lt; </span><span class="s5">16</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">repr_str</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">'&lt;%s @ 0x%x&gt;' </span><span class="s3">% (</span><span class="s1">type</span><span class="s3">(</span><span class="s1">r</span><span class="s3">).</span><span class="s1">__name__</span><span class="s3">, </span><span class="s1">id</span><span class="s3">(</span><span class="s1">r</span><span class="s3">))</span>

<span class="s0"># Panic mode error recovery support.   This feature is being reworked--much of the</span>
<span class="s0"># code here is to offer a deprecation/backwards compatible transition</span>

<span class="s1">_errok </span><span class="s3">= </span><span class="s2">None</span>
<span class="s1">_token </span><span class="s3">= </span><span class="s2">None</span>
<span class="s1">_restart </span><span class="s3">= </span><span class="s2">None</span>
<span class="s1">_warnmsg </span><span class="s3">= </span><span class="s4">'''PLY: Don't use global functions errok(), token(), and restart() in p_error(). 
Instead, invoke the methods on the associated parser instance: 
 
    def p_error(p): 
        ... 
        # Use parser.errok(), parser.token(), parser.restart() 
        ... 
 
    parser = yacc.yacc() 
'''</span>

<span class="s2">def </span><span class="s1">errok</span><span class="s3">():</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">_warnmsg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_errok</span><span class="s3">()</span>

<span class="s2">def </span><span class="s1">restart</span><span class="s3">():</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">_warnmsg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_restart</span><span class="s3">()</span>

<span class="s2">def </span><span class="s1">token</span><span class="s3">():</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">_warnmsg</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_token</span><span class="s3">()</span>

<span class="s0"># Utility function to call the p_error() function with some deprecation hacks</span>
<span class="s2">def </span><span class="s1">call_errorfunc</span><span class="s3">(</span><span class="s1">errorfunc</span><span class="s3">, </span><span class="s1">token</span><span class="s3">, </span><span class="s1">parser</span><span class="s3">):</span>
    <span class="s2">global </span><span class="s1">_errok</span><span class="s3">, </span><span class="s1">_token</span><span class="s3">, </span><span class="s1">_restart</span>
    <span class="s1">_errok </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">errok</span>
    <span class="s1">_token </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">token</span>
    <span class="s1">_restart </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">restart</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">errorfunc</span><span class="s3">(</span><span class="s1">token</span><span class="s3">)</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">del </span><span class="s1">_errok</span><span class="s3">, </span><span class="s1">_token</span><span class="s3">, </span><span class="s1">_restart</span>
    <span class="s2">except </span><span class="s1">NameError</span><span class="s3">:</span>
        <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">r</span>

<span class="s0">#-----------------------------------------------------------------------------</span>
<span class="s0">#                        ===  LR Parsing Engine ===</span>
<span class="s0">#</span>
<span class="s0"># The following classes are used for the LR parser itself.  These are not</span>
<span class="s0"># used during table construction and are independent of the actual LR</span>
<span class="s0"># table generation algorithm</span>
<span class="s0">#-----------------------------------------------------------------------------</span>

<span class="s0"># This class is used to hold non-terminal grammar symbols during parsing.</span>
<span class="s0"># It normally has the following attributes set:</span>
<span class="s0">#        .type       = Grammar symbol type</span>
<span class="s0">#        .value      = Symbol value</span>
<span class="s0">#        .lineno     = Starting line number</span>
<span class="s0">#        .endlineno  = Ending line number (optional, set automatically)</span>
<span class="s0">#        .lexpos     = Starting lex position</span>
<span class="s0">#        .endlexpos  = Ending lex position (optional, set automatically)</span>

<span class="s2">class </span><span class="s1">YaccSymbol</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

<span class="s0"># This class is a wrapper around the objects actually passed to each</span>
<span class="s0"># grammar rule.   Index lookup and assignment actually assign the</span>
<span class="s0"># .value attribute of the underlying YaccSymbol object.</span>
<span class="s0"># The lineno() method returns the line number of a given</span>
<span class="s0"># item (or 0 if not defined).   The linespan() method returns</span>
<span class="s0"># a tuple of (startline,endline) representing the range of lines</span>
<span class="s0"># for a symbol.  The lexspan() method returns a tuple (lexpos,endlexpos)</span>
<span class="s0"># representing the range of positional information for a symbol.</span>

<span class="s2">class </span><span class="s1">YaccProduction</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">s</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">stack</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">parser </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">[</span><span class="s1">s</span><span class="s3">.</span><span class="s1">value </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">]]</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">].</span><span class="s1">value</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">[</span><span class="s1">n</span><span class="s3">].</span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">].</span><span class="s1">value </span><span class="s3">= </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">__getslice__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">s</span><span class="s3">.</span><span class="s1">value </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:</span><span class="s1">j</span><span class="s3">]]</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lineno</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'lineno'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">set_lineno</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">lineno</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">].</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">lineno</span>

    <span class="s2">def </span><span class="s1">linespan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">startline </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'lineno'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">endline </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'endlineno'</span><span class="s3">, </span><span class="s1">startline</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">startline</span><span class="s3">, </span><span class="s1">endline</span>

    <span class="s2">def </span><span class="s1">lexpos</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'lexpos'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">lexspan</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">startpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'lexpos'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">endpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">[</span><span class="s1">n</span><span class="s3">], </span><span class="s4">'endlexpos'</span><span class="s3">, </span><span class="s1">startpos</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">startpos</span><span class="s3">, </span><span class="s1">endpos</span>

    <span class="s2">def </span><span class="s1">error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">SyntaxError</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                               == LRParser ==</span>
<span class="s0">#</span>
<span class="s0"># The LR Parsing engine.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRParser</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lrtab</span><span class="s3">, </span><span class="s1">errorf</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">productions </span><span class="s3">= </span><span class="s1">lrtab</span><span class="s3">.</span><span class="s1">lr_productions</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">action </span><span class="s3">= </span><span class="s1">lrtab</span><span class="s3">.</span><span class="s1">lr_action</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">goto </span><span class="s3">= </span><span class="s1">lrtab</span><span class="s3">.</span><span class="s1">lr_goto</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc </span><span class="s3">= </span><span class="s1">errorf</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">set_defaulted_states</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">errok</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">restart</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">statestack</span><span class="s3">[:]</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">symstack</span><span class="s3">[:]</span>
        <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
        <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s0"># Defaulted state support.</span>
    <span class="s0"># This method identifies parser states where there is only one possible reduction action.</span>
    <span class="s0"># For such states, the parser can make a choose to make a rule reduction without consuming</span>
    <span class="s0"># the next look-ahead token.  This delayed invocation of the tokenizer can be useful in</span>
    <span class="s0"># certain kinds of advanced parsing situations where the lexer and parser interact with</span>
    <span class="s0"># each other or change states (i.e., manipulation of scope, lexer states, etc.).</span>
    <span class="s0">#</span>
    <span class="s0"># See:  https://www.gnu.org/software/bison/manual/html_node/Default-Reductions.html#Default-Reductions</span>
    <span class="s2">def </span><span class="s1">set_defaulted_states</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">actions </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">action</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">rules </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">actions</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">rules</span><span class="s3">) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">rules</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states</span><span class="s3">[</span><span class="s1">state</span><span class="s3">] = </span><span class="s1">rules</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">disable_defaulted_states</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">parse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">debug </span><span class="s2">or </span><span class="s1">yaccdevel</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">debug</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
                <span class="s1">debug </span><span class="s3">= </span><span class="s1">PlyLogger</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">parsedebug</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">tracking</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">parseopt</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">parseopt_notrack</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">)</span>


    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parsedebug().</span>
    <span class="s0">#</span>
    <span class="s0"># This is the debugging enabled version of parse().  All changes made to the</span>
    <span class="s0"># parsing engine should be made here.   Optimized versions of this function</span>
    <span class="s0"># are automatically created by the ply/ygen.py script.  This script cuts out</span>
    <span class="s0"># sections enclosed in markers such as this:</span>
    <span class="s0">#</span>
    <span class="s0">#      #--! DEBUG</span>
    <span class="s0">#      statements</span>
    <span class="s0">#      #--! DEBUG</span>
    <span class="s0">#</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parsedebug</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">#--! parsedebug-start</span>
        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack </span><span class="s3">= []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  </span><span class="s3">= </span><span class="s1">YaccProduction</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount </span><span class="s3">= </span><span class="s5">0                           </span><span class="s0"># Used during error recovery</span>

        <span class="s0">#--! DEBUG</span>
        <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'PLY: PARSE DEBUG START'</span><span class="s3">)</span>
        <span class="s0">#--! DEBUG</span>

        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer </span><span class="s3">= </span><span class="s1">lex</span><span class="s3">.</span><span class="s1">lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">parser </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">lexer</span><span class="s3">.</span><span class="s1">input</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">token</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">token </span><span class="s3">= </span><span class="s1">get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack </span><span class="s3">= []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">statestack </span><span class="s3">= </span><span class="s1">statestack</span>
        <span class="s1">symstack   </span><span class="s3">= []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">symstack </span><span class="s3">= </span><span class="s1">symstack</span>

        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
        <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>
        <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
        <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>

            <span class="s0">#--! DEBUG</span>
            <span class="s1">debug</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
            <span class="s1">debug</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'State  : %s'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">)</span>
            <span class="s0">#--! DEBUG</span>

            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">get_token</span><span class="s3">()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">actions</span><span class="s3">[</span><span class="s1">state</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ltype</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">defaulted_states</span><span class="s3">[</span><span class="s1">state</span><span class="s3">]</span>
                <span class="s0">#--! DEBUG</span>
                <span class="s1">debug</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'Defaulted state %s: Reduce using %d'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, -</span><span class="s1">t</span><span class="s3">)</span>
                <span class="s0">#--! DEBUG</span>

            <span class="s0">#--! DEBUG</span>
            <span class="s1">debug</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'Stack  : %s'</span><span class="s3">,</span>
                        <span class="s3">(</span><span class="s4">'%s . %s' </span><span class="s3">% (</span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">xx</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">symstack</span><span class="s3">][</span><span class="s5">1</span><span class="s3">:]), </span><span class="s1">str</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">))).</span><span class="s1">lstrip</span><span class="s3">())</span>
            <span class="s0">#--! DEBUG</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">t</span>

                    <span class="s0">#--! DEBUG</span>
                    <span class="s1">debug</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'Action : Shift and goto state %s'</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
                    <span class="s0">#--! DEBUG</span>

                    <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount</span><span class="s3">:</span>
                        <span class="s1">errorcount </span><span class="s3">-= </span><span class="s5">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">[-</span><span class="s1">t</span><span class="s3">]</span>
                    <span class="s1">pname </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s1">plen  </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s2">None</span>

                    <span class="s0">#--! DEBUG</span>
                    <span class="s2">if </span><span class="s1">plen</span><span class="s3">:</span>
                        <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Action : Reduce rule [%s] with %s and goto state %d'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">str</span><span class="s3">,</span>
                                   <span class="s4">'['</span><span class="s3">+</span><span class="s4">','</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">format_stack_entry</span><span class="s3">(</span><span class="s1">_v</span><span class="s3">.</span><span class="s1">value</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_v </span><span class="s2">in </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]])+</span><span class="s4">']'</span><span class="s3">,</span>
                                   <span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">-</span><span class="s1">plen</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">])</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Action : Reduce rule [%s] with %s and goto state %d'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">str</span><span class="s3">, [],</span>
                                   <span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">])</span>

                    <span class="s0">#--! DEBUG</span>

                    <span class="s2">if </span><span class="s1">plen</span><span class="s3">:</span>
                        <span class="s1">targ </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">-</span><span class="s5">1</span><span class="s3">:]</span>
                        <span class="s1">targ</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">sym</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">targ</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lexpos</span>
                            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">targ</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">, </span><span class="s4">'endlineno'</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">)</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">, </span><span class="s4">'endlexpos'</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">)</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s2">del </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Result : %s'</span><span class="s3">, </span><span class="s1">format_result</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">targ</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s3">:</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexpos</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s1">targ </span><span class="s3">= [</span><span class="s1">sym</span><span class="s3">]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Result : %s'</span><span class="s3">, </span><span class="s1">format_result</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
                            <span class="s0">#--! DEBUG</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">n </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'value'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s0">#--! DEBUG</span>
                    <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Done   : Returning %s'</span><span class="s3">, </span><span class="s1">format_result</span><span class="s3">(</span><span class="s1">result</span><span class="s3">))</span>
                    <span class="s1">debug</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'PLY: PARSE DEBUG END'</span><span class="s3">)</span>
                    <span class="s0">#--! DEBUG</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s3">:</span>

                <span class="s0">#--! DEBUG</span>
                <span class="s1">debug</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'Error  : %s'</span><span class="s3">,</span>
                            <span class="s3">(</span><span class="s4">'%s . %s' </span><span class="s3">% (</span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">xx</span><span class="s3">.</span><span class="s1">type </span><span class="s2">for </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">symstack</span><span class="s3">][</span><span class="s5">1</span><span class="s3">:]), </span><span class="s1">str</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">))).</span><span class="s1">lstrip</span><span class="s3">())</span>
                <span class="s0">#--! DEBUG</span>

                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                        <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lexer'</span><span class="s3">):</span>
                            <span class="s1">errtoken</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                        <span class="s1">tok </span><span class="s3">= </span><span class="s1">call_errorfunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">tok</span>
                            <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s5">0</span>
                            <span class="s2">if </span><span class="s1">lineno</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">% (</span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error, token=%s' </span><span class="s3">% </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">statestack</span><span class="s3">) &lt;= </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack</span><span class="s3">[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'error'</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'error'</span><span class="s3">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">)</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lexpos'</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">)</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lexpos'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lexpos</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">t</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

        <span class="s0">#--! parsedebug-end</span>

    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parseopt().</span>
    <span class="s0">#</span>
    <span class="s0"># Optimized version of parse() method.  DO NOT EDIT THIS CODE DIRECTLY!</span>
    <span class="s0"># This code is automatically generated by the ply/ygen.py script. Make</span>
    <span class="s0"># changes to the parsedebug() method instead.</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parseopt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">#--! parseopt-start</span>
        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack </span><span class="s3">= []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  </span><span class="s3">= </span><span class="s1">YaccProduction</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount </span><span class="s3">= </span><span class="s5">0                           </span><span class="s0"># Used during error recovery</span>


        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer </span><span class="s3">= </span><span class="s1">lex</span><span class="s3">.</span><span class="s1">lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">parser </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">lexer</span><span class="s3">.</span><span class="s1">input</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">token</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">token </span><span class="s3">= </span><span class="s1">get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack </span><span class="s3">= []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">statestack </span><span class="s3">= </span><span class="s1">statestack</span>
        <span class="s1">symstack   </span><span class="s3">= []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">symstack </span><span class="s3">= </span><span class="s1">symstack</span>

        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
        <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>
        <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
        <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>


            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">get_token</span><span class="s3">()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">actions</span><span class="s3">[</span><span class="s1">state</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ltype</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">defaulted_states</span><span class="s3">[</span><span class="s1">state</span><span class="s3">]</span>


            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">t</span>


                    <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount</span><span class="s3">:</span>
                        <span class="s1">errorcount </span><span class="s3">-= </span><span class="s5">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">[-</span><span class="s1">t</span><span class="s3">]</span>
                    <span class="s1">pname </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s1">plen  </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s2">None</span>


                    <span class="s2">if </span><span class="s1">plen</span><span class="s3">:</span>
                        <span class="s1">targ </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">-</span><span class="s5">1</span><span class="s3">:]</span>
                        <span class="s1">targ</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">sym</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">targ</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lexpos</span>
                            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">targ</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">, </span><span class="s4">'endlineno'</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">)</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">, </span><span class="s4">'endlexpos'</span><span class="s3">, </span><span class="s1">t1</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">)</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s2">del </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">targ</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s3">:</span>

                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexpos</span>
                        <span class="s0">#--! TRACKING</span>

                        <span class="s1">targ </span><span class="s3">= [</span><span class="s1">sym</span><span class="s3">]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">n </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'value'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s3">:</span>


                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                        <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lexer'</span><span class="s3">):</span>
                            <span class="s1">errtoken</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                        <span class="s1">tok </span><span class="s3">= </span><span class="s1">call_errorfunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">tok</span>
                            <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s5">0</span>
                            <span class="s2">if </span><span class="s1">lineno</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">% (</span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error, token=%s' </span><span class="s3">% </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">statestack</span><span class="s3">) &lt;= </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack</span><span class="s3">[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'error'</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'error'</span><span class="s3">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">)</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lexpos'</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">)</span>
                        <span class="s0">#--! TRACKING</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lexpos'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lexpos</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">t</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s2">if </span><span class="s1">tracking</span><span class="s3">:</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lineno</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">lexpos</span>
                    <span class="s0">#--! TRACKING</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

        <span class="s0">#--! parseopt-end</span>

    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
    <span class="s0"># parseopt_notrack().</span>
    <span class="s0">#</span>
    <span class="s0"># Optimized version of parseopt() with line number tracking removed.</span>
    <span class="s0"># DO NOT EDIT THIS CODE DIRECTLY. This code is automatically generated</span>
    <span class="s0"># by the ply/ygen.py script. Make changes to the parsedebug() method instead.</span>
    <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

    <span class="s2">def </span><span class="s1">parseopt_notrack</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">input</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">lexer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tracking</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">tokenfunc</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">#--! parseopt-notrack-start</span>
        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None                         </span><span class="s0"># Current lookahead symbol</span>
        <span class="s1">lookaheadstack </span><span class="s3">= []                      </span><span class="s0"># Stack of lookahead symbols</span>
        <span class="s1">actions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">action                    </span><span class="s0"># Local reference to action table (to avoid lookup on self.)</span>
        <span class="s1">goto    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">goto                      </span><span class="s0"># Local reference to goto table (to avoid lookup on self.)</span>
        <span class="s1">prod    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">productions               </span><span class="s0"># Local reference to production list (to avoid lookup on self.)</span>
        <span class="s1">defaulted_states </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">defaulted_states </span><span class="s0"># Local reference to defaulted states</span>
        <span class="s1">pslice  </span><span class="s3">= </span><span class="s1">YaccProduction</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)           </span><span class="s0"># Production object passed to grammar rules</span>
        <span class="s1">errorcount </span><span class="s3">= </span><span class="s5">0                           </span><span class="s0"># Used during error recovery</span>


        <span class="s0"># If no lexer was given, we will try to use the lex module</span>
        <span class="s2">if not </span><span class="s1">lexer</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">lex</span>
            <span class="s1">lexer </span><span class="s3">= </span><span class="s1">lex</span><span class="s3">.</span><span class="s1">lexer</span>

        <span class="s0"># Set up the lexer and parser objects on pslice</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">parser </span><span class="s3">= </span><span class="s1">self</span>

        <span class="s0"># If input was supplied, pass to lexer</span>
        <span class="s2">if </span><span class="s1">input </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">lexer</span><span class="s3">.</span><span class="s1">input</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">tokenfunc </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s0"># Tokenize function</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">token</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">get_token </span><span class="s3">= </span><span class="s1">tokenfunc</span>

        <span class="s0"># Set the parser() token method (sometimes used in error recovery)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">token </span><span class="s3">= </span><span class="s1">get_token</span>

        <span class="s0"># Set up the state and symbol stacks</span>

        <span class="s1">statestack </span><span class="s3">= []                </span><span class="s0"># Stack of parsing states</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">statestack </span><span class="s3">= </span><span class="s1">statestack</span>
        <span class="s1">symstack   </span><span class="s3">= []                </span><span class="s0"># Stack of grammar symbols</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">symstack </span><span class="s3">= </span><span class="s1">symstack</span>

        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">stack </span><span class="s3">= </span><span class="s1">symstack         </span><span class="s0"># Put in the production</span>
        <span class="s1">errtoken   </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># Err token</span>

        <span class="s0"># The start state is assumed to be (0,$end)</span>

        <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
        <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>
        <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
        <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s0"># Get the next symbol on the input.  If a lookahead symbol</span>
            <span class="s0"># is already set, we just use that. Otherwise, we'll pull</span>
            <span class="s0"># the next token off of the lookaheadstack or from the lexer</span>


            <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">defaulted_states</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                    <span class="s2">if not </span><span class="s1">lookaheadstack</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">get_token</span><span class="s3">()     </span><span class="s0"># Get the next token</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s2">if not </span><span class="s1">lookahead</span><span class="s3">:</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                        <span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'$end'</span>

                <span class="s0"># Check the action table</span>
                <span class="s1">ltype </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">actions</span><span class="s3">[</span><span class="s1">state</span><span class="s3">].</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ltype</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">t </span><span class="s3">= </span><span class="s1">defaulted_states</span><span class="s3">[</span><span class="s1">state</span><span class="s3">]</span>


            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># shift a symbol on the stack</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">t</span>


                    <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>

                    <span class="s0"># Decrease error count on successful shift</span>
                    <span class="s2">if </span><span class="s1">errorcount</span><span class="s3">:</span>
                        <span class="s1">errorcount </span><span class="s3">-= </span><span class="s5">1</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s0"># reduce a symbol on the stack, emit a production</span>
                    <span class="s1">p </span><span class="s3">= </span><span class="s1">prod</span><span class="s3">[-</span><span class="s1">t</span><span class="s3">]</span>
                    <span class="s1">pname </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span>
                    <span class="s1">plen  </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span>

                    <span class="s0"># Get production function</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">pname       </span><span class="s0"># Production name</span>
                    <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s2">None</span>


                    <span class="s2">if </span><span class="s1">plen</span><span class="s3">:</span>
                        <span class="s1">targ </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">-</span><span class="s5">1</span><span class="s3">:]</span>
                        <span class="s1">targ</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">sym</span>


                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># below as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s2">del </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s2">del </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s1">plen</span><span class="s3">:]</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">targ</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">])         </span><span class="s0"># Put the production slice back on the stack</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                    <span class="s2">else</span><span class="s3">:</span>


                        <span class="s1">targ </span><span class="s3">= [</span><span class="s1">sym</span><span class="s3">]</span>

                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
                        <span class="s0"># The code enclosed in this section is duplicated</span>
                        <span class="s0"># above as a performance optimization.  Make sure</span>
                        <span class="s0"># changes get made in both locations.</span>

                        <span class="s1">pslice</span><span class="s3">.</span><span class="s1">slice </span><span class="s3">= </span><span class="s1">targ</span>

                        <span class="s2">try</span><span class="s3">:</span>
                            <span class="s0"># Call the grammar rule with our special slice object</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                            <span class="s1">p</span><span class="s3">.</span><span class="s1">callable</span><span class="s3">(</span><span class="s1">pslice</span><span class="s3">)</span>
                            <span class="s1">symstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">sym</span><span class="s3">)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">goto</span><span class="s3">[</span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]][</span><span class="s1">pname</span><span class="s3">]</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">state</span><span class="s3">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                            <span class="s0"># If an error was set. Enter error recovery state</span>
                            <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)    </span><span class="s0"># Save the current lookahead token</span>
                            <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()                    </span><span class="s0"># Pop back one state (before the reduce)</span>
                            <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">sym</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s4">'error'</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">sym</span>
                            <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>

                        <span class="s2">continue</span>
                        <span class="s0"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>

                <span class="s2">if </span><span class="s1">t </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">n </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">result </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'value'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s2">return </span><span class="s1">result</span>

            <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s3">:</span>


                <span class="s0"># We have some kind of parsing error here.  To handle</span>
                <span class="s0"># this, we are going to push the current token onto</span>
                <span class="s0"># the tokenstack and replace it with an 'error' token.</span>
                <span class="s0"># If there are any synchronization rules, they may</span>
                <span class="s0"># catch it.</span>
                <span class="s0">#</span>
                <span class="s0"># In addition to pushing the error token, we call call</span>
                <span class="s0"># the user defined p_error() function if this is the</span>
                <span class="s0"># first syntax error.  This function is only called if</span>
                <span class="s0"># errorcount == 0.</span>
                <span class="s2">if </span><span class="s1">errorcount </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">errorok </span><span class="s3">= </span><span class="s2">False</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                        <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None               </span><span class="s0"># End of file!</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken </span><span class="s2">and not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lexer'</span><span class="s3">):</span>
                            <span class="s1">errtoken</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lexer</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">state </span><span class="s3">= </span><span class="s1">state</span>
                        <span class="s1">tok </span><span class="s3">= </span><span class="s1">call_errorfunc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorfunc</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">errorok</span><span class="s3">:</span>
                            <span class="s0"># User must have done some kind of panic</span>
                            <span class="s0"># mode recovery on their own.  The</span>
                            <span class="s0"># returned token is the next lookahead</span>
                            <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">tok</span>
                            <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                            <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">errtoken</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">errtoken</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">lineno </span><span class="s3">= </span><span class="s5">0</span>
                            <span class="s2">if </span><span class="s1">lineno</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error at line %d, token=%s</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">% (</span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">))</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Syntax error, token=%s' </span><span class="s3">% </span><span class="s1">errtoken</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'yacc: Parse error in input. EOF</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
                            <span class="s2">return</span>

                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">errorcount </span><span class="s3">= </span><span class="s1">error_count</span>

                <span class="s0"># case 1:  the statestack only has 1 entry on it.  If we're in this state, the</span>
                <span class="s0"># entire parse has been rolled back and we're completely hosed.   The token is</span>
                <span class="s0"># discarded and we just keep going.</span>

                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">statestack</span><span class="s3">) &lt;= </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">errtoken </span><span class="s3">= </span><span class="s2">None</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s0"># Nuke the pushback stack</span>
                    <span class="s2">del </span><span class="s1">lookaheadstack</span><span class="s3">[:]</span>
                    <span class="s2">continue</span>

                <span class="s0"># case 2: the statestack has a couple of entries on it, but we're</span>
                <span class="s0"># at the end of the file. nuke the top entry and generate an error token</span>

                <span class="s0"># Start nuking entries on the stack</span>
                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'$end'</span><span class="s3">:</span>
                    <span class="s0"># Whoa. We're really hosed here. Bail out</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">type </span><span class="s3">!= </span><span class="s4">'error'</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">sym</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s4">'error'</span><span class="s3">:</span>
                        <span class="s0"># Hmmm. Error is on top of stack, we'll just nuke input</span>
                        <span class="s0"># symbol and continue</span>
                        <span class="s1">lookahead </span><span class="s3">= </span><span class="s2">None</span>
                        <span class="s2">continue</span>

                    <span class="s0"># Create the error symbol for the first time and make it the new lookahead symbol</span>
                    <span class="s1">t </span><span class="s3">= </span><span class="s1">YaccSymbol</span><span class="s3">()</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s4">'error'</span>

                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lineno'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlineno </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lineno</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">, </span><span class="s4">'lexpos'</span><span class="s3">):</span>
                        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">endlexpos </span><span class="s3">= </span><span class="s1">lookahead</span><span class="s3">.</span><span class="s1">lexpos</span>
                    <span class="s1">t</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s1">lookahead</span>
                    <span class="s1">lookaheadstack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lookahead</span><span class="s3">)</span>
                    <span class="s1">lookahead </span><span class="s3">= </span><span class="s1">t</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">sym </span><span class="s3">= </span><span class="s1">symstack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s1">statestack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
                    <span class="s1">state </span><span class="s3">= </span><span class="s1">statestack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

                <span class="s2">continue</span>

            <span class="s0"># Call an error function here</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'yacc: internal parser error!!!</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

        <span class="s0">#--! parseopt-notrack-end</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                          === Grammar Representation ===</span>
<span class="s0">#</span>
<span class="s0"># The following functions, classes, and variables are used to represent and</span>
<span class="s0"># manipulate the rules that make up a grammar.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># regex matching identifiers</span>
<span class="s1">_is_identifier </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r'^[a-zA-Z0-9_-]+$'</span><span class="s3">)</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># class Production:</span>
<span class="s0">#</span>
<span class="s0"># This class stores the raw information about a single production or grammar rule.</span>
<span class="s0"># A grammar rule refers to a specification such as this:</span>
<span class="s0">#</span>
<span class="s0">#       expr : expr PLUS term</span>
<span class="s0">#</span>
<span class="s0"># Here are the basic attributes defined on all productions</span>
<span class="s0">#</span>
<span class="s0">#       name     - Name of the production.  For example 'expr'</span>
<span class="s0">#       prod     - A list of symbols on the right side ['expr','PLUS','term']</span>
<span class="s0">#       prec     - Production precedence level</span>
<span class="s0">#       number   - Production number.</span>
<span class="s0">#       func     - Function that executes on reduce</span>
<span class="s0">#       file     - File where production function is defined</span>
<span class="s0">#       lineno   - Line number where production function is defined</span>
<span class="s0">#</span>
<span class="s0"># The following attributes are defined or optional.</span>
<span class="s0">#</span>
<span class="s0">#       len       - Length of the production (number of symbols on right hand side)</span>
<span class="s0">#       usyms     - Set of unique symbols found in the production</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">Production</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s1">reduced </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">number</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">, </span><span class="s1">precedence</span><span class="s3">=(</span><span class="s4">'right'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), </span><span class="s1">func</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">file</span><span class="s3">=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">line</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name     </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prod     </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">number   </span><span class="s3">= </span><span class="s1">number</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func     </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">callable </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">file     </span><span class="s3">= </span><span class="s1">file</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">line     </span><span class="s3">= </span><span class="s1">line</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prec     </span><span class="s3">= </span><span class="s1">precedence</span>

        <span class="s0"># Internal settings used during table construction</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">len  </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)   </span><span class="s0"># Length of the production</span>

        <span class="s0"># Create a list of unique production symbols used in the production</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">usyms </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">usyms</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">usyms</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>

        <span class="s0"># List of all LR items for the production</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_items </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_next </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s0"># Create a string representation</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">str </span><span class="s3">= </span><span class="s4">'%s -&gt; %s' </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">str </span><span class="s3">= </span><span class="s4">'%s -&gt; &lt;empty&gt;' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">str</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">'Production(' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) + </span><span class="s4">')'</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__nonzero__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>

    <span class="s0"># Return the nth lr_item from the production (or None if at the end)</span>
    <span class="s2">def </span><span class="s1">lr_item</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">):</span>
            <span class="s2">return None</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">LRItem</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s0"># Precompute the list of productions immediately following.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">lr_after </span><span class="s3">= </span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]]</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">lr_after </span><span class="s3">= []</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">lr_before </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">n</span><span class="s3">-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">except </span><span class="s1">IndexError</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">lr_before </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">p</span>

    <span class="s0"># Bind the production function name to a callable</span>
    <span class="s2">def </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pdict</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">callable </span><span class="s3">= </span><span class="s1">pdict</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">]</span>

<span class="s0"># This class serves as a minimal standin for Production objects when</span>
<span class="s0"># reading table data from files.   It only contains information</span>
<span class="s0"># actually used by the LR parsing engine, plus some additional</span>
<span class="s0"># debugging information.</span>
<span class="s2">class </span><span class="s1">MiniProduction</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">len</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name     </span><span class="s3">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">len      </span><span class="s3">= </span><span class="s1">len</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">func     </span><span class="s3">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">callable </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">file     </span><span class="s3">= </span><span class="s1">file</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">line     </span><span class="s3">= </span><span class="s1">line</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">str      </span><span class="s3">= </span><span class="s1">str</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">str</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">'MiniProduction(%s)' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">str</span>

    <span class="s0"># Bind the production function name to a callable</span>
    <span class="s2">def </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pdict</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">callable </span><span class="s3">= </span><span class="s1">pdict</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">func</span><span class="s3">]</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># class LRItem</span>
<span class="s0">#</span>
<span class="s0"># This class represents a specific stage of parsing a production rule.  For</span>
<span class="s0"># example:</span>
<span class="s0">#</span>
<span class="s0">#       expr : expr . PLUS term</span>
<span class="s0">#</span>
<span class="s0"># In the above, the &quot;.&quot; represents the current location of the parse.  Here</span>
<span class="s0"># basic attributes:</span>
<span class="s0">#</span>
<span class="s0">#       name       - Name of the production.  For example 'expr'</span>
<span class="s0">#       prod       - A list of symbols on the right side ['expr','.', 'PLUS','term']</span>
<span class="s0">#       number     - Production number.</span>
<span class="s0">#</span>
<span class="s0">#       lr_next      Next LR item. Example, if we are ' expr -&gt; expr . PLUS term'</span>
<span class="s0">#                    then lr_next refers to 'expr -&gt; expr PLUS . term'</span>
<span class="s0">#       lr_index   - LR item index (location of the &quot;.&quot;) in the prod list.</span>
<span class="s0">#       lookaheads - LALR lookahead symbols for this item</span>
<span class="s0">#       len        - Length of the production (number of symbols on right hand side)</span>
<span class="s0">#       lr_after    - List of all productions that immediately follow</span>
<span class="s0">#       lr_before   - Grammar symbol immediately before</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRItem</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">name       </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prod       </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">number     </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_index   </span><span class="s3">= </span><span class="s1">n</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lookaheads </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'.'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prod       </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">len        </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">usyms      </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">usyms</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">'%s -&gt; %s' </span><span class="s3">% (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s4">'%s -&gt; &lt;empty&gt;' </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">name</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">'LRItem(' </span><span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) + </span><span class="s4">')'</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># rightmost_terminal()</span>
<span class="s0">#</span>
<span class="s0"># Return the rightmost terminal from a list of symbols.  Used in add_production()</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">def </span><span class="s1">rightmost_terminal</span><span class="s3">(</span><span class="s1">symbols</span><span class="s3">, </span><span class="s1">terminals</span><span class="s3">):</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">symbols</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s2">while </span><span class="s1">i </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">symbols</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">in </span><span class="s1">terminals</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">symbols</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">i </span><span class="s3">-= </span><span class="s5">1</span>
    <span class="s2">return None</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                           === GRAMMAR CLASS ===</span>
<span class="s0">#</span>
<span class="s0"># The following class represents the contents of the specified grammar along</span>
<span class="s0"># with various computed properties such as first sets, follow sets, LR items, etc.</span>
<span class="s0"># This data is used for critical parts of the table generation process later.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s1">YaccError</span><span class="s3">):</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">Grammar</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">terminals</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Productions  </span><span class="s3">= [</span><span class="s2">None</span><span class="s3">]  </span><span class="s0"># A list of all of the productions.  The first</span>
                                    <span class="s0"># entry is always reserved for the purpose of</span>
                                    <span class="s0"># building an augmented grammar</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames    </span><span class="s3">= {}      </span><span class="s0"># A dictionary mapping the names of nonterminals to a list of all</span>
                                    <span class="s0"># productions of that nonterminal.</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Prodmap      </span><span class="s3">= {}      </span><span class="s0"># A dictionary that is only used to detect duplicate</span>
                                    <span class="s0"># productions.</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals    </span><span class="s3">= {}      </span><span class="s0"># A dictionary mapping the names of terminal symbols to a</span>
                                    <span class="s0"># list of the rules where they are used.</span>

        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terminals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">[</span><span class="s1">term</span><span class="s3">] = []</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">[</span><span class="s4">'error'</span><span class="s3">] = []</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals </span><span class="s3">= {}      </span><span class="s0"># A dictionary mapping names of nonterminals to a list</span>
                                    <span class="s0"># of rule numbers where they are used.</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">First        </span><span class="s3">= {}      </span><span class="s0"># A dictionary of precomputed FIRST(x) symbols</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Follow       </span><span class="s3">= {}      </span><span class="s0"># A dictionary of precomputed FOLLOW(x) symbols</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence   </span><span class="s3">= {}      </span><span class="s0"># Precedence rules for each terminal. Contains tuples of the</span>
                                    <span class="s0"># form ('right',level) or ('nonassoc', level) or ('left',level)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">UsedPrecedence </span><span class="s3">= </span><span class="s1">set</span><span class="s3">() </span><span class="s0"># Precedence rules that were actually used by the grammer.</span>
                                    <span class="s0"># This is only used to provide error checking and to generate</span>
                                    <span class="s0"># a warning about unused precedence rules.</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Start </span><span class="s3">= </span><span class="s2">None           </span><span class="s0"># Starting symbol for the grammar</span>


    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s1">index</span><span class="s3">]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># set_precedence()</span>
    <span class="s0">#</span>
    <span class="s0"># Sets the precedence for a given terminal. assoc is the associativity such as</span>
    <span class="s0"># 'left','right', or 'nonassoc'.  level is a numeric level.</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">term</span><span class="s3">, </span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">level</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions </span><span class="s3">== [</span><span class="s2">None</span><span class="s3">], </span><span class="s4">'Must call set_precedence() before add_production()'</span>
        <span class="s2">if </span><span class="s1">term </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'Precedence already specified for terminal %r' </span><span class="s3">% </span><span class="s1">term</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">assoc </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'left'</span><span class="s3">, </span><span class="s4">'right'</span><span class="s3">, </span><span class="s4">'nonassoc'</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">&quot;Associativity must be one of 'left','right', or 'nonassoc'&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">[</span><span class="s1">term</span><span class="s3">] = (</span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">level</span><span class="s3">)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_production()</span>
    <span class="s0">#</span>
    <span class="s0"># Given an action function, this function assembles a production rule and</span>
    <span class="s0"># computes its precedence level.</span>
    <span class="s0">#</span>
    <span class="s0"># The production rule is supplied as a list of symbols.   For example,</span>
    <span class="s0"># a rule such as 'expr : expr PLUS term' has a production name of 'expr' and</span>
    <span class="s0"># symbols ['expr','PLUS','term'].</span>
    <span class="s0">#</span>
    <span class="s0"># Precedence is determined by the precedence of the right-most non-terminal</span>
    <span class="s0"># or the precedence of a terminal specified by %prec.</span>
    <span class="s0">#</span>
    <span class="s0"># A variety of error checks are performed to make sure production symbols</span>
    <span class="s0"># are valid and that %prec is used correctly.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_production</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms</span><span class="s3">, </span><span class="s1">func</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">file</span><span class="s3">=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">line</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>

        <span class="s2">if </span><span class="s1">prodname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Illegal rule name %r. Already defined as a token' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">prodname </span><span class="s3">== </span><span class="s4">'error'</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Illegal rule name %r. error is a reserved word' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">))</span>
        <span class="s2">if not </span><span class="s1">_is_identifier</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">prodname</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Illegal rule name %r' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">))</span>

        <span class="s0"># Look for literal tokens</span>
        <span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">syms</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">s</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">in </span><span class="s4">&quot;'</span><span class="s2">\&quot;</span><span class="s4">&quot;</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">c </span><span class="s3">= </span><span class="s1">eval</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
                    <span class="s2">if </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">c</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">):</span>
                        <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Literal token %s in rule %r may only be a single character' </span><span class="s3">%</span>
                                           <span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">))</span>
                    <span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = []</span>
                    <span class="s1">syms</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">c</span>
                    <span class="s2">continue</span>
                <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
                    <span class="s2">pass</span>
            <span class="s2">if not </span><span class="s1">_is_identifier</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) </span><span class="s2">and </span><span class="s1">s </span><span class="s3">!= </span><span class="s4">'%prec'</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Illegal name %r in rule %r' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">))</span>

        <span class="s0"># Determine the precedence level</span>
        <span class="s2">if </span><span class="s4">'%prec' </span><span class="s2">in </span><span class="s1">syms</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">syms</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s4">'%prec'</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Syntax error. Nothing follows %%prec' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">))</span>
            <span class="s2">if </span><span class="s1">syms</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] != </span><span class="s4">'%prec'</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Syntax error. %%prec can only appear at the end of a grammar rule' </span><span class="s3">%</span>
                                   <span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">))</span>
            <span class="s1">precname </span><span class="s3">= </span><span class="s1">syms</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">prodprec </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">precname</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">prodprec</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Nothing known about the precedence of %r' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">precname</span><span class="s3">))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">UsedPrecedence</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">precname</span><span class="s3">)</span>
            <span class="s2">del </span><span class="s1">syms</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">:]     </span><span class="s0"># Drop %prec from the rule</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># If no %prec, precedence is determined by the rightmost terminal symbol</span>
            <span class="s1">precname </span><span class="s3">= </span><span class="s1">rightmost_terminal</span><span class="s3">(</span><span class="s1">syms</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">)</span>
            <span class="s1">prodprec </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">precname</span><span class="s3">, (</span><span class="s4">'right'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

        <span class="s0"># See if the rule is already in the rulemap</span>
        <span class="s1">map </span><span class="s3">= </span><span class="s4">'%s -&gt; %s' </span><span class="s3">% (</span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">map </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodmap</span><span class="s3">:</span>
            <span class="s1">m </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodmap</span><span class="s3">[</span><span class="s1">map</span><span class="s3">]</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'%s:%d: Duplicate rule %s. ' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">m</span><span class="s3">) +</span>
                               <span class="s4">'Previous definition at %s:%d' </span><span class="s3">% (</span><span class="s1">m</span><span class="s3">.</span><span class="s1">file</span><span class="s3">, </span><span class="s1">m</span><span class="s3">.</span><span class="s1">line</span><span class="s3">))</span>

        <span class="s0"># From this point on, everything is valid.  Create a new Production instance</span>
        <span class="s1">pnumber  </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">prodname </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">[</span><span class="s1">prodname</span><span class="s3">] = []</span>

        <span class="s0"># Add the production number to Terminals and Nonterminals</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">syms</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">[</span><span class="s1">t</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pnumber</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = []</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">[</span><span class="s1">t</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pnumber</span><span class="s3">)</span>

        <span class="s0"># Create a production and add it to the list of productions</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">Production</span><span class="s3">(</span><span class="s1">pnumber</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms</span><span class="s3">, </span><span class="s1">prodprec</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Prodmap</span><span class="s3">[</span><span class="s1">map</span><span class="s3">] = </span><span class="s1">p</span>

        <span class="s0"># Add to the global productions list</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">prodname</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">prodname</span><span class="s3">] = [</span><span class="s1">p</span><span class="s3">]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># set_start()</span>
    <span class="s0">#</span>
    <span class="s0"># Sets the starting symbol and creates the augmented grammar.  Production</span>
    <span class="s0"># rule 0 is S' -&gt; start where start is the start symbol.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">set_start</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">start</span><span class="s3">:</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">name</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">GrammarError</span><span class="s3">(</span><span class="s4">'start symbol %s undefined' </span><span class="s3">% </span><span class="s1">start</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">Production</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s4">&quot;S'&quot;</span><span class="s3">, [</span><span class="s1">start</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">[</span><span class="s1">start</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">Start </span><span class="s3">= </span><span class="s1">start</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># find_unreachable()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all of the nonterminal symbols that can't be reached from the starting</span>
    <span class="s0"># symbol.  Returns a list of nonterminals that can't be reached.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">find_unreachable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s0"># Mark all symbols that are reachable from a symbol s</span>
        <span class="s2">def </span><span class="s1">mark_reachable_from</span><span class="s3">(</span><span class="s1">s</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">reachable</span><span class="s3">:</span>
                <span class="s2">return</span>
            <span class="s1">reachable</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, []):</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
                    <span class="s1">mark_reachable_from</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s1">reachable </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">mark_reachable_from</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">prod</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals </span><span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">reachable</span><span class="s3">]</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># infinite_cycles()</span>
    <span class="s0">#</span>
    <span class="s0"># This function looks at the various parsing rules and tries to detect</span>
    <span class="s0"># infinite recursion cycles (grammar rules where there is no possible way</span>
    <span class="s0"># to derive a string of only terminals).</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">infinite_cycles</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">terminates </span><span class="s3">= {}</span>

        <span class="s0"># Terminals:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
            <span class="s1">terminates</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s1">terminates</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s0"># Nonterminals:</span>

        <span class="s0"># Initialize to false:</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
            <span class="s1">terminates</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s2">False</span>

        <span class="s0"># Then propagate termination until no change:</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s1">some_change </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">pl</span><span class="s3">) </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                <span class="s0"># Nonterminal n terminates iff any of its productions terminates.</span>
                <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pl</span><span class="s3">:</span>
                    <span class="s0"># Production p terminates iff all of its rhs symbols terminate.</span>
                    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
                        <span class="s2">if not </span><span class="s1">terminates</span><span class="s3">[</span><span class="s1">s</span><span class="s3">]:</span>
                            <span class="s0"># The symbol s does not terminate,</span>
                            <span class="s0"># so production p does not terminate.</span>
                            <span class="s1">p_terminates </span><span class="s3">= </span><span class="s2">False</span>
                            <span class="s2">break</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s0"># didn't break from the loop,</span>
                        <span class="s0"># so every symbol s terminates</span>
                        <span class="s0"># so production p terminates.</span>
                        <span class="s1">p_terminates </span><span class="s3">= </span><span class="s2">True</span>

                    <span class="s2">if </span><span class="s1">p_terminates</span><span class="s3">:</span>
                        <span class="s0"># symbol n terminates!</span>
                        <span class="s2">if not </span><span class="s1">terminates</span><span class="s3">[</span><span class="s1">n</span><span class="s3">]:</span>
                            <span class="s1">terminates</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s2">True</span>
                            <span class="s1">some_change </span><span class="s3">= </span><span class="s2">True</span>
                        <span class="s0"># Don't need to consider any more productions for this n.</span>
                        <span class="s2">break</span>

            <span class="s2">if not </span><span class="s1">some_change</span><span class="s3">:</span>
                <span class="s2">break</span>

        <span class="s1">infinite </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">term</span><span class="s3">) </span><span class="s2">in </span><span class="s1">terminates</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if not </span><span class="s1">term</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames </span><span class="s2">and </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals </span><span class="s2">and </span><span class="s1">s </span><span class="s3">!= </span><span class="s4">'error'</span><span class="s3">:</span>
                    <span class="s0"># s is used-but-not-defined, and we've already warned of that,</span>
                    <span class="s0"># so it would be overkill to say that it's also non-terminating.</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">infinite</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">infinite</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># undefined_symbols()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all symbols that were used the grammar, but not defined as tokens or</span>
    <span class="s0"># grammar rules.  Returns a list of tuples (sym, prod) where sym in the symbol</span>
    <span class="s0"># and prod is the production where the symbol was used.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">undefined_symbols</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">p</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames </span><span class="s2">and </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals </span><span class="s2">and </span><span class="s1">s </span><span class="s3">!= </span><span class="s4">'error'</span><span class="s3">:</span>
                    <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">s</span><span class="s3">, </span><span class="s1">p</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># unused_terminals()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all terminals that were defined, but not used by the grammar.  Returns</span>
    <span class="s0"># a list of all symbols.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">unused_terminals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">unused_tok </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">s </span><span class="s3">!= </span><span class="s4">'error' </span><span class="s2">and not </span><span class="s1">v</span><span class="s3">:</span>
                <span class="s1">unused_tok</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">unused_tok</span>

    <span class="s0"># ------------------------------------------------------------------------------</span>
    <span class="s0"># unused_rules()</span>
    <span class="s0">#</span>
    <span class="s0"># Find all grammar rules that were defined,  but not used (maybe not reachable)</span>
    <span class="s0"># Returns a list of productions.</span>
    <span class="s0"># ------------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">unused_rules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">unused_prod </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if not </span><span class="s1">v</span><span class="s3">:</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">s</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">unused_prod</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">unused_prod</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># unused_precedence()</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a list of tuples (term,precedence) corresponding to precedence</span>
    <span class="s0"># rules that were never used by the grammar.  term is the name of the terminal</span>
    <span class="s0"># on which precedence was applied and precedence is a string such as 'left' or</span>
    <span class="s0"># 'right' corresponding to the type of precedence.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">unused_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">unused </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">termname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s3">(</span><span class="s1">termname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals </span><span class="s2">or </span><span class="s1">termname </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">UsedPrecedence</span><span class="s3">):</span>
                <span class="s1">unused</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">termname</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Precedence</span><span class="s3">[</span><span class="s1">termname</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]))</span>

        <span class="s2">return </span><span class="s1">unused</span>

    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s0"># _first()</span>
    <span class="s0">#</span>
    <span class="s0"># Compute the value of FIRST1(beta) where beta is a tuple of symbols.</span>
    <span class="s0">#</span>
    <span class="s0"># During execution of compute_first1, the result may be incomplete.</span>
    <span class="s0"># Afterward (e.g., when called from compute_follow()), it will be complete.</span>
    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">_first</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">):</span>

        <span class="s0"># We are computing First(x1,x2,x3,...,xn)</span>
        <span class="s1">result </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">beta</span><span class="s3">:</span>
            <span class="s1">x_produces_empty </span><span class="s3">= </span><span class="s2">False</span>

            <span class="s0"># Add all the non-&lt;empty&gt; symbols of First[x] to the result.</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]:</span>
                <span class="s2">if </span><span class="s1">f </span><span class="s3">== </span><span class="s4">'&lt;empty&gt;'</span><span class="s3">:</span>
                    <span class="s1">x_produces_empty </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">result</span><span class="s3">:</span>
                        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">x_produces_empty</span><span class="s3">:</span>
                <span class="s0"># We have to consider the next x in beta,</span>
                <span class="s0"># i.e. stay in the loop.</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># We don't have to consider any further symbols in beta.</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># There was no 'break' from the loop,</span>
            <span class="s0"># so x_produces_empty was true for all x in beta,</span>
            <span class="s0"># so beta produces empty as well.</span>
            <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'&lt;empty&gt;'</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s0"># compute_first()</span>
    <span class="s0">#</span>
    <span class="s0"># Compute the value of FIRST1(X) for all symbols</span>
    <span class="s0"># -------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">compute_first</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span>

        <span class="s0"># Terminals:</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = [</span><span class="s1">t</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = [</span><span class="s4">'$end'</span><span class="s3">]</span>

        <span class="s0"># Nonterminals:</span>

        <span class="s0"># Initialize to the empty set:</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = []</span>

        <span class="s0"># Then propagate symbols until no change:</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s1">some_change </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">n</span><span class="s3">]:</span>
                    <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_first</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">):</span>
                        <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s1">n</span><span class="s3">]:</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">[</span><span class="s1">n</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
                            <span class="s1">some_change </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">if not </span><span class="s1">some_change</span><span class="s3">:</span>
                <span class="s2">break</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span>

    <span class="s0"># ---------------------------------------------------------------------</span>
    <span class="s0"># compute_follow()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes all of the follow sets for every non-terminal symbol.  The</span>
    <span class="s0"># follow set is the set of all symbols that might follow a given</span>
    <span class="s0"># non-terminal.  See the Dragon book, 2nd Ed. p. 189.</span>
    <span class="s0"># ---------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">compute_follow</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># If already computed, return the result</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span>

        <span class="s0"># If first sets not computed yet, do that first.</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">First</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">compute_first</span><span class="s3">()</span>

        <span class="s0"># Add '$end' to the follow list of the start symbol</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = []</span>

        <span class="s2">if not </span><span class="s1">start</span><span class="s3">:</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">name</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">start</span><span class="s3">] = [</span><span class="s4">'$end'</span><span class="s3">]</span>

        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s1">didadd </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]:</span>
                <span class="s0"># Here is the production set</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">B </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">B </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
                        <span class="s0"># Okay. We got a non-terminal in a production</span>
                        <span class="s1">fst </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_first</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:])</span>
                        <span class="s1">hasempty </span><span class="s3">= </span><span class="s2">False</span>
                        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fst</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">f </span><span class="s3">!= </span><span class="s4">'&lt;empty&gt;' </span><span class="s2">and </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">B</span><span class="s3">]:</span>
                                <span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">B</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
                                <span class="s1">didadd </span><span class="s3">= </span><span class="s2">True</span>
                            <span class="s2">if </span><span class="s1">f </span><span class="s3">== </span><span class="s4">'&lt;empty&gt;'</span><span class="s3">:</span>
                                <span class="s1">hasempty </span><span class="s3">= </span><span class="s2">True</span>
                        <span class="s2">if </span><span class="s1">hasempty </span><span class="s2">or </span><span class="s1">i </span><span class="s3">== (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">)-</span><span class="s5">1</span><span class="s3">):</span>
                            <span class="s0"># Add elements of follow(a) to follow(b)</span>
                            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]:</span>
                                <span class="s2">if </span><span class="s1">f </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">B</span><span class="s3">]:</span>
                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">B</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
                                    <span class="s1">didadd </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">if not </span><span class="s1">didadd</span><span class="s3">:</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Follow</span>


    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># build_lritems()</span>
    <span class="s0">#</span>
    <span class="s0"># This function walks the list of productions and builds a complete set of the</span>
    <span class="s0"># LR items.  The LR items are stored in two ways:  First, they are uniquely</span>
    <span class="s0"># numbered and placed in the list _lritems.  Second, a linked list of LR items</span>
    <span class="s0"># is built for each production.  For example:</span>
    <span class="s0">#</span>
    <span class="s0">#   E -&gt; E PLUS E</span>
    <span class="s0">#</span>
    <span class="s0"># Creates the list</span>
    <span class="s0">#</span>
    <span class="s0">#  [E -&gt; . E PLUS E, E -&gt; E . PLUS E, E -&gt; E PLUS . E, E -&gt; E PLUS E . ]</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">build_lritems</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">:</span>
            <span class="s1">lastlri </span><span class="s3">= </span><span class="s1">p</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">lr_items </span><span class="s3">= []</span>
            <span class="s2">while True</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
                    <span class="s1">lri </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">lri </span><span class="s3">= </span><span class="s1">LRItem</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
                    <span class="s0"># Precompute the list of productions immediately following</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">lri</span><span class="s3">.</span><span class="s1">lr_after </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">Prodnames</span><span class="s3">[</span><span class="s1">lri</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]]</span>
                    <span class="s2">except </span><span class="s3">(</span><span class="s1">IndexError</span><span class="s3">, </span><span class="s1">KeyError</span><span class="s3">):</span>
                        <span class="s1">lri</span><span class="s3">.</span><span class="s1">lr_after </span><span class="s3">= []</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">lri</span><span class="s3">.</span><span class="s1">lr_before </span><span class="s3">= </span><span class="s1">lri</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">except </span><span class="s1">IndexError</span><span class="s3">:</span>
                        <span class="s1">lri</span><span class="s3">.</span><span class="s1">lr_before </span><span class="s3">= </span><span class="s2">None</span>

                <span class="s1">lastlri</span><span class="s3">.</span><span class="s1">lr_next </span><span class="s3">= </span><span class="s1">lri</span>
                <span class="s2">if not </span><span class="s1">lri</span><span class="s3">:</span>
                    <span class="s2">break</span>
                <span class="s1">lr_items</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">lri</span><span class="s3">)</span>
                <span class="s1">lastlri </span><span class="s3">= </span><span class="s1">lri</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">lr_items </span><span class="s3">= </span><span class="s1">lr_items</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                            == Class LRTable ==</span>
<span class="s0">#</span>
<span class="s0"># This basic class represents a basic table of LR parsing information.</span>
<span class="s0"># Methods for generating the tables are not defined here.  They are defined</span>
<span class="s0"># in the derived class LRGeneratedTable.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">VersionError</span><span class="s3">(</span><span class="s1">YaccError</span><span class="s3">):</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">LRTable</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">read_table</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">module</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
            <span class="s1">parsetab </span><span class="s3">= </span><span class="s1">module</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">exec</span><span class="s3">(</span><span class="s4">'import %s' </span><span class="s3">% </span><span class="s1">module</span><span class="s3">)</span>
            <span class="s1">parsetab </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">module</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_tabversion </span><span class="s3">!= </span><span class="s1">__tabversion__</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">VersionError</span><span class="s3">(</span><span class="s4">'yacc table file version is out of date'</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action </span><span class="s3">= </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_lr_action</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto </span><span class="s3">= </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_lr_goto</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_lr_productions</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">MiniProduction</span><span class="s3">(*</span><span class="s1">p</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">= </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_lr_method</span>
        <span class="s2">return </span><span class="s1">parsetab</span><span class="s3">.</span><span class="s1">_lr_signature</span>

    <span class="s2">def </span><span class="s1">read_pickle</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">cPickle </span><span class="s2">as </span><span class="s1">pickle</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">pickle</span>

        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">exists</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">):</span>
          <span class="s2">raise </span><span class="s1">ImportError</span>

        <span class="s1">in_f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>

        <span class="s1">tabversion </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tabversion </span><span class="s3">!= </span><span class="s1">__tabversion__</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">VersionError</span><span class="s3">(</span><span class="s4">'yacc table file version is out of date'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>
        <span class="s1">signature      </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto   </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>
        <span class="s1">productions    </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">in_f</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">productions</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">MiniProduction</span><span class="s3">(*</span><span class="s1">p</span><span class="s3">))</span>

        <span class="s1">in_f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">signature</span>

    <span class="s0"># Bind all production function names to callable objects in pdict</span>
    <span class="s2">def </span><span class="s1">bind_callables</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pdict</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions</span><span class="s3">:</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">bind</span><span class="s3">(</span><span class="s1">pdict</span><span class="s3">)</span>


<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                           === LR Generator ===</span>
<span class="s0">#</span>
<span class="s0"># The following classes and functions are used to generate LR parsing tables on</span>
<span class="s0"># a grammar.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># digraph()</span>
<span class="s0"># traverse()</span>
<span class="s0">#</span>
<span class="s0"># The following two functions are used to compute set valued functions</span>
<span class="s0"># of the form:</span>
<span class="s0">#</span>
<span class="s0">#     F(x) = F'(x) U U{F(y) | x R y}</span>
<span class="s0">#</span>
<span class="s0"># This is used to compute the values of Read() sets as well as FOLLOW sets</span>
<span class="s0"># in LALR(1) generation.</span>
<span class="s0">#</span>
<span class="s0"># Inputs:  X    - An input set</span>
<span class="s0">#          R    - A relation</span>
<span class="s0">#          FP   - Set-valued function</span>
<span class="s0"># ------------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">digraph</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">):</span>
    <span class="s1">N </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">X</span><span class="s3">:</span>
        <span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s5">0</span>
    <span class="s1">stack </span><span class="s3">= []</span>
    <span class="s1">F </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">X</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">traverse</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">, </span><span class="s1">F</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">F</span>

<span class="s2">def </span><span class="s1">traverse</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">, </span><span class="s1">F</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">):</span>
    <span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">stack</span><span class="s3">)</span>
    <span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">d</span>
    <span class="s1">F</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">FP</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)             </span><span class="s0"># F(X) &lt;- F'(x)</span>

    <span class="s1">rel </span><span class="s3">= </span><span class="s1">R</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)               </span><span class="s0"># Get y's related to x</span>
    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">rel</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">N</span><span class="s3">[</span><span class="s1">y</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">traverse</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">stack</span><span class="s3">, </span><span class="s1">F</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">)</span>
        <span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">min</span><span class="s3">(</span><span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">], </span><span class="s1">N</span><span class="s3">[</span><span class="s1">y</span><span class="s3">])</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">F</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, []):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">F</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]:</span>
                <span class="s1">F</span><span class="s3">[</span><span class="s1">x</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">N</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] == </span><span class="s1">d</span><span class="s3">:</span>
        <span class="s1">N</span><span class="s3">[</span><span class="s1">stack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">MAXINT</span>
        <span class="s1">F</span><span class="s3">[</span><span class="s1">stack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">F</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]</span>
        <span class="s1">element </span><span class="s3">= </span><span class="s1">stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
        <span class="s2">while </span><span class="s1">element </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">N</span><span class="s3">[</span><span class="s1">stack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">MAXINT</span>
            <span class="s1">F</span><span class="s3">[</span><span class="s1">stack</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]] = </span><span class="s1">F</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]</span>
            <span class="s1">element </span><span class="s3">= </span><span class="s1">stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>

<span class="s2">class </span><span class="s1">LALRError</span><span class="s3">(</span><span class="s1">YaccError</span><span class="s3">):</span>
    <span class="s2">pass</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                             == LRGeneratedTable ==</span>
<span class="s0">#</span>
<span class="s0"># This class implements the LR table generation algorithm.  There are no</span>
<span class="s0"># public methods except for write()</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">class </span><span class="s1">LRGeneratedTable</span><span class="s3">(</span><span class="s1">LRTable</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">grammar</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'LALR'</span><span class="s3">, </span><span class="s1">log</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'SLR'</span><span class="s3">, </span><span class="s4">'LALR'</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">LALRError</span><span class="s3">(</span><span class="s4">'Unsupported method %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar </span><span class="s3">= </span><span class="s1">grammar</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">= </span><span class="s1">method</span>

        <span class="s0"># Set up the logger</span>
        <span class="s2">if not </span><span class="s1">log</span><span class="s3">:</span>
            <span class="s1">log </span><span class="s3">= </span><span class="s1">NullLogger</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">log </span><span class="s3">= </span><span class="s1">log</span>

        <span class="s0"># Internal attributes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action     </span><span class="s3">= {}        </span><span class="s0"># Action table</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto       </span><span class="s3">= {}        </span><span class="s0"># Goto table</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions  </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions    </span><span class="s0"># Copy of grammar Production array</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto_cache </span><span class="s3">= {}        </span><span class="s0"># Cache of computed gotos</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash   </span><span class="s3">= {}        </span><span class="s0"># Cache of closures</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_count    </span><span class="s3">= </span><span class="s5">0         </span><span class="s0"># Internal counter used to detect cycles</span>

        <span class="s0"># Diagonistic information filled in by the table generator</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflict   </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">rr_conflict   </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">conflicts     </span><span class="s3">= []        </span><span class="s0"># List of conflicts</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflicts  </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">rr_conflicts  </span><span class="s3">= []</span>

        <span class="s0"># Build the tables</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">build_lritems</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">compute_first</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">compute_follow</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_parse_table</span><span class="s3">()</span>

    <span class="s0"># Compute the LR(0) closure operation on I, where I is a set of LR(0) items.</span>

    <span class="s2">def </span><span class="s1">lr0_closure</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">I</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_add_count </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s0"># Add everything in I to J</span>
        <span class="s1">J </span><span class="s3">= </span><span class="s1">I</span><span class="s3">[:]</span>
        <span class="s1">didadd </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">didadd</span><span class="s3">:</span>
            <span class="s1">didadd </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">J</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">j</span><span class="s3">.</span><span class="s1">lr_after</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s4">'lr0_added'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) == </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_count</span><span class="s3">:</span>
                        <span class="s2">continue</span>
                    <span class="s0"># Add B --&gt; .G to J</span>
                    <span class="s1">J</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">lr_next</span><span class="s3">)</span>
                    <span class="s1">x</span><span class="s3">.</span><span class="s1">lr0_added </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_add_count</span>
                    <span class="s1">didadd </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">J</span>

    <span class="s0"># Compute the LR(0) goto function goto(I,X) where I is a set</span>
    <span class="s0"># of LR(0) items and X is a grammar symbol.   This function is written</span>
    <span class="s0"># in a way that guarantees uniqueness of the generated goto sets</span>
    <span class="s0"># (i.e. the same goto set will never be returned as two different Python</span>
    <span class="s0"># objects).  With uniqueness, we can later do fast set comparisons using</span>
    <span class="s0"># id(obj) instead of element-wise comparison.</span>

    <span class="s2">def </span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">I</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s0"># First we look for a previously cached entry</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto_cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">((</span><span class="s1">id</span><span class="s3">(</span><span class="s1">I</span><span class="s3">), </span><span class="s1">x</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">g</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">g</span>

        <span class="s0"># Now we generate the goto set in a way that guarantees uniqueness</span>
        <span class="s0"># of the result</span>

        <span class="s1">s </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto_cache</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">s</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= {}</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto_cache</span><span class="s3">[</span><span class="s1">x</span><span class="s3">] = </span><span class="s1">s</span>

        <span class="s1">gs </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I</span><span class="s3">:</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_next</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s2">and </span><span class="s1">n</span><span class="s3">.</span><span class="s1">lr_before </span><span class="s3">== </span><span class="s1">x</span><span class="s3">:</span>
                <span class="s1">s1 </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
                <span class="s2">if not </span><span class="s1">s1</span><span class="s3">:</span>
                    <span class="s1">s1 </span><span class="s3">= {}</span>
                    <span class="s1">s</span><span class="s3">[</span><span class="s1">id</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)] = </span><span class="s1">s1</span>
                <span class="s1">gs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">s1</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">s</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'$end'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">g</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">gs</span><span class="s3">:</span>
                <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_closure</span><span class="s3">(</span><span class="s1">gs</span><span class="s3">)</span>
                <span class="s1">s</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = </span><span class="s1">g</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">s</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = </span><span class="s1">gs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto_cache</span><span class="s3">[(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">I</span><span class="s3">), </span><span class="s1">x</span><span class="s3">)] = </span><span class="s1">g</span>
        <span class="s2">return </span><span class="s1">g</span>

    <span class="s0"># Compute the LR(0) sets of item function</span>
    <span class="s2">def </span><span class="s1">lr0_items</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">C </span><span class="s3">= [</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_closure</span><span class="s3">([</span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">lr_next</span><span class="s3">])]</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">I </span><span class="s2">in </span><span class="s1">C</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">[</span><span class="s1">id</span><span class="s3">(</span><span class="s1">I</span><span class="s3">)] = </span><span class="s1">i</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>

        <span class="s0"># Loop over the items in C and each grammar symbols</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">):</span>
            <span class="s1">I </span><span class="s3">= </span><span class="s1">C</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s5">1</span>

            <span class="s0"># Collect all of the symbols that could possibly be in the goto(I,X) sets</span>
            <span class="s1">asyms </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">I</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ii</span><span class="s3">.</span><span class="s1">usyms</span><span class="s3">:</span>
                    <span class="s1">asyms</span><span class="s3">[</span><span class="s1">s</span><span class="s3">] = </span><span class="s2">None</span>

            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">asyms</span><span class="s3">:</span>
                <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">I</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">g </span><span class="s2">or </span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">) </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">:</span>
                    <span class="s2">continue</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">[</span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">)] = </span><span class="s1">len</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>
                <span class="s1">C</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">g</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">C</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0">#                       ==== LALR(1) Parsing ====</span>
    <span class="s0">#</span>
    <span class="s0"># LALR(1) parsing is almost exactly the same as SLR except that instead of</span>
    <span class="s0"># relying upon Follow() sets when performing reductions, a more selective</span>
    <span class="s0"># lookahead set that incorporates the state of the LR(0) machine is utilized.</span>
    <span class="s0"># Thus, we mainly just have to focus on calculating the lookahead sets.</span>
    <span class="s0">#</span>
    <span class="s0"># The method used here is due to DeRemer and Pennelo (1982).</span>
    <span class="s0">#</span>
    <span class="s0"># DeRemer, F. L., and T. J. Pennelo: &quot;Efficient Computation of LALR(1)</span>
    <span class="s0">#     Lookahead Sets&quot;, ACM Transactions on Programming Languages and Systems,</span>
    <span class="s0">#     Vol. 4, No. 4, Oct. 1982, pp. 615-649</span>
    <span class="s0">#</span>
    <span class="s0"># Further details can also be found in:</span>
    <span class="s0">#</span>
    <span class="s0">#  J. Tremblay and P. Sorenson, &quot;The Theory and Practice of Compiler Writing&quot;,</span>
    <span class="s0">#      McGraw-Hill Book Company, (1985).</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_nullable_nonterminals()</span>
    <span class="s0">#</span>
    <span class="s0"># Creates a dictionary containing all of the non-terminals that might produce</span>
    <span class="s0"># an empty production.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_nullable_nonterminals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">nullable </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">num_nullable </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]:</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">nullable</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">continue</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">nullable</span><span class="s3">:</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">nullable</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nullable</span><span class="s3">) == </span><span class="s1">num_nullable</span><span class="s3">:</span>
                <span class="s2">break</span>
            <span class="s1">num_nullable </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">nullable</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">nullable</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># find_nonterminal_trans(C)</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, this functions finds all of the non-terminal</span>
    <span class="s0"># transitions.    These are transitions in which a dot appears immediately before</span>
    <span class="s0"># a non-terminal.   Returns a list of tuples of the form (state,N) where state</span>
    <span class="s0"># is the state number and N is the nonterminal symbol.</span>
    <span class="s0">#</span>
    <span class="s0"># The input C is the set of LR(0) items.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">find_nonterminal_transitions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">):</span>
        <span class="s1">trans </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">stateno</span><span class="s3">, </span><span class="s1">state </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">C</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">state</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index </span><span class="s3">&lt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">t </span><span class="s3">= (</span><span class="s1">stateno</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index</span><span class="s3">+</span><span class="s5">1</span><span class="s3">])</span>
                    <span class="s2">if </span><span class="s1">t</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">trans</span><span class="s3">:</span>
                            <span class="s1">trans</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">trans</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># dr_relation()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the DR(p,A) relationships for non-terminal transitions.  The input</span>
    <span class="s0"># is a tuple (state,N) where state is a number and N is a nonterminal symbol.</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a list of terminals.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">dr_relation</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">):</span>
        <span class="s1">dr_set </span><span class="s3">= {}</span>
        <span class="s1">state</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s1">trans</span>
        <span class="s1">terms </span><span class="s3">= []</span>

        <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">C</span><span class="s3">[</span><span class="s1">state</span><span class="s3">], </span><span class="s1">N</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">g</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index </span><span class="s3">&lt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">terms</span><span class="s3">:</span>
                        <span class="s1">terms</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

        <span class="s0"># This extra bit is to handle the start state</span>
        <span class="s2">if </span><span class="s1">state </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">N </span><span class="s3">== </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">prod</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
            <span class="s1">terms</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">'$end'</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">terms</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># reads_relation()</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the READS() relation (p,A) READS (t,C).</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">reads_relation</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">empty</span><span class="s3">):</span>
        <span class="s0"># Look for empty transitions</span>
        <span class="s1">rel </span><span class="s3">= []</span>
        <span class="s1">state</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s1">trans</span>

        <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">C</span><span class="s3">[</span><span class="s1">state</span><span class="s3">], </span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">), -</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">g</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index </span><span class="s3">&lt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">empty</span><span class="s3">:</span>
                    <span class="s1">rel</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">j</span><span class="s3">, </span><span class="s1">a</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">rel</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_lookback_includes()</span>
    <span class="s0">#</span>
    <span class="s0"># Determines the lookback and includes relations</span>
    <span class="s0">#</span>
    <span class="s0"># LOOKBACK:</span>
    <span class="s0">#</span>
    <span class="s0"># This relation is determined by running the LR(0) state machine forward.</span>
    <span class="s0"># For example, starting with a production &quot;N : . A B C&quot;, we run it forward</span>
    <span class="s0"># to obtain &quot;N : A B C .&quot;   We then build a relationship between this final</span>
    <span class="s0"># state and the starting state.   These relationships are stored in a dictionary</span>
    <span class="s0"># lookdict.</span>
    <span class="s0">#</span>
    <span class="s0"># INCLUDES:</span>
    <span class="s0">#</span>
    <span class="s0"># Computes the INCLUDE() relation (p,A) INCLUDES (p',B).</span>
    <span class="s0">#</span>
    <span class="s0"># This relation is used to determine non-terminal transitions that occur</span>
    <span class="s0"># inside of other non-terminal transition states.   (p,A) INCLUDES (p', B)</span>
    <span class="s0"># if the following holds:</span>
    <span class="s0">#</span>
    <span class="s0">#       B -&gt; LAT, where T -&gt; epsilon and p' -L-&gt; p</span>
    <span class="s0">#</span>
    <span class="s0"># L is essentially a prefix (which may be empty), T is a suffix that must be</span>
    <span class="s0"># able to derive an empty string.  State p' must lead to state p with the string L.</span>
    <span class="s0">#</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_lookback_includes</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">):</span>
        <span class="s1">lookdict </span><span class="s3">= {}          </span><span class="s0"># Dictionary of lookback relations</span>
        <span class="s1">includedict </span><span class="s3">= {}       </span><span class="s0"># Dictionary of include relations</span>

        <span class="s0"># Make a dictionary of non-terminal transitions</span>
        <span class="s1">dtrans </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">trans</span><span class="s3">:</span>
            <span class="s1">dtrans</span><span class="s3">[</span><span class="s1">t</span><span class="s3">] = </span><span class="s5">1</span>

        <span class="s0"># Loop over all transitions and compute lookbacks and includes</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">N </span><span class="s2">in </span><span class="s1">trans</span><span class="s3">:</span>
            <span class="s1">lookb </span><span class="s3">= []</span>
            <span class="s1">includes </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">C</span><span class="s3">[</span><span class="s1">state</span><span class="s3">]:</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s1">N</span><span class="s3">:</span>
                    <span class="s2">continue</span>

                <span class="s0"># Okay, we have a name match.  We now follow the production all the way</span>
                <span class="s0"># through the state machine until we get the . on the right hand side</span>

                <span class="s1">lr_index </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index</span>
                <span class="s1">j </span><span class="s3">= </span><span class="s1">state</span>
                <span class="s2">while </span><span class="s1">lr_index </span><span class="s3">&lt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
                    <span class="s1">lr_index </span><span class="s3">= </span><span class="s1">lr_index </span><span class="s3">+ </span><span class="s5">1</span>
                    <span class="s1">t </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">lr_index</span><span class="s3">]</span>

                    <span class="s0"># Check to see if this symbol and state are a non-terminal transition</span>
                    <span class="s2">if </span><span class="s3">(</span><span class="s1">j</span><span class="s3">, </span><span class="s1">t</span><span class="s3">) </span><span class="s2">in </span><span class="s1">dtrans</span><span class="s3">:</span>
                        <span class="s0"># Yes.  Okay, there is some chance that this is an includes relation</span>
                        <span class="s0"># the only way to know for certain is whether the rest of the</span>
                        <span class="s0"># production derives empty</span>

                        <span class="s1">li </span><span class="s3">= </span><span class="s1">lr_index </span><span class="s3">+ </span><span class="s5">1</span>
                        <span class="s2">while </span><span class="s1">li </span><span class="s3">&lt; </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">:</span>
                            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">li</span><span class="s3">] </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
                                <span class="s2">break      </span><span class="s0"># No forget it</span>
                            <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">li</span><span class="s3">] </span><span class="s2">not in </span><span class="s1">nullable</span><span class="s3">:</span>
                                <span class="s2">break</span>
                            <span class="s1">li </span><span class="s3">= </span><span class="s1">li </span><span class="s3">+ </span><span class="s5">1</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s0"># Appears to be a relation between (j,t) and (state,N)</span>
                            <span class="s1">includes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">j</span><span class="s3">, </span><span class="s1">t</span><span class="s3">))</span>

                    <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">C</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">t</span><span class="s3">)               </span><span class="s0"># Go to next set</span>
                    <span class="s1">j </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">), -</span><span class="s5">1</span><span class="s3">)      </span><span class="s0"># Go to next state</span>

                <span class="s0"># When we get here, j is the final state, now we have to locate the production</span>
                <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">C</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]:</span>
                    <span class="s2">if </span><span class="s1">r</span><span class="s3">.</span><span class="s1">name </span><span class="s3">!= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">r</span><span class="s3">.</span><span class="s1">len </span><span class="s3">!= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">:</span>
                        <span class="s2">continue</span>
                    <span class="s1">i </span><span class="s3">= </span><span class="s5">0</span>
                    <span class="s0"># This look is comparing a production &quot;. A B C&quot; with &quot;A B C .&quot;</span>
                    <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">r</span><span class="s3">.</span><span class="s1">lr_index</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">r</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]:</span>
                            <span class="s2">break</span>
                        <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">lookb</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">j</span><span class="s3">, </span><span class="s1">r</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">includes</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">includedict</span><span class="s3">:</span>
                    <span class="s1">includedict</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = []</span>
                <span class="s1">includedict</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">append</span><span class="s3">((</span><span class="s1">state</span><span class="s3">, </span><span class="s1">N</span><span class="s3">))</span>
            <span class="s1">lookdict</span><span class="s3">[(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)] = </span><span class="s1">lookb</span>

        <span class="s2">return </span><span class="s1">lookdict</span><span class="s3">, </span><span class="s1">includedict</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_read_sets()</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, this function computes the read sets.</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:  C        =  Set of LR(0) items</span>
    <span class="s0">#          ntrans   = Set of nonterminal transitions</span>
    <span class="s0">#          nullable = Set of empty transitions</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a set containing the read sets</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_read_sets</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">ntrans</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">):</span>
        <span class="s1">FP </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dr_relation</span><span class="s3">(</span><span class="s1">C</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">)</span>
        <span class="s1">R </span><span class="s3">=  </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">self</span><span class="s3">.</span><span class="s1">reads_relation</span><span class="s3">(</span><span class="s1">C</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">)</span>
        <span class="s1">F </span><span class="s3">= </span><span class="s1">digraph</span><span class="s3">(</span><span class="s1">ntrans</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">F</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># compute_follow_sets()</span>
    <span class="s0">#</span>
    <span class="s0"># Given a set of LR(0) items, a set of non-terminal transitions, a readset,</span>
    <span class="s0"># and an include set, this function computes the follow sets</span>
    <span class="s0">#</span>
    <span class="s0"># Follow(p,A) = Read(p,A) U U {Follow(p',B) | (p,A) INCLUDES (p',B)}</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:</span>
    <span class="s0">#            ntrans     = Set of nonterminal transitions</span>
    <span class="s0">#            readsets   = Readset (previously computed)</span>
    <span class="s0">#            inclsets   = Include sets (previously computed)</span>
    <span class="s0">#</span>
    <span class="s0"># Returns a set containing the follow sets</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">compute_follow_sets</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ntrans</span><span class="s3">, </span><span class="s1">readsets</span><span class="s3">, </span><span class="s1">inclsets</span><span class="s3">):</span>
        <span class="s1">FP </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">readsets</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]</span>
        <span class="s1">R  </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">inclsets</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, [])</span>
        <span class="s1">F </span><span class="s3">= </span><span class="s1">digraph</span><span class="s3">(</span><span class="s1">ntrans</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">FP</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">F</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_lookaheads()</span>
    <span class="s0">#</span>
    <span class="s0"># Attaches the lookahead symbols to grammar rules.</span>
    <span class="s0">#</span>
    <span class="s0"># Inputs:    lookbacks         -  Set of lookback relations</span>
    <span class="s0">#            followset         -  Computed follow set</span>
    <span class="s0">#</span>
    <span class="s0"># This function directly attaches the lookaheads to productions contained</span>
    <span class="s0"># in the lookbacks set</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_lookaheads</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lookbacks</span><span class="s3">, </span><span class="s1">followset</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">lb </span><span class="s2">in </span><span class="s1">lookbacks</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s0"># Loop over productions in lookback</span>
            <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">lb</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">state </span><span class="s2">not in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lookaheads</span><span class="s3">:</span>
                    <span class="s1">p</span><span class="s3">.</span><span class="s1">lookaheads</span><span class="s3">[</span><span class="s1">state</span><span class="s3">] = []</span>
                <span class="s1">f </span><span class="s3">= </span><span class="s1">followset</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">trans</span><span class="s3">, [])</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">f</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lookaheads</span><span class="s3">[</span><span class="s1">state</span><span class="s3">]:</span>
                        <span class="s1">p</span><span class="s3">.</span><span class="s1">lookaheads</span><span class="s3">[</span><span class="s1">state</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># add_lalr_lookaheads()</span>
    <span class="s0">#</span>
    <span class="s0"># This function does all of the work of adding lookahead information for use</span>
    <span class="s0"># with LALR parsing</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">add_lalr_lookaheads</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">C</span><span class="s3">):</span>
        <span class="s0"># Determine all of the nullable nonterminals</span>
        <span class="s1">nullable </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compute_nullable_nonterminals</span><span class="s3">()</span>

        <span class="s0"># Find all non-terminal transitions</span>
        <span class="s1">trans </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">find_nonterminal_transitions</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>

        <span class="s0"># Compute read sets</span>
        <span class="s1">readsets </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compute_read_sets</span><span class="s3">(</span><span class="s1">C</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">)</span>

        <span class="s0"># Compute lookback/includes relations</span>
        <span class="s1">lookd</span><span class="s3">, </span><span class="s1">included </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compute_lookback_includes</span><span class="s3">(</span><span class="s1">C</span><span class="s3">, </span><span class="s1">trans</span><span class="s3">, </span><span class="s1">nullable</span><span class="s3">)</span>

        <span class="s0"># Compute LALR FOLLOW sets</span>
        <span class="s1">followsets </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compute_follow_sets</span><span class="s3">(</span><span class="s1">trans</span><span class="s3">, </span><span class="s1">readsets</span><span class="s3">, </span><span class="s1">included</span><span class="s3">)</span>

        <span class="s0"># Add all of the lookaheads</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">add_lookaheads</span><span class="s3">(</span><span class="s1">lookd</span><span class="s3">, </span><span class="s1">followsets</span><span class="s3">)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># lr_parse_table()</span>
    <span class="s0">#</span>
    <span class="s0"># This function constructs the parse tables for SLR or LALR</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s2">def </span><span class="s1">lr_parse_table</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">Productions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions</span>
        <span class="s1">Precedence  </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Precedence</span>
        <span class="s1">goto   </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto         </span><span class="s0"># Goto array</span>
        <span class="s1">action </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action       </span><span class="s0"># Action array</span>
        <span class="s1">log    </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">log             </span><span class="s0"># Logger for output</span>

        <span class="s1">actionp </span><span class="s3">= {}                  </span><span class="s0"># Action production array (temporary)</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Parsing method: %s'</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method</span><span class="s3">)</span>

        <span class="s0"># Step 1: Construct C = { I0, I1, ... IN}, collection of LR(0) items</span>
        <span class="s0"># This determines the number of states</span>

        <span class="s1">C </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_items</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">== </span><span class="s4">'LALR'</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_lalr_lookaheads</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>

        <span class="s0"># Build the parser table, state by state</span>
        <span class="s1">st </span><span class="s3">= </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">I </span><span class="s2">in </span><span class="s1">C</span><span class="s3">:</span>
            <span class="s0"># Loop over each production in I</span>
            <span class="s1">actlist </span><span class="s3">= []              </span><span class="s0"># List of actions</span>
            <span class="s1">st_action  </span><span class="s3">= {}</span>
            <span class="s1">st_actionp </span><span class="s3">= {}</span>
            <span class="s1">st_goto    </span><span class="s3">= {}</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'state %d'</span><span class="s3">, </span><span class="s1">st</span><span class="s3">)</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I</span><span class="s3">:</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'    (%d) %s'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">I</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len </span><span class="s3">== </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name </span><span class="s3">== </span><span class="s4">&quot;S'&quot;</span><span class="s3">:</span>
                            <span class="s0"># Start symbol. Accept!</span>
                            <span class="s1">st_action</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = </span><span class="s5">0</span>
                            <span class="s1">st_actionp</span><span class="s3">[</span><span class="s4">'$end'</span><span class="s3">] = </span><span class="s1">p</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s0"># We are at the end of a production.  Reduce!</span>
                            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method </span><span class="s3">== </span><span class="s4">'LALR'</span><span class="s3">:</span>
                                <span class="s1">laheads </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lookaheads</span><span class="s3">[</span><span class="s1">st</span><span class="s3">]</span>
                            <span class="s2">else</span><span class="s3">:</span>
                                <span class="s1">laheads </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Follow</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">]</span>
                            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">laheads</span><span class="s3">:</span>
                                <span class="s1">actlist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s4">'reduce using rule %d (%s)' </span><span class="s3">% (</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)))</span>
                                <span class="s1">r </span><span class="s3">= </span><span class="s1">st_action</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">r </span><span class="s2">is not None</span><span class="s3">:</span>
                                    <span class="s0"># Whoa. Have a shift/reduce or reduce/reduce conflict</span>
                                    <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                                        <span class="s0"># Need to decide on shift or reduce here</span>
                                        <span class="s0"># By default we favor shifting. Need to add</span>
                                        <span class="s0"># some precedence rules here.</span>

                                        <span class="s0"># Shift precedence comes from the token</span>
                                        <span class="s1">sprec</span><span class="s3">, </span><span class="s1">slevel </span><span class="s3">= </span><span class="s1">Precedence</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s4">'right'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

                                        <span class="s0"># Reduce precedence comes from rule being reduced (p)</span>
                                        <span class="s1">rprec</span><span class="s3">, </span><span class="s1">rlevel </span><span class="s3">= </span><span class="s1">Productions</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">].</span><span class="s1">prec</span>

                                        <span class="s2">if </span><span class="s3">(</span><span class="s1">slevel </span><span class="s3">&lt; </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">or </span><span class="s3">((</span><span class="s1">slevel </span><span class="s3">== </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">rprec </span><span class="s3">== </span><span class="s4">'left'</span><span class="s3">)):</span>
                                            <span class="s0"># We really need to reduce here.</span>
                                            <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = -</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span>
                                            <span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">p</span>
                                            <span class="s2">if not </span><span class="s1">slevel </span><span class="s2">and not </span><span class="s1">rlevel</span><span class="s3">:</span>
                                                <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'  ! shift/reduce conflict for %s resolved as reduce'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">st</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s4">'reduce'</span><span class="s3">))</span>
                                            <span class="s1">Productions</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">].</span><span class="s1">reduced </span><span class="s3">+= </span><span class="s5">1</span>
                                        <span class="s2">elif </span><span class="s3">(</span><span class="s1">slevel </span><span class="s3">== </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">rprec </span><span class="s3">== </span><span class="s4">'nonassoc'</span><span class="s3">):</span>
                                            <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s2">None</span>
                                        <span class="s2">else</span><span class="s3">:</span>
                                            <span class="s0"># Hmmm. Guess we'll keep the shift</span>
                                            <span class="s2">if not </span><span class="s1">rlevel</span><span class="s3">:</span>
                                                <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'  ! shift/reduce conflict for %s resolved as shift'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">st</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s4">'shift'</span><span class="s3">))</span>
                                    <span class="s2">elif </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                                        <span class="s0"># Reduce/reduce conflict.   In this case, we favor the rule</span>
                                        <span class="s0"># that was defined first in the grammar file</span>
                                        <span class="s1">oldp </span><span class="s3">= </span><span class="s1">Productions</span><span class="s3">[-</span><span class="s1">r</span><span class="s3">]</span>
                                        <span class="s1">pp </span><span class="s3">= </span><span class="s1">Productions</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">]</span>
                                        <span class="s2">if </span><span class="s1">oldp</span><span class="s3">.</span><span class="s1">line </span><span class="s3">&gt; </span><span class="s1">pp</span><span class="s3">.</span><span class="s1">line</span><span class="s3">:</span>
                                            <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = -</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span>
                                            <span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">p</span>
                                            <span class="s1">chosenp</span><span class="s3">, </span><span class="s1">rejectp </span><span class="s3">= </span><span class="s1">pp</span><span class="s3">, </span><span class="s1">oldp</span>
                                            <span class="s1">Productions</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">].</span><span class="s1">reduced </span><span class="s3">+= </span><span class="s5">1</span>
                                            <span class="s1">Productions</span><span class="s3">[</span><span class="s1">oldp</span><span class="s3">.</span><span class="s1">number</span><span class="s3">].</span><span class="s1">reduced </span><span class="s3">-= </span><span class="s5">1</span>
                                        <span class="s2">else</span><span class="s3">:</span>
                                            <span class="s1">chosenp</span><span class="s3">, </span><span class="s1">rejectp </span><span class="s3">= </span><span class="s1">oldp</span><span class="s3">, </span><span class="s1">pp</span>
                                        <span class="s1">self</span><span class="s3">.</span><span class="s1">rr_conflicts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">st</span><span class="s3">, </span><span class="s1">chosenp</span><span class="s3">, </span><span class="s1">rejectp</span><span class="s3">))</span>
                                        <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'  ! reduce/reduce conflict for %s resolved using rule %d (%s)'</span><span class="s3">,</span>
                                                 <span class="s1">a</span><span class="s3">, </span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">].</span><span class="s1">number</span><span class="s3">, </span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">])</span>
                                    <span class="s2">else</span><span class="s3">:</span>
                                        <span class="s2">raise </span><span class="s1">LALRError</span><span class="s3">(</span><span class="s4">'Unknown conflict in state %d' </span><span class="s3">% </span><span class="s1">st</span><span class="s3">)</span>
                                <span class="s2">else</span><span class="s3">:</span>
                                    <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = -</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span>
                                    <span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">p</span>
                                    <span class="s1">Productions</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">number</span><span class="s3">].</span><span class="s1">reduced </span><span class="s3">+= </span><span class="s5">1</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">i </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">lr_index</span>
                        <span class="s1">a </span><span class="s3">= </span><span class="s1">p</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]       </span><span class="s0"># Get symbol right after the &quot;.&quot;</span>
                        <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">:</span>
                            <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">I</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                            <span class="s1">j </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">), -</span><span class="s5">1</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                                <span class="s0"># We are in a shift state</span>
                                <span class="s1">actlist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s4">'shift and go to state %d' </span><span class="s3">% </span><span class="s1">j</span><span class="s3">))</span>
                                <span class="s1">r </span><span class="s3">= </span><span class="s1">st_action</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
                                <span class="s2">if </span><span class="s1">r </span><span class="s2">is not None</span><span class="s3">:</span>
                                    <span class="s0"># Whoa have a shift/reduce or shift/shift conflict</span>
                                    <span class="s2">if </span><span class="s1">r </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                                        <span class="s2">if </span><span class="s1">r </span><span class="s3">!= </span><span class="s1">j</span><span class="s3">:</span>
                                            <span class="s2">raise </span><span class="s1">LALRError</span><span class="s3">(</span><span class="s4">'Shift/shift conflict in state %d' </span><span class="s3">% </span><span class="s1">st</span><span class="s3">)</span>
                                    <span class="s2">elif </span><span class="s1">r </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                                        <span class="s0"># Do a precedence check.</span>
                                        <span class="s0">#   -  if precedence of reduce rule is higher, we reduce.</span>
                                        <span class="s0">#   -  if precedence of reduce is same and left assoc, we reduce.</span>
                                        <span class="s0">#   -  otherwise we shift</span>

                                        <span class="s0"># Shift precedence comes from the token</span>
                                        <span class="s1">sprec</span><span class="s3">, </span><span class="s1">slevel </span><span class="s3">= </span><span class="s1">Precedence</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s4">'right'</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

                                        <span class="s0"># Reduce precedence comes from the rule that could have been reduced</span>
                                        <span class="s1">rprec</span><span class="s3">, </span><span class="s1">rlevel </span><span class="s3">= </span><span class="s1">Productions</span><span class="s3">[</span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">].</span><span class="s1">number</span><span class="s3">].</span><span class="s1">prec</span>

                                        <span class="s2">if </span><span class="s3">(</span><span class="s1">slevel </span><span class="s3">&gt; </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">or </span><span class="s3">((</span><span class="s1">slevel </span><span class="s3">== </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">rprec </span><span class="s3">== </span><span class="s4">'right'</span><span class="s3">)):</span>
                                            <span class="s0"># We decide to shift here... highest precedence to shift</span>
                                            <span class="s1">Productions</span><span class="s3">[</span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">].</span><span class="s1">number</span><span class="s3">].</span><span class="s1">reduced </span><span class="s3">-= </span><span class="s5">1</span>
                                            <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">j</span>
                                            <span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">p</span>
                                            <span class="s2">if not </span><span class="s1">rlevel</span><span class="s3">:</span>
                                                <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'  ! shift/reduce conflict for %s resolved as shift'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">st</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s4">'shift'</span><span class="s3">))</span>
                                        <span class="s2">elif </span><span class="s3">(</span><span class="s1">slevel </span><span class="s3">== </span><span class="s1">rlevel</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">rprec </span><span class="s3">== </span><span class="s4">'nonassoc'</span><span class="s3">):</span>
                                            <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s2">None</span>
                                        <span class="s2">else</span><span class="s3">:</span>
                                            <span class="s0"># Hmmm. Guess we'll keep the reduce</span>
                                            <span class="s2">if not </span><span class="s1">slevel </span><span class="s2">and not </span><span class="s1">rlevel</span><span class="s3">:</span>
                                                <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'  ! shift/reduce conflict for %s resolved as reduce'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">st</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s4">'reduce'</span><span class="s3">))</span>

                                    <span class="s2">else</span><span class="s3">:</span>
                                        <span class="s2">raise </span><span class="s1">LALRError</span><span class="s3">(</span><span class="s4">'Unknown conflict in state %d' </span><span class="s3">% </span><span class="s1">st</span><span class="s3">)</span>
                                <span class="s2">else</span><span class="s3">:</span>
                                    <span class="s1">st_action</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">j</span>
                                    <span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] = </span><span class="s1">p</span>

            <span class="s0"># Print the actions associated with each terminal</span>
            <span class="s1">_actprint </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">actlist</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">st_action</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">p </span><span class="s2">is </span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">]:</span>
                        <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'    %-15s %s'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
                        <span class="s1">_actprint</span><span class="s3">[(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)] = </span><span class="s5">1</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
            <span class="s0"># Print the actions that were not used. (debugging)</span>
            <span class="s1">not_used </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">actlist</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">a </span><span class="s2">in </span><span class="s1">st_action</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">p </span><span class="s2">is not </span><span class="s1">st_actionp</span><span class="s3">[</span><span class="s1">a</span><span class="s3">]:</span>
                        <span class="s2">if not </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">) </span><span class="s2">in </span><span class="s1">_actprint</span><span class="s3">:</span>
                            <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'  ! %-15s [ %s ]'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
                            <span class="s1">not_used </span><span class="s3">= </span><span class="s5">1</span>
                            <span class="s1">_actprint</span><span class="s3">[(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)] = </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">not_used</span><span class="s3">:</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>

            <span class="s0"># Construct the goto table for this state</span>

            <span class="s1">nkeys </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">I</span><span class="s3">:</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">ii</span><span class="s3">.</span><span class="s1">usyms</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">:</span>
                        <span class="s1">nkeys</span><span class="s3">[</span><span class="s1">s</span><span class="s3">] = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nkeys</span><span class="s3">:</span>
                <span class="s1">g </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_goto</span><span class="s3">(</span><span class="s1">I</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
                <span class="s1">j </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr0_cidhash</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">id</span><span class="s3">(</span><span class="s1">g</span><span class="s3">), -</span><span class="s5">1</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">st_goto</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">j</span>
                    <span class="s1">log</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'    %-30s shift and go to state %d'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">j</span><span class="s3">)</span>

            <span class="s1">action</span><span class="s3">[</span><span class="s1">st</span><span class="s3">] = </span><span class="s1">st_action</span>
            <span class="s1">actionp</span><span class="s3">[</span><span class="s1">st</span><span class="s3">] = </span><span class="s1">st_actionp</span>
            <span class="s1">goto</span><span class="s3">[</span><span class="s1">st</span><span class="s3">] = </span><span class="s1">st_goto</span>
            <span class="s1">st </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># write()</span>
    <span class="s0">#</span>
    <span class="s0"># This function writes the LR parsing tables to a file</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">write_table</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">outputdir</span><span class="s3">=</span><span class="s4">''</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">IOError</span><span class="s3">(</span><span class="s4">&quot;Won't overwrite existing tabmodule&quot;</span><span class="s3">)</span>

        <span class="s1">basemodulename </span><span class="s3">= </span><span class="s1">tabmodule</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">filename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">outputdir</span><span class="s3">, </span><span class="s1">basemodulename</span><span class="s3">) + </span><span class="s4">'.py'</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s4">'w'</span><span class="s3">)</span>

            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">''' 
# %s 
# This file is automatically generated. Do not edit. 
_tabversion = %r 
 
_lr_method = %r 
 
_lr_signature = %r 
    ''' </span><span class="s3">% (</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">), </span><span class="s1">__tabversion__</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">))</span>

            <span class="s0"># Change smaller to 0 to go back to original tables</span>
            <span class="s1">smaller </span><span class="s3">= </span><span class="s5">1</span>

            <span class="s0"># Factor out names to try and make smaller</span>
            <span class="s2">if </span><span class="s1">smaller</span><span class="s3">:</span>
                <span class="s1">items </span><span class="s3">= {}</span>

                <span class="s2">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">nd</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s1">i </span><span class="s3">= </span><span class="s1">items</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                        <span class="s2">if not </span><span class="s1">i</span><span class="s3">:</span>
                            <span class="s1">i </span><span class="s3">= ([], [])</span>
                            <span class="s1">items</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">i</span>
                        <span class="s1">i</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
                        <span class="s1">i</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">_lr_action_items = {'</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">items</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r:([' </span><span class="s3">% </span><span class="s1">k</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
                        <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r,' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'],['</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
                        <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r,' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>

                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">']),'</span><span class="s3">)</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'}</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">''' 
_lr_action = {} 
for _k, _v in _lr_action_items.items(): 
   for _x,_y in zip(_v[0],_v[1]): 
      if not _x in _lr_action:  _lr_action[_x] = {} 
      _lr_action[_x][_k] = _y 
del _lr_action_items 
'''</span><span class="s3">)</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">_lr_action = { '</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'(%r,%r):%r,' </span><span class="s3">% (</span><span class="s1">k</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">k</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">v</span><span class="s3">))</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'}</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">smaller</span><span class="s3">:</span>
                <span class="s0"># Factor out names to try and make smaller</span>
                <span class="s1">items </span><span class="s3">= {}</span>

                <span class="s2">for </span><span class="s1">s</span><span class="s3">, </span><span class="s1">nd </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">nd</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                        <span class="s1">i </span><span class="s3">= </span><span class="s1">items</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                        <span class="s2">if not </span><span class="s1">i</span><span class="s3">:</span>
                            <span class="s1">i </span><span class="s3">= ([], [])</span>
                            <span class="s1">items</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">i</span>
                        <span class="s1">i</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">s</span><span class="s3">)</span>
                        <span class="s1">i</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>

                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">_lr_goto_items = {'</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">items</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r:([' </span><span class="s3">% </span><span class="s1">k</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
                        <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r,' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'],['</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">v</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
                        <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'%r,' </span><span class="s3">% </span><span class="s1">i</span><span class="s3">)</span>

                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">']),'</span><span class="s3">)</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'}</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">''' 
_lr_goto = {} 
for _k, _v in _lr_goto_items.items(): 
   for _x, _y in zip(_v[0], _v[1]): 
       if not _x in _lr_goto: _lr_goto[_x] = {} 
       _lr_goto[_x][_k] = _y 
del _lr_goto_items 
'''</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">_lr_goto = { '</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'(%r,%r):%r,' </span><span class="s3">% (</span><span class="s1">k</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">k</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">v</span><span class="s3">))</span>
                <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'}</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>

            <span class="s0"># Write production table</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'_lr_productions = [</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">func</span><span class="s3">:</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'  (%r,%r,%d,%r,%r,%d),</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">% (</span><span class="s1">p</span><span class="s3">.</span><span class="s1">str</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">,</span>
                                                          <span class="s1">p</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">file</span><span class="s3">), </span><span class="s1">p</span><span class="s3">.</span><span class="s1">line</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">'  (%r,%r,%d,None,None,None),</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">% (</span><span class="s1">str</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">))</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">write</span><span class="s3">(</span><span class="s4">']</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise</span>


    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># pickle_table()</span>
    <span class="s0">#</span>
    <span class="s0"># This function pickles the LR parsing tables to a supplied file object</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">pickle_table</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">=</span><span class="s4">''</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">cPickle </span><span class="s2">as </span><span class="s1">pickle</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">pickle</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">outf</span><span class="s3">:</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">__tabversion__</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_method</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">signature</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_action</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_goto</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>

            <span class="s1">outp </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lr_productions</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">p</span><span class="s3">.</span><span class="s1">func</span><span class="s3">:</span>
                    <span class="s1">outp</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">p</span><span class="s3">.</span><span class="s1">str</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">func</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">file</span><span class="s3">), </span><span class="s1">p</span><span class="s3">.</span><span class="s1">line</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">outp</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">str</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">len</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
            <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">outp</span><span class="s3">, </span><span class="s1">outf</span><span class="s3">, </span><span class="s1">pickle_protocol</span><span class="s3">)</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0">#                            === INTROSPECTION ===</span>
<span class="s0">#</span>
<span class="s0"># The following functions and classes are used to implement the PLY</span>
<span class="s0"># introspection features followed by the yacc() function itself.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># get_caller_module_dict()</span>
<span class="s0">#</span>
<span class="s0"># This function returns a dictionary containing all of the symbols defined within</span>
<span class="s0"># a caller further down the call stack.  This is used to get the environment</span>
<span class="s0"># associated with the yacc() call if none was provided.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">get_caller_module_dict</span><span class="s3">(</span><span class="s1">levels</span><span class="s3">):</span>
    <span class="s1">f </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">_getframe</span><span class="s3">(</span><span class="s1">levels</span><span class="s3">)</span>
    <span class="s1">ldict </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">f_globals</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">f</span><span class="s3">.</span><span class="s1">f_globals </span><span class="s3">!= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">f_locals</span><span class="s3">:</span>
        <span class="s1">ldict</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">f</span><span class="s3">.</span><span class="s1">f_locals</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ldict</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># parse_grammar()</span>
<span class="s0">#</span>
<span class="s0"># This takes a raw grammar rule string and parses it into production data</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">def </span><span class="s1">parse_grammar</span><span class="s3">(</span><span class="s1">doc</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">):</span>
    <span class="s1">grammar </span><span class="s3">= []</span>
    <span class="s0"># Split the doc string into lines</span>
    <span class="s1">pstrings </span><span class="s3">= </span><span class="s1">doc</span><span class="s3">.</span><span class="s1">splitlines</span><span class="s3">()</span>
    <span class="s1">lastp </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">dline </span><span class="s3">= </span><span class="s1">line</span>
    <span class="s2">for </span><span class="s1">ps </span><span class="s2">in </span><span class="s1">pstrings</span><span class="s3">:</span>
        <span class="s1">dline </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">split</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">p</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'|'</span><span class="s3">:</span>
                <span class="s0"># This is a continuation of a previous rule</span>
                <span class="s2">if not </span><span class="s1">lastp</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError</span><span class="s3">(</span><span class="s4">&quot;%s:%d: Misplaced '|'&quot; </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">dline</span><span class="s3">))</span>
                <span class="s1">prodname </span><span class="s3">= </span><span class="s1">lastp</span>
                <span class="s1">syms </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">prodname </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">lastp </span><span class="s3">= </span><span class="s1">prodname</span>
                <span class="s1">syms   </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s5">2</span><span class="s3">:]</span>
                <span class="s1">assign </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">assign </span><span class="s3">!= </span><span class="s4">':' </span><span class="s2">and </span><span class="s1">assign </span><span class="s3">!= </span><span class="s4">'::='</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">SyntaxError</span><span class="s3">(</span><span class="s4">&quot;%s:%d: Syntax error. Expected ':'&quot; </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">dline</span><span class="s3">))</span>

            <span class="s1">grammar</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">file</span><span class="s3">, </span><span class="s1">dline</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms</span><span class="s3">))</span>
        <span class="s2">except </span><span class="s1">SyntaxError</span><span class="s3">:</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Exception</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">SyntaxError</span><span class="s3">(</span><span class="s4">'%s:%d: Syntax error in rule %r' </span><span class="s3">% (</span><span class="s1">file</span><span class="s3">, </span><span class="s1">dline</span><span class="s3">, </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">strip</span><span class="s3">()))</span>

    <span class="s2">return </span><span class="s1">grammar</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># ParserReflect()</span>
<span class="s0">#</span>
<span class="s0"># This class represents information extracted for building a parser including</span>
<span class="s0"># start symbol, error function, tokens, precedence list, action functions,</span>
<span class="s0"># etc.</span>
<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s2">class </span><span class="s1">ParserReflect</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pdict</span><span class="s3">, </span><span class="s1">log</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pdict      </span><span class="s3">= </span><span class="s1">pdict</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start      </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">error_func </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tokens     </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">modules    </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar    </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">error      </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">log </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log </span><span class="s3">= </span><span class="s1">PlyLogger</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log </span><span class="s3">= </span><span class="s1">log</span>

    <span class="s0"># Get all of the basic information</span>
    <span class="s2">def </span><span class="s1">get_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">get_start</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">get_error_func</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">get_tokens</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">get_precedence</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">get_pfunctions</span><span class="s3">()</span>

    <span class="s0"># Validate all of the information</span>
    <span class="s2">def </span><span class="s1">validate_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_start</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_error_func</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_tokens</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_precedence</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_pfunctions</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">validate_modules</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">error</span>

    <span class="s0"># Compute a signature over the grammar</span>
    <span class="s2">def </span><span class="s1">signature</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">parts </span><span class="s3">= []</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">:</span>
                <span class="s1">parts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prec</span><span class="s3">:</span>
                <span class="s1">parts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s4">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prec</span><span class="s3">]))</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tokens</span><span class="s3">:</span>
                <span class="s1">parts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">tokens</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pfuncs</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">f</span><span class="s3">[</span><span class="s5">3</span><span class="s3">]:</span>
                    <span class="s1">parts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">f</span><span class="s3">[</span><span class="s5">3</span><span class="s3">])</span>
        <span class="s2">except </span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s4">''</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">)</span>

    <span class="s0"># -----------------------------------------------------------------------------</span>
    <span class="s0"># validate_modules()</span>
    <span class="s0">#</span>
    <span class="s0"># This method checks to see if there are duplicated p_rulename() functions</span>
    <span class="s0"># in the parser module file.  Without this function, it is really easy for</span>
    <span class="s0"># users to make mistakes by cutting and pasting code fragments (and it's a real</span>
    <span class="s0"># bugger to try and figure out why the resulting parser doesn't work).  Therefore,</span>
    <span class="s0"># we just do a little regular expression pattern matching of def statements</span>
    <span class="s0"># to try and detect duplicates.</span>
    <span class="s0"># -----------------------------------------------------------------------------</span>

    <span class="s2">def </span><span class="s1">validate_modules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Match def p_funcname(</span>
        <span class="s1">fre </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s4">r'\s*def\s+(p_[a-zA-Z_0-9]*)\('</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">module </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">lines</span><span class="s3">, </span><span class="s1">linen </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">getsourcelines</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">IOError</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s1">counthash </span><span class="s3">= {}</span>
            <span class="s2">for </span><span class="s1">linen</span><span class="s3">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">lines</span><span class="s3">):</span>
                <span class="s1">linen </span><span class="s3">+= </span><span class="s5">1</span>
                <span class="s1">m </span><span class="s3">= </span><span class="s1">fre</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">line</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">m</span><span class="s3">:</span>
                    <span class="s1">name </span><span class="s3">= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">group</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
                    <span class="s1">prev </span><span class="s3">= </span><span class="s1">counthash</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
                    <span class="s2">if not </span><span class="s1">prev</span><span class="s3">:</span>
                        <span class="s1">counthash</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">linen</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">filename </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">getsourcefile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%s:%d: Function %s redefined. Previously defined on line %d'</span><span class="s3">,</span>
                                         <span class="s1">filename</span><span class="s3">, </span><span class="s1">linen</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">prev</span><span class="s3">)</span>

    <span class="s0"># Get the start symbol</span>
    <span class="s2">def </span><span class="s1">get_start</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'start'</span><span class="s3">)</span>

    <span class="s0"># Validate the start symbol</span>
    <span class="s2">def </span><span class="s1">validate_start</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">string_types</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">&quot;'start' must be a string&quot;</span><span class="s3">)</span>

    <span class="s0"># Look for error handler</span>
    <span class="s2">def </span><span class="s1">get_error_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">error_func </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'p_error'</span><span class="s3">)</span>

    <span class="s0"># Validate the error function</span>
    <span class="s2">def </span><span class="s1">validate_error_func</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">):</span>
                <span class="s1">ismethod </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MethodType</span><span class="s3">):</span>
                <span class="s1">ismethod </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">&quot;'p_error' defined, but is not a function or method&quot;</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">return</span>

            <span class="s1">eline </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_firstlineno</span>
            <span class="s1">efile </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_filename</span>
            <span class="s1">module </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">getmodule</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>

            <span class="s1">argcount </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">- </span><span class="s1">ismethod</span>
            <span class="s2">if </span><span class="s1">argcount </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'%s:%d: p_error() requires 1 argument'</span><span class="s3">, </span><span class="s1">efile</span><span class="s3">, </span><span class="s1">eline</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s0"># Get the tokens map</span>
    <span class="s2">def </span><span class="s1">get_tokens</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">tokens </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'tokens'</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">tokens</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'No token list is defined'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tokens</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'tokens must be a list or tuple'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">tokens</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'tokens is empty'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">tokens </span><span class="s3">= </span><span class="s1">tokens</span>

    <span class="s0"># Validate the tokens</span>
    <span class="s2">def </span><span class="s1">validate_tokens</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Validate the tokens.</span>
        <span class="s2">if </span><span class="s4">'error' </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tokens</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">&quot;Illegal token name 'error'. Is a reserved word&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s1">terminals </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tokens</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s2">in </span><span class="s1">terminals</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Token %r multiply defined'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">terminals</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s0"># Get the precedence map (if any)</span>
    <span class="s2">def </span><span class="s1">get_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">prec </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'precedence'</span><span class="s3">)</span>

    <span class="s0"># Validate and parse the precedence map</span>
    <span class="s2">def </span><span class="s1">validate_precedence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">preclist </span><span class="s3">= []</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">prec</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prec</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'precedence must be a list or tuple'</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s2">return</span>
            <span class="s2">for </span><span class="s1">level</span><span class="s3">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">prec</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'Bad precedence table'</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                    <span class="s2">return</span>

                <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt; </span><span class="s5">2</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'Malformed precedence entry %s. Must be (assoc, term, ..., term)'</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                    <span class="s2">return</span>
                <span class="s1">assoc </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">string_types</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'precedence associativity must be a string'</span><span class="s3">)</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                    <span class="s2">return</span>
                <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">p</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]:</span>
                    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">string_types</span><span class="s3">):</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'precedence items must be strings'</span><span class="s3">)</span>
                        <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
                        <span class="s2">return</span>
                    <span class="s1">preclist</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">term</span><span class="s3">, </span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">level</span><span class="s3">+</span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">preclist </span><span class="s3">= </span><span class="s1">preclist</span>

    <span class="s0"># Get all p_functions from the grammar</span>
    <span class="s2">def </span><span class="s1">get_pfunctions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">p_functions </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if not </span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'p_'</span><span class="s3">) </span><span class="s2">or </span><span class="s1">name </span><span class="s3">== </span><span class="s4">'p_error'</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MethodType</span><span class="s3">)):</span>
                <span class="s1">line </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">item</span><span class="s3">, </span><span class="s4">'co_firstlineno'</span><span class="s3">, </span><span class="s1">item</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_firstlineno</span><span class="s3">)</span>
                <span class="s1">module </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">getmodule</span><span class="s3">(</span><span class="s1">item</span><span class="s3">)</span>
                <span class="s1">p_functions</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">line</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">item</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">))</span>

        <span class="s0"># Sort all of the actions by line number; make sure to stringify</span>
        <span class="s0"># modules to make them sortable, since `line` may not uniquely sort all</span>
        <span class="s0"># p functions</span>
        <span class="s1">p_functions</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">p_function</span><span class="s3">: (</span>
            <span class="s1">p_function</span><span class="s3">[</span><span class="s5">0</span><span class="s3">],</span>
            <span class="s1">str</span><span class="s3">(</span><span class="s1">p_function</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]),</span>
            <span class="s1">p_function</span><span class="s3">[</span><span class="s5">2</span><span class="s3">],</span>
            <span class="s1">p_function</span><span class="s3">[</span><span class="s5">3</span><span class="s3">]))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pfuncs </span><span class="s3">= </span><span class="s1">p_functions</span>

    <span class="s0"># Validate all of the p_functions</span>
    <span class="s2">def </span><span class="s1">validate_pfunctions</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">grammar </span><span class="s3">= []</span>
        <span class="s0"># Check for non-empty symbols</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pfuncs</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'no rules of the form p_rulename are defined'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">line</span><span class="s3">, </span><span class="s1">module</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">doc </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pfuncs</span><span class="s3">:</span>
            <span class="s1">file </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">getsourcefile</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>
            <span class="s1">func </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MethodType</span><span class="s3">):</span>
                <span class="s1">reqargs </span><span class="s3">= </span><span class="s5">2</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">reqargs </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">&gt; </span><span class="s1">reqargs</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'%s:%d: Rule %r has too many arguments'</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">&lt; </span><span class="s1">reqargs</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'%s:%d: Rule %r requires an argument'</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">elif not </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%s:%d: No documentation string specified in function %r (ignored)'</span><span class="s3">,</span>
                                 <span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">func</span><span class="s3">.</span><span class="s1">__name__</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">parsed_g </span><span class="s3">= </span><span class="s1">parse_grammar</span><span class="s3">(</span><span class="s1">doc</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">g </span><span class="s2">in </span><span class="s1">parsed_g</span><span class="s3">:</span>
                        <span class="s1">grammar</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">name</span><span class="s3">, </span><span class="s1">g</span><span class="s3">))</span>
                <span class="s2">except </span><span class="s1">SyntaxError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">))</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s2">True</span>

                <span class="s0"># Looks like a valid grammar rule</span>
                <span class="s0"># Mark the file in which defined.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)</span>

        <span class="s0"># Secondary validation step that looks for p_ definitions that are not functions</span>
        <span class="s0"># or functions that look like they might be grammar rules.</span>

        <span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'p_'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MethodType</span><span class="s3">)):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'t_'</span><span class="s3">):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'p_'</span><span class="s3">) </span><span class="s2">and </span><span class="s1">n </span><span class="s3">!= </span><span class="s4">'p_error'</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%r not defined as a function'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s3">((</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">FunctionType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">== </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or</span>
                   <span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">MethodType</span><span class="s3">) </span><span class="s2">and </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__func__</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_argcount </span><span class="s3">== </span><span class="s5">2</span><span class="s3">)):</span>
                <span class="s2">if </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
                    <span class="s2">try</span><span class="s3">:</span>
                        <span class="s1">doc </span><span class="s3">= </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">' '</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">doc</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s4">':'</span><span class="s3">:</span>
                            <span class="s1">self</span><span class="s3">.</span><span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%s:%d: Possible grammar rule %r defined without p_ prefix'</span><span class="s3">,</span>
                                             <span class="s1">v</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_filename</span><span class="s3">, </span><span class="s1">v</span><span class="s3">.</span><span class="s1">__code__</span><span class="s3">.</span><span class="s1">co_firstlineno</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
                    <span class="s2">except </span><span class="s1">IndexError</span><span class="s3">:</span>
                        <span class="s2">pass</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">grammar </span><span class="s3">= </span><span class="s1">grammar</span>

<span class="s0"># -----------------------------------------------------------------------------</span>
<span class="s0"># yacc(module)</span>
<span class="s0">#</span>
<span class="s0"># Build a parser</span>
<span class="s0"># -----------------------------------------------------------------------------</span>

<span class="s2">def </span><span class="s1">yacc</span><span class="s3">(</span><span class="s1">method</span><span class="s3">=</span><span class="s4">'LALR'</span><span class="s3">, </span><span class="s1">debug</span><span class="s3">=</span><span class="s1">yaccdebug</span><span class="s3">, </span><span class="s1">module</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">tabmodule</span><span class="s3">=</span><span class="s1">tab_module</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
         <span class="s1">check_recursion</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">write_tables</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">debugfile</span><span class="s3">=</span><span class="s1">debug_file</span><span class="s3">,</span>
         <span class="s1">outputdir</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">debuglog</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">errorlog</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">picklefile</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">tabmodule </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">tabmodule </span><span class="s3">= </span><span class="s1">tab_module</span>

    <span class="s0"># Reference to the parsing method of the last built parser</span>
    <span class="s2">global </span><span class="s1">parse</span>

    <span class="s0"># If pickling is enabled, table files are not created</span>
    <span class="s2">if </span><span class="s1">picklefile</span><span class="s3">:</span>
        <span class="s1">write_tables </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">if </span><span class="s1">errorlog </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">errorlog </span><span class="s3">= </span><span class="s1">PlyLogger</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">stderr</span><span class="s3">)</span>

    <span class="s0"># Get the module dictionary used for the parser</span>
    <span class="s2">if </span><span class="s1">module</span><span class="s3">:</span>
        <span class="s1">_items </span><span class="s3">= [(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">module</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">dir</span><span class="s3">(</span><span class="s1">module</span><span class="s3">)]</span>
        <span class="s1">pdict </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">_items</span><span class="s3">)</span>
        <span class="s0"># If no __file__ attribute is available, try to obtain it from the __module__ instead</span>
        <span class="s2">if </span><span class="s4">'__file__' </span><span class="s2">not in </span><span class="s1">pdict</span><span class="s3">:</span>
            <span class="s1">pdict</span><span class="s3">[</span><span class="s4">'__file__'</span><span class="s3">] = </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">pdict</span><span class="s3">[</span><span class="s4">'__module__'</span><span class="s3">]].</span><span class="s1">__file__</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">pdict </span><span class="s3">= </span><span class="s1">get_caller_module_dict</span><span class="s3">(</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">outputdir </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s0"># If no output directory is set, the location of the output files</span>
        <span class="s0"># is determined according to the following rules:</span>
        <span class="s0">#     - If tabmodule specifies a package, files go into that package directory</span>
        <span class="s0">#     - Otherwise, files go in the same directory as the specifying module</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">types</span><span class="s3">.</span><span class="s1">ModuleType</span><span class="s3">):</span>
            <span class="s1">srcfile </span><span class="s3">= </span><span class="s1">tabmodule</span><span class="s3">.</span><span class="s1">__file__</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s4">'.' </span><span class="s2">not in </span><span class="s1">tabmodule</span><span class="s3">:</span>
                <span class="s1">srcfile </span><span class="s3">= </span><span class="s1">pdict</span><span class="s3">[</span><span class="s4">'__file__'</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">parts </span><span class="s3">= </span><span class="s1">tabmodule</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s4">'.'</span><span class="s3">)</span>
                <span class="s1">pkgname </span><span class="s3">= </span><span class="s4">'.'</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>
                <span class="s1">exec</span><span class="s3">(</span><span class="s4">'import %s' </span><span class="s3">% </span><span class="s1">pkgname</span><span class="s3">)</span>
                <span class="s1">srcfile </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">[</span><span class="s1">pkgname</span><span class="s3">], </span><span class="s4">'__file__'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">outputdir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">srcfile</span><span class="s3">)</span>

    <span class="s0"># Determine if the module is package of a package or not.</span>
    <span class="s0"># If so, fix the tabmodule setting so that tables load correctly</span>
    <span class="s1">pkg </span><span class="s3">= </span><span class="s1">pdict</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">'__package__'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">pkg </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s4">'.' </span><span class="s2">not in </span><span class="s1">tabmodule</span><span class="s3">:</span>
            <span class="s1">tabmodule </span><span class="s3">= </span><span class="s1">pkg </span><span class="s3">+ </span><span class="s4">'.' </span><span class="s3">+ </span><span class="s1">tabmodule</span>



    <span class="s0"># Set start symbol if it's specified directly using an argument</span>
    <span class="s2">if </span><span class="s1">start </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">pdict</span><span class="s3">[</span><span class="s4">'start'</span><span class="s3">] = </span><span class="s1">start</span>

    <span class="s0"># Collect parser information from the dictionary</span>
    <span class="s1">pinfo </span><span class="s3">= </span><span class="s1">ParserReflect</span><span class="s3">(</span><span class="s1">pdict</span><span class="s3">, </span><span class="s1">log</span><span class="s3">=</span><span class="s1">errorlog</span><span class="s3">)</span>
    <span class="s1">pinfo</span><span class="s3">.</span><span class="s1">get_all</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">error</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">YaccError</span><span class="s3">(</span><span class="s4">'Unable to build parser'</span><span class="s3">)</span>

    <span class="s0"># Check signature against table files (if any)</span>
    <span class="s1">signature </span><span class="s3">= </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">()</span>

    <span class="s0"># Read the tables</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">lr </span><span class="s3">= </span><span class="s1">LRTable</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">picklefile</span><span class="s3">:</span>
            <span class="s1">read_signature </span><span class="s3">= </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">read_pickle</span><span class="s3">(</span><span class="s1">picklefile</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">read_signature </span><span class="s3">= </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">read_table</span><span class="s3">(</span><span class="s1">tabmodule</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">optimize </span><span class="s2">or </span><span class="s3">(</span><span class="s1">read_signature </span><span class="s3">== </span><span class="s1">signature</span><span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">lr</span><span class="s3">.</span><span class="s1">bind_callables</span><span class="s3">(</span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">)</span>
                <span class="s1">parser </span><span class="s3">= </span><span class="s1">LRParser</span><span class="s3">(</span><span class="s1">lr</span><span class="s3">, </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">)</span>
                <span class="s1">parse </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">parse</span>
                <span class="s2">return </span><span class="s1">parser</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'There was a problem loading the table file: %r'</span><span class="s3">, </span><span class="s1">e</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">VersionError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">))</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">if </span><span class="s1">debuglog </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">debug</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">debuglog </span><span class="s3">= </span><span class="s1">PlyLogger</span><span class="s3">(</span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">outputdir</span><span class="s3">, </span><span class="s1">debugfile</span><span class="s3">), </span><span class="s4">'w'</span><span class="s3">))</span>
            <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">&quot;Couldn't open %r. %s&quot; </span><span class="s3">% (</span><span class="s1">debugfile</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>
                <span class="s1">debuglog </span><span class="s3">= </span><span class="s1">NullLogger</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">debuglog </span><span class="s3">= </span><span class="s1">NullLogger</span><span class="s3">()</span>

    <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Created by PLY version %s (http://www.dabeaz.com/ply)'</span><span class="s3">, </span><span class="s1">__version__</span><span class="s3">)</span>

    <span class="s1">errors </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># Validate the parser information</span>
    <span class="s2">if </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">validate_all</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">YaccError</span><span class="s3">(</span><span class="s4">'Unable to build parser'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'no p_error() function is defined'</span><span class="s3">)</span>

    <span class="s0"># Create a grammar object</span>
    <span class="s1">grammar </span><span class="s3">= </span><span class="s1">Grammar</span><span class="s3">(</span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">tokens</span><span class="s3">)</span>

    <span class="s0"># Set precedence level for terminals</span>
    <span class="s2">for </span><span class="s1">term</span><span class="s3">, </span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">level </span><span class="s2">in </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">preclist</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">grammar</span><span class="s3">.</span><span class="s1">set_precedence</span><span class="s3">(</span><span class="s1">term</span><span class="s3">, </span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">level</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%s'</span><span class="s3">, </span><span class="s1">e</span><span class="s3">)</span>

    <span class="s0"># Add productions to the grammar</span>
    <span class="s2">for </span><span class="s1">funcname</span><span class="s3">, </span><span class="s1">gram </span><span class="s2">in </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">grammar</span><span class="s3">:</span>
        <span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">, </span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms </span><span class="s3">= </span><span class="s1">gram</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">grammar</span><span class="s3">.</span><span class="s1">add_production</span><span class="s3">(</span><span class="s1">prodname</span><span class="s3">, </span><span class="s1">syms</span><span class="s3">, </span><span class="s1">funcname</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">line</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'%s'</span><span class="s3">, </span><span class="s1">e</span><span class="s3">)</span>
            <span class="s1">errors </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s0"># Set the grammar start symbols</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">grammar</span><span class="s3">.</span><span class="s1">set_start</span><span class="s3">(</span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">start</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">grammar</span><span class="s3">.</span><span class="s1">set_start</span><span class="s3">(</span><span class="s1">start</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">GrammarError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">))</span>
        <span class="s1">errors </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">errors</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">YaccError</span><span class="s3">(</span><span class="s4">'Unable to build parser'</span><span class="s3">)</span>

    <span class="s0"># Verify the grammar structure</span>
    <span class="s1">undefined_symbols </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">undefined_symbols</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">sym</span><span class="s3">, </span><span class="s1">prod </span><span class="s2">in </span><span class="s1">undefined_symbols</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'%s:%d: Symbol %r used, but not defined as a token or a rule'</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">file</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">line</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">)</span>
        <span class="s1">errors </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">unused_terminals </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">unused_terminals</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">unused_terminals</span><span class="s3">:</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Unused terminals:'</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">unused_terminals</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Token %r defined, but not used'</span><span class="s3">, </span><span class="s1">term</span><span class="s3">)</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'    %s'</span><span class="s3">, </span><span class="s1">term</span><span class="s3">)</span>

    <span class="s0"># Print out all productions to the debug log</span>
    <span class="s2">if </span><span class="s1">debug</span><span class="s3">:</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Grammar'</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Productions</span><span class="s3">):</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Rule %-5d %s'</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s0"># Find unused non-terminals</span>
    <span class="s1">unused_rules </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">unused_rules</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">prod </span><span class="s2">in </span><span class="s1">unused_rules</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%s:%d: Rule %r defined, but not used'</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">file</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">line</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_terminals</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'There is 1 unused token'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_terminals</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'There are %d unused tokens'</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_terminals</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_rules</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'There is 1 unused rule'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_rules</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'There are %d unused rules'</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">unused_rules</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">debug</span><span class="s3">:</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Terminals, with rules where they appear'</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">terms </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">)</span>
        <span class="s1">terms</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">term </span><span class="s2">in </span><span class="s1">terms</span><span class="s3">:</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'%-20s : %s'</span><span class="s3">, </span><span class="s1">term</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">str</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Terminals</span><span class="s3">[</span><span class="s1">term</span><span class="s3">]]))</span>

        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'Nonterminals, with rules where they appear'</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">nonterms </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">)</span>
        <span class="s1">nonterms</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">nonterm </span><span class="s2">in </span><span class="s1">nonterms</span><span class="s3">:</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">'%-20s : %s'</span><span class="s3">, </span><span class="s1">nonterm</span><span class="s3">, </span><span class="s4">' '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([</span><span class="s1">str</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">Nonterminals</span><span class="s3">[</span><span class="s1">nonterm</span><span class="s3">]]))</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">check_recursion</span><span class="s3">:</span>
        <span class="s1">unreachable </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">find_unreachable</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">u </span><span class="s2">in </span><span class="s1">unreachable</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Symbol %r is unreachable'</span><span class="s3">, </span><span class="s1">u</span><span class="s3">)</span>

        <span class="s1">infinite </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">infinite_cycles</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">inf </span><span class="s2">in </span><span class="s1">infinite</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'Infinite recursion detected for symbol %r'</span><span class="s3">, </span><span class="s1">inf</span><span class="s3">)</span>
            <span class="s1">errors </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">unused_prec </span><span class="s3">= </span><span class="s1">grammar</span><span class="s3">.</span><span class="s1">unused_precedence</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">term</span><span class="s3">, </span><span class="s1">assoc </span><span class="s2">in </span><span class="s1">unused_prec</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">error</span><span class="s3">(</span><span class="s4">'Precedence rule %r defined for unknown symbol %r'</span><span class="s3">, </span><span class="s1">assoc</span><span class="s3">, </span><span class="s1">term</span><span class="s3">)</span>
        <span class="s1">errors </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">errors</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">YaccError</span><span class="s3">(</span><span class="s4">'Unable to build parser'</span><span class="s3">)</span>

    <span class="s0"># Run the LRGeneratedTable on the grammar</span>
    <span class="s2">if </span><span class="s1">debug</span><span class="s3">:</span>
        <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">'Generating %s tables'</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>

    <span class="s1">lr </span><span class="s3">= </span><span class="s1">LRGeneratedTable</span><span class="s3">(</span><span class="s1">grammar</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">debuglog</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">debug</span><span class="s3">:</span>
        <span class="s1">num_sr </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lr</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">)</span>

        <span class="s0"># Report shift/reduce and reduce/reduce conflicts</span>
        <span class="s2">if </span><span class="s1">num_sr </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'1 shift/reduce conflict'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">num_sr </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%d shift/reduce conflicts'</span><span class="s3">, </span><span class="s1">num_sr</span><span class="s3">)</span>

        <span class="s1">num_rr </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">lr</span><span class="s3">.</span><span class="s1">rr_conflicts</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">num_rr </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'1 reduce/reduce conflict'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">num_rr </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'%d reduce/reduce conflicts'</span><span class="s3">, </span><span class="s1">num_rr</span><span class="s3">)</span>

    <span class="s0"># Write out conflicts to the output file</span>
    <span class="s2">if </span><span class="s1">debug </span><span class="s2">and </span><span class="s3">(</span><span class="s1">lr</span><span class="s3">.</span><span class="s1">sr_conflicts </span><span class="s2">or </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">rr_conflicts</span><span class="s3">):</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Conflicts:'</span><span class="s3">)</span>
        <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">''</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">tok</span><span class="s3">, </span><span class="s1">resolution </span><span class="s2">in </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">sr_conflicts</span><span class="s3">:</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'shift/reduce conflict for %s in state %d resolved as %s'</span><span class="s3">,  </span><span class="s1">tok</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">resolution</span><span class="s3">)</span>

        <span class="s1">already_reported </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">, </span><span class="s1">rejected </span><span class="s2">in </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">rr_conflicts</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">state</span><span class="s3">, </span><span class="s1">id</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">), </span><span class="s1">id</span><span class="s3">(</span><span class="s1">rejected</span><span class="s3">)) </span><span class="s2">in </span><span class="s1">already_reported</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'reduce/reduce conflict in state %d resolved using rule (%s)'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">)</span>
            <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'rejected rule (%s) in state %d'</span><span class="s3">, </span><span class="s1">rejected</span><span class="s3">, </span><span class="s1">state</span><span class="s3">)</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'reduce/reduce conflict in state %d resolved using rule (%s)'</span><span class="s3">, </span><span class="s1">state</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">)</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'rejected rule (%s) in state %d'</span><span class="s3">, </span><span class="s1">rejected</span><span class="s3">, </span><span class="s1">state</span><span class="s3">)</span>
            <span class="s1">already_reported</span><span class="s3">.</span><span class="s1">add</span><span class="s3">((</span><span class="s1">state</span><span class="s3">, </span><span class="s1">id</span><span class="s3">(</span><span class="s1">rule</span><span class="s3">), </span><span class="s1">id</span><span class="s3">(</span><span class="s1">rejected</span><span class="s3">)))</span>

        <span class="s1">warned_never </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">state</span><span class="s3">, </span><span class="s1">rule</span><span class="s3">, </span><span class="s1">rejected </span><span class="s2">in </span><span class="s1">lr</span><span class="s3">.</span><span class="s1">rr_conflicts</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">rejected</span><span class="s3">.</span><span class="s1">reduced </span><span class="s2">and </span><span class="s3">(</span><span class="s1">rejected </span><span class="s2">not in </span><span class="s1">warned_never</span><span class="s3">):</span>
                <span class="s1">debuglog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Rule (%s) is never reduced'</span><span class="s3">, </span><span class="s1">rejected</span><span class="s3">)</span>
                <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">'Rule (%s) is never reduced'</span><span class="s3">, </span><span class="s1">rejected</span><span class="s3">)</span>
                <span class="s1">warned_never</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">rejected</span><span class="s3">)</span>

    <span class="s0"># Write the table file if requested</span>
    <span class="s2">if </span><span class="s1">write_tables</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">lr</span><span class="s3">.</span><span class="s1">write_table</span><span class="s3">(</span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">outputdir</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">&quot;Couldn't create %r. %s&quot; </span><span class="s3">% (</span><span class="s1">tabmodule</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>

    <span class="s0"># Write a pickled version of the tables</span>
    <span class="s2">if </span><span class="s1">picklefile</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">lr</span><span class="s3">.</span><span class="s1">pickle_table</span><span class="s3">(</span><span class="s1">picklefile</span><span class="s3">, </span><span class="s1">signature</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">IOError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">errorlog</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s4">&quot;Couldn't create %r. %s&quot; </span><span class="s3">% (</span><span class="s1">picklefile</span><span class="s3">, </span><span class="s1">e</span><span class="s3">))</span>

    <span class="s0"># Build the parser</span>
    <span class="s1">lr</span><span class="s3">.</span><span class="s1">bind_callables</span><span class="s3">(</span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">pdict</span><span class="s3">)</span>
    <span class="s1">parser </span><span class="s3">= </span><span class="s1">LRParser</span><span class="s3">(</span><span class="s1">lr</span><span class="s3">, </span><span class="s1">pinfo</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">)</span>

    <span class="s1">parse </span><span class="s3">= </span><span class="s1">parser</span><span class="s3">.</span><span class="s1">parse</span>
    <span class="s2">return </span><span class="s1">parser</span>
</pre>
</body>
</html>