<html>
<head>
<title>test_guest_mode.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_guest_mode.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">asyncio</span>
<span class="s0">import </span><span class="s1">contextvars</span>
<span class="s0">import </span><span class="s1">queue</span>
<span class="s0">import </span><span class="s1">signal</span>
<span class="s0">import </span><span class="s1">socket</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">traceback</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">inf</span>

<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">trio</span>
<span class="s0">import </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">testing</span>

<span class="s0">from </span><span class="s2">...</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">signal_raise</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">tutil </span><span class="s0">import </span><span class="s1">buggy_pypy_asyncgens</span><span class="s2">, </span><span class="s1">gc_collect_harder</span><span class="s2">, </span><span class="s1">restore_unraisablehook</span>


<span class="s3"># The simplest possible &quot;host&quot; loop.</span>
<span class="s3"># Nice features:</span>
<span class="s3"># - we can run code &quot;outside&quot; of trio using the schedule function passed to</span>
<span class="s3">#   our main</span>
<span class="s3"># - final result is returned</span>
<span class="s3"># - any unhandled exceptions cause an immediate crash</span>
<span class="s0">def </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_fn</span><span class="s2">, **</span><span class="s1">start_guest_run_kwargs</span><span class="s2">):</span>
    <span class="s1">todo </span><span class="s2">= </span><span class="s1">queue</span><span class="s2">.</span><span class="s1">Queue</span><span class="s2">()</span>

    <span class="s1">host_thread </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">run_sync_soon_threadsafe</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">host_thread </span><span class="s0">is </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">():  </span><span class="s3"># pragma: no cover</span>
            <span class="s1">crash </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span>
                <span class="s1">pytest</span><span class="s2">.</span><span class="s1">fail</span><span class="s2">, </span><span class="s4">&quot;run_sync_soon_threadsafe called from host thread&quot;</span>
            <span class="s2">)</span>
            <span class="s1">todo</span><span class="s2">.</span><span class="s1">put</span><span class="s2">((</span><span class="s4">&quot;run&quot;</span><span class="s2">, </span><span class="s1">crash</span><span class="s2">))</span>
        <span class="s1">todo</span><span class="s2">.</span><span class="s1">put</span><span class="s2">((</span><span class="s4">&quot;run&quot;</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">run_sync_soon_not_threadsafe</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">host_thread </span><span class="s0">is not </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">():  </span><span class="s3"># pragma: no cover</span>
            <span class="s1">crash </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span>
                <span class="s1">pytest</span><span class="s2">.</span><span class="s1">fail</span><span class="s2">, </span><span class="s4">&quot;run_sync_soon_not_threadsafe called from worker thread&quot;</span>
            <span class="s2">)</span>
            <span class="s1">todo</span><span class="s2">.</span><span class="s1">put</span><span class="s2">((</span><span class="s4">&quot;run&quot;</span><span class="s2">, </span><span class="s1">crash</span><span class="s2">))</span>
        <span class="s1">todo</span><span class="s2">.</span><span class="s1">put</span><span class="s2">((</span><span class="s4">&quot;run&quot;</span><span class="s2">, </span><span class="s1">fn</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">done_callback</span><span class="s2">(</span><span class="s1">outcome</span><span class="s2">):</span>
        <span class="s1">todo</span><span class="s2">.</span><span class="s1">put</span><span class="s2">((</span><span class="s4">&quot;unwrap&quot;</span><span class="s2">, </span><span class="s1">outcome</span><span class="s2">))</span>

    <span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">start_guest_run</span><span class="s2">(</span>
        <span class="s1">trio_fn</span><span class="s2">,</span>
        <span class="s1">run_sync_soon_not_threadsafe</span><span class="s2">,</span>
        <span class="s1">run_sync_soon_threadsafe</span><span class="s2">=</span><span class="s1">run_sync_soon_threadsafe</span><span class="s2">,</span>
        <span class="s1">run_sync_soon_not_threadsafe</span><span class="s2">=</span><span class="s1">run_sync_soon_not_threadsafe</span><span class="s2">,</span>
        <span class="s1">done_callback</span><span class="s2">=</span><span class="s1">done_callback</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">start_guest_run_kwargs</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">while True</span><span class="s2">:</span>
            <span class="s1">op</span><span class="s2">, </span><span class="s1">obj </span><span class="s2">= </span><span class="s1">todo</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">op </span><span class="s2">== </span><span class="s4">&quot;run&quot;</span><span class="s2">:</span>
                <span class="s1">obj</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">op </span><span class="s2">== </span><span class="s4">&quot;unwrap&quot;</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">unwrap</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:  </span><span class="s3"># pragma: no cover</span>
                <span class="s0">assert False</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s3"># Make sure that exceptions raised here don't capture these, so that</span>
        <span class="s3"># if an exception does cause us to abandon a run then the Trio state</span>
        <span class="s3"># has a chance to be GC'ed and warn about it.</span>
        <span class="s0">del </span><span class="s1">todo</span><span class="s2">, </span><span class="s1">run_sync_soon_threadsafe</span><span class="s2">, </span><span class="s1">done_callback</span>


<span class="s0">def </span><span class="s1">test_guest_trivial</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">trio_return</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_return</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>

    <span class="s0">async def </span><span class="s1">trio_fail</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s4">&quot;whoopsiedaisy&quot;</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s4">&quot;whoopsiedaisy&quot;</span><span class="s2">):</span>
        <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_fail</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_guest_can_do_io</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s1">record </span><span class="s2">= []</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">socket</span><span class="s2">.</span><span class="s1">socketpair</span><span class="s2">()</span>
        <span class="s0">with </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">:</span>
            <span class="s0">async with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>

                <span class="s0">async def </span><span class="s1">do_receive</span><span class="s2">():</span>
                    <span class="s1">record</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s0">await </span><span class="s1">a</span><span class="s2">.</span><span class="s1">recv</span><span class="s2">(</span><span class="s5">1</span><span class="s2">))</span>

                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">do_receive</span><span class="s2">)</span>
                <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>

                <span class="s0">await </span><span class="s1">b</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s6">b&quot;x&quot;</span><span class="s2">)</span>

        <span class="s0">assert </span><span class="s1">record </span><span class="s2">== [</span><span class="s6">b&quot;x&quot;</span><span class="s2">]</span>

    <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_host_can_directly_wake_trio_task</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s1">ev </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
        <span class="s1">in_host</span><span class="s2">(</span><span class="s1">ev</span><span class="s2">.</span><span class="s1">set</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">ev</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>


<span class="s0">def </span><span class="s1">test_host_altering_deadlines_wakes_trio_up</span><span class="s2">():</span>
    <span class="s0">def </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, </span><span class="s1">new_deadline</span><span class="s2">):</span>
        <span class="s1">cscope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">new_deadline</span>

    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cscope</span><span class="s2">:</span>
            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, -</span><span class="s1">inf</span><span class="s2">))</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep_forever</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">cscope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

        <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cscope</span><span class="s2">:</span>
            <span class="s3"># also do a change that doesn't affect the next deadline, just to</span>
            <span class="s3"># exercise that path</span>
            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, </span><span class="s5">1e6</span><span class="s2">))</span>
            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, -</span><span class="s1">inf</span><span class="s2">))</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">999</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">cscope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

        <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>


<span class="s0">def </span><span class="s1">test_warn_set_wakeup_fd_overwrite</span><span class="s2">():</span>
    <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">) == -</span><span class="s5">1</span>

    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

    <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">socket</span><span class="s2">.</span><span class="s1">socketpair</span><span class="s2">()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">:</span>
        <span class="s1">a</span><span class="s2">.</span><span class="s1">setblocking</span><span class="s2">(</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s3"># Warn if there's already a wakeup fd</span>
        <span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">())</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s4">&quot;signal handling code.*collided&quot;</span><span class="s2">):</span>
                <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">) == </span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">()</span>

        <span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">())</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s4">&quot;signal handling code.*collided&quot;</span><span class="s2">):</span>
                <span class="s0">assert </span><span class="s2">(</span>
                    <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">, </span><span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
                    <span class="s2">== </span><span class="s4">&quot;ok&quot;</span>
                <span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">) == </span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">()</span>

        <span class="s3"># Don't warn if there isn't already a wakeup fd</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s4">&quot;error&quot;</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>

        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s4">&quot;error&quot;</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">, </span><span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s2">== </span><span class="s4">&quot;ok&quot;</span>
            <span class="s2">)</span>

        <span class="s3"># If there's already a wakeup fd, but we've been told to trust it,</span>
        <span class="s3"># then it's left alone and there's no warning</span>
        <span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">())</span>
        <span class="s0">try</span><span class="s2">:</span>

            <span class="s0">async def </span><span class="s1">trio_check_wakeup_fd_unaltered</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
                <span class="s1">fd </span><span class="s2">= </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)</span>
                <span class="s0">assert </span><span class="s1">fd </span><span class="s2">== </span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">()</span>
                <span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(</span><span class="s1">fd</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s4">&quot;error&quot;</span><span class="s2">)</span>
                <span class="s0">assert </span><span class="s2">(</span>
                    <span class="s1">trivial_guest_run</span><span class="s2">(</span>
                        <span class="s1">trio_check_wakeup_fd_unaltered</span><span class="s2">,</span>
                        <span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s2">== </span><span class="s4">&quot;ok&quot;</span>
                <span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">set_wakeup_fd</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">) == </span><span class="s1">a</span><span class="s2">.</span><span class="s1">fileno</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_host_wakeup_doesnt_trigger_wait_all_tasks_blocked</span><span class="s2">():</span>
    <span class="s3"># This is designed to hit the branch in unrolled_run where:</span>
    <span class="s3">#   idle_primed=True</span>
    <span class="s3">#   runner.runq is empty</span>
    <span class="s3">#   events is Truth-y</span>
    <span class="s3"># ...and confirm that in this case, wait_all_tasks_blocked does not get</span>
    <span class="s3"># triggered.</span>
    <span class="s0">def </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, </span><span class="s1">new_deadline</span><span class="s2">):</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;setting deadline </span><span class="s0">{</span><span class="s1">new_deadline</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s1">cscope</span><span class="s2">.</span><span class="s1">deadline </span><span class="s2">= </span><span class="s1">new_deadline</span>

    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">async def </span><span class="s1">sit_in_wait_all_tasks_blocked</span><span class="s2">(</span><span class="s1">watb_cscope</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">watb_cscope</span><span class="s2">:</span>
                <span class="s3"># Overall point of this test is that this</span>
                <span class="s3"># wait_all_tasks_blocked should *not* return normally, but</span>
                <span class="s3"># only by cancellation.</span>
                <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">wait_all_tasks_blocked</span><span class="s2">(</span><span class="s1">cushion</span><span class="s2">=</span><span class="s5">9999</span><span class="s2">)</span>
                <span class="s0">assert False  </span><span class="s3"># pragma: no cover</span>
            <span class="s0">assert </span><span class="s1">watb_cscope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>

        <span class="s0">async def </span><span class="s1">get_woken_by_host_deadline</span><span class="s2">(</span><span class="s1">watb_cscope</span><span class="s2">):</span>
            <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">() </span><span class="s0">as </span><span class="s1">cscope</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s4">&quot;scheduling stuff to happen&quot;</span><span class="s2">)</span>

                <span class="s3"># Altering the deadline from the host, to something in the</span>
                <span class="s3"># future, will cause the run loop to wake up, but then</span>
                <span class="s3"># discover that there is nothing to do and go back to sleep.</span>
                <span class="s3"># This should *not* trigger wait_all_tasks_blocked.</span>
                <span class="s3">#</span>
                <span class="s3"># So the 'before_io_wait' here will wait until we're blocking</span>
                <span class="s3"># with the wait_all_tasks_blocked primed, and then schedule a</span>
                <span class="s3"># deadline change. The critical test is that this should *not*</span>
                <span class="s3"># wake up 'sit_in_wait_all_tasks_blocked'.</span>
                <span class="s3">#</span>
                <span class="s3"># The after we've had a chance to wake up</span>
                <span class="s3"># 'sit_in_wait_all_tasks_blocked', we want the test to</span>
                <span class="s3"># actually end. So in after_io_wait we schedule a second host</span>
                <span class="s3"># call to tear things down.</span>
                <span class="s0">class </span><span class="s1">InstrumentHelper</span><span class="s2">:</span>
                    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">primed </span><span class="s2">= </span><span class="s0">False</span>

                    <span class="s0">def </span><span class="s1">before_io_wait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">):</span>
                        <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;before_io_wait(</span><span class="s0">{</span><span class="s1">timeout</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">timeout </span><span class="s2">== </span><span class="s5">9999</span><span class="s2">:  </span><span class="s3"># pragma: no branch</span>
                            <span class="s0">assert not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">primed</span>
                            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">set_deadline</span><span class="s2">(</span><span class="s1">cscope</span><span class="s2">, </span><span class="s5">1e9</span><span class="s2">))</span>
                            <span class="s1">self</span><span class="s2">.</span><span class="s1">primed </span><span class="s2">= </span><span class="s0">True</span>

                    <span class="s0">def </span><span class="s1">after_io_wait</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">):</span>
                        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">primed</span><span class="s2">:  </span><span class="s3"># pragma: no branch</span>
                            <span class="s1">print</span><span class="s2">(</span><span class="s4">&quot;instrument triggered&quot;</span><span class="s2">)</span>
                            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">cscope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">())</span>
                            <span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">remove_instrument</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

                <span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">add_instrument</span><span class="s2">(</span><span class="s1">InstrumentHelper</span><span class="s2">())</span>
                <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep_forever</span><span class="s2">()</span>
            <span class="s0">assert </span><span class="s1">cscope</span><span class="s2">.</span><span class="s1">cancelled_caught</span>
            <span class="s1">watb_cscope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>

        <span class="s0">async with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">watb_cscope </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">CancelScope</span><span class="s2">()</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">sit_in_wait_all_tasks_blocked</span><span class="s2">, </span><span class="s1">watb_cscope</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">wait_all_tasks_blocked</span><span class="s2">()</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">get_woken_by_host_deadline</span><span class="s2">, </span><span class="s1">watb_cscope</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s4">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">) == </span><span class="s4">&quot;ok&quot;</span>


<span class="s2">@</span><span class="s1">restore_unraisablehook</span><span class="s2">()</span>
<span class="s0">def </span><span class="s1">test_guest_warns_if_abandoned</span><span class="s2">():</span>
    <span class="s3"># This warning is emitted from the garbage collector. So we have to make</span>
    <span class="s3"># sure that our abandoned run is garbage. The easiest way to do this is to</span>
    <span class="s3"># put it into a function, so that we're sure all the local state,</span>
    <span class="s3"># traceback frames, etc. are garbage once it returns.</span>
    <span class="s0">def </span><span class="s1">do_abandoned_guest_run</span><span class="s2">():</span>
        <span class="s0">async def </span><span class="s1">abandoned_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
            <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s5">1 </span><span class="s2">/ </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ZeroDivisionError</span><span class="s2">):</span>
            <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">abandoned_main</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s4">&quot;Trio guest run got abandoned&quot;</span><span class="s2">):</span>
        <span class="s1">do_abandoned_guest_run</span><span class="s2">()</span>
        <span class="s1">gc_collect_harder</span><span class="s2">()</span>

        <span class="s3"># If you have problems some day figuring out what's holding onto a</span>
        <span class="s3"># reference to the unrolled_run generator and making this test fail,</span>
        <span class="s3"># then this might be useful to help track it down. (It assumes you</span>
        <span class="s3"># also hack start_guest_run so that it does 'global W; W =</span>
        <span class="s3"># weakref(unrolled_run_gen)'.)</span>
        <span class="s3">#</span>
        <span class="s3"># import gc</span>
        <span class="s3"># print(trio._core._run.W)</span>
        <span class="s3"># targets = [trio._core._run.W()]</span>
        <span class="s3"># for i in range(15):</span>
        <span class="s3">#     new_targets = []</span>
        <span class="s3">#     for target in targets:</span>
        <span class="s3">#         new_targets += gc.get_referrers(target)</span>
        <span class="s3">#         new_targets.remove(targets)</span>
        <span class="s3">#     print(&quot;#####################&quot;)</span>
        <span class="s3">#     print(f&quot;depth {i}: {len(new_targets)}&quot;)</span>
        <span class="s3">#     print(new_targets)</span>
        <span class="s3">#     targets = new_targets</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
            <span class="s1">trio</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">aiotrio_run</span><span class="s2">(</span><span class="s1">trio_fn</span><span class="s2">, *, </span><span class="s1">pass_not_threadsafe</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, **</span><span class="s1">start_guest_run_kwargs</span><span class="s2">):</span>
    <span class="s1">loop </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">new_event_loop</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">aio_main</span><span class="s2">():</span>
        <span class="s1">trio_done_fut </span><span class="s2">= </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">create_future</span><span class="s2">()</span>

        <span class="s0">def </span><span class="s1">trio_done_callback</span><span class="s2">(</span><span class="s1">main_outcome</span><span class="s2">):</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;trio_fn finished: </span><span class="s0">{</span><span class="s1">main_outcome</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s2">)</span>
            <span class="s1">trio_done_fut</span><span class="s2">.</span><span class="s1">set_result</span><span class="s2">(</span><span class="s1">main_outcome</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">pass_not_threadsafe</span><span class="s2">:</span>
            <span class="s1">start_guest_run_kwargs</span><span class="s2">[</span><span class="s4">&quot;run_sync_soon_not_threadsafe&quot;</span><span class="s2">] = </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">call_soon</span>

        <span class="s1">trio</span><span class="s2">.</span><span class="s1">lowlevel</span><span class="s2">.</span><span class="s1">start_guest_run</span><span class="s2">(</span>
            <span class="s1">trio_fn</span><span class="s2">,</span>
            <span class="s1">run_sync_soon_threadsafe</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">.</span><span class="s1">call_soon_threadsafe</span><span class="s2">,</span>
            <span class="s1">done_callback</span><span class="s2">=</span><span class="s1">trio_done_callback</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">start_guest_run_kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s2">(</span><span class="s0">await </span><span class="s1">trio_done_fut</span><span class="s2">).</span><span class="s1">unwrap</span><span class="s2">()</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">loop</span><span class="s2">.</span><span class="s1">run_until_complete</span><span class="s2">(</span><span class="s1">aio_main</span><span class="s2">())</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">loop</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_guest_mode_on_asyncio</span><span class="s2">():</span>
    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">():</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s4">&quot;trio_main!&quot;</span><span class="s2">)</span>

        <span class="s1">to_trio</span><span class="s2">, </span><span class="s1">from_aio </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_memory_channel</span><span class="s2">(</span><span class="s1">float</span><span class="s2">(</span><span class="s4">&quot;inf&quot;</span><span class="s2">))</span>
        <span class="s1">from_trio </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">Queue</span><span class="s2">()</span>

        <span class="s1">aio_task </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">ensure_future</span><span class="s2">(</span><span class="s1">aio_pingpong</span><span class="s2">(</span><span class="s1">from_trio</span><span class="s2">, </span><span class="s1">to_trio</span><span class="s2">))</span>

        <span class="s3"># Make sure we have at least one tick where we don't need to go into</span>
        <span class="s3"># the thread</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s1">from_trio</span><span class="s2">.</span><span class="s1">put_nowait</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s0">async for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">from_aio</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;trio got: </span><span class="s0">{</span><span class="s1">n</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
            <span class="s1">from_trio</span><span class="s2">.</span><span class="s1">put_nowait</span><span class="s2">(</span><span class="s1">n </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">n </span><span class="s2">&gt;= </span><span class="s5">10</span><span class="s2">:</span>
                <span class="s1">aio_task</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s0">return </span><span class="s4">&quot;trio-main-done&quot;</span>

    <span class="s0">async def </span><span class="s1">aio_pingpong</span><span class="s2">(</span><span class="s1">from_trio</span><span class="s2">, </span><span class="s1">to_trio</span><span class="s2">):</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s4">&quot;aio_pingpong!&quot;</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">while True</span><span class="s2">:</span>
                <span class="s1">n </span><span class="s2">= </span><span class="s0">await </span><span class="s1">from_trio</span><span class="s2">.</span><span class="s1">get</span><span class="s2">()</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s4">f&quot;aio got: </span><span class="s0">{</span><span class="s1">n</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
                <span class="s1">to_trio</span><span class="s2">.</span><span class="s1">send_nowait</span><span class="s2">(</span><span class="s1">n </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">CancelledError</span><span class="s2">:</span>
            <span class="s0">raise</span>
        <span class="s0">except</span><span class="s2">:  </span><span class="s3"># pragma: no cover</span>
            <span class="s1">traceback</span><span class="s2">.</span><span class="s1">print_exc</span><span class="s2">()</span>
            <span class="s0">raise</span>

    <span class="s0">assert </span><span class="s2">(</span>
        <span class="s1">aiotrio_run</span><span class="s2">(</span>
            <span class="s1">trio_main</span><span class="s2">,</span>
            <span class="s3"># Not all versions of asyncio we test on can actually be trusted,</span>
            <span class="s3"># but this test doesn't care about signal handling, and it's</span>
            <span class="s3"># easier to just avoid the warnings.</span>
            <span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s2">== </span><span class="s4">&quot;trio-main-done&quot;</span>
    <span class="s2">)</span>

    <span class="s0">assert </span><span class="s2">(</span>
        <span class="s1">aiotrio_run</span><span class="s2">(</span>
            <span class="s1">trio_main</span><span class="s2">,</span>
            <span class="s3"># Also check that passing only call_soon_threadsafe works, via the</span>
            <span class="s3"># fallback path where we use it for everything.</span>
            <span class="s1">pass_not_threadsafe</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
            <span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s2">== </span><span class="s4">&quot;trio-main-done&quot;</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_guest_mode_internal_errors</span><span class="s2">(</span><span class="s1">monkeypatch</span><span class="s2">, </span><span class="s1">recwarn</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">monkeypatch</span><span class="s2">.</span><span class="s1">context</span><span class="s2">() </span><span class="s0">as </span><span class="s1">m</span><span class="s2">:</span>

        <span class="s0">async def </span><span class="s1">crash_in_run_loop</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
            <span class="s1">m</span><span class="s2">.</span><span class="s1">setattr</span><span class="s2">(</span><span class="s4">&quot;trio._core._run.GLOBAL_RUN_CONTEXT.runner.runq&quot;</span><span class="s2">, </span><span class="s4">&quot;HI&quot;</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
            <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">crash_in_run_loop</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">monkeypatch</span><span class="s2">.</span><span class="s1">context</span><span class="s2">() </span><span class="s0">as </span><span class="s1">m</span><span class="s2">:</span>

        <span class="s0">async def </span><span class="s1">crash_in_io</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
            <span class="s1">m</span><span class="s2">.</span><span class="s1">setattr</span><span class="s2">(</span><span class="s4">&quot;trio._core._run.TheIOManager.get_events&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
            <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">crash_in_io</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">monkeypatch</span><span class="s2">.</span><span class="s1">context</span><span class="s2">() </span><span class="s0">as </span><span class="s1">m</span><span class="s2">:</span>

        <span class="s0">async def </span><span class="s1">crash_in_worker_thread_io</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
            <span class="s1">t </span><span class="s2">= </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">()</span>
            <span class="s1">old_get_events </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_run</span><span class="s2">.</span><span class="s1">TheIOManager</span><span class="s2">.</span><span class="s1">get_events</span>

            <span class="s0">def </span><span class="s1">bad_get_events</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">threading</span><span class="s2">.</span><span class="s1">current_thread</span><span class="s2">() </span><span class="s0">is not </span><span class="s1">t</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;oh no!&quot;</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">old_get_events</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>

            <span class="s1">m</span><span class="s2">.</span><span class="s1">setattr</span><span class="s2">(</span><span class="s4">&quot;trio._core._run.TheIOManager.get_events&quot;</span><span class="s2">, </span><span class="s1">bad_get_events</span><span class="s2">)</span>

            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>

        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TrioInternalError</span><span class="s2">):</span>
            <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">crash_in_worker_thread_io</span><span class="s2">)</span>

    <span class="s1">gc_collect_harder</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_guest_mode_ki</span><span class="s2">():</span>
    <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">getsignal</span><span class="s2">(</span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">) </span><span class="s0">is </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">default_int_handler</span>

    <span class="s3"># Check SIGINT in Trio func and in host func</span>
    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyboardInterrupt</span><span class="s2">):</span>
            <span class="s1">signal_raise</span><span class="s2">(</span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">)</span>

        <span class="s3"># Host SIGINT should get injected into Trio</span>
        <span class="s1">in_host</span><span class="s2">(</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">signal_raise</span><span class="s2">, </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">))</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyboardInterrupt</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is None</span>
    <span class="s3"># Signal handler should be restored properly on exit</span>
    <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">getsignal</span><span class="s2">(</span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">) </span><span class="s0">is </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">default_int_handler</span>

    <span class="s3"># Also check chaining in the case where KI is injected after main exits</span>
    <span class="s1">final_exc </span><span class="s2">= </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s4">&quot;whoa&quot;</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">trio_main_raising</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s1">in_host</span><span class="s2">(</span><span class="s1">partial</span><span class="s2">(</span><span class="s1">signal_raise</span><span class="s2">, </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">))</span>
        <span class="s0">raise </span><span class="s1">final_exc</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">KeyboardInterrupt</span><span class="s2">) </span><span class="s0">as </span><span class="s1">excinfo</span><span class="s2">:</span>
        <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main_raising</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">excinfo</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">__context__ </span><span class="s0">is </span><span class="s1">final_exc</span>

    <span class="s0">assert </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">getsignal</span><span class="s2">(</span><span class="s1">signal</span><span class="s2">.</span><span class="s1">SIGINT</span><span class="s2">) </span><span class="s0">is </span><span class="s1">signal</span><span class="s2">.</span><span class="s1">default_int_handler</span>


<span class="s0">def </span><span class="s1">test_guest_mode_autojump_clock_threshold_changing</span><span class="s2">():</span>
    <span class="s3"># This is super obscure and probably no-one will ever notice, but</span>
    <span class="s3"># technically mutating the MockClock.autojump_threshold from the host</span>
    <span class="s3"># should wake up the guest, so let's test it.</span>

    <span class="s1">clock </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">MockClock</span><span class="s2">()</span>

    <span class="s1">DURATION </span><span class="s2">= </span><span class="s5">120</span>

    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">(</span><span class="s1">in_host</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s5">0</span>
        <span class="s1">in_host</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s1">setattr</span><span class="s2">(</span><span class="s1">clock</span><span class="s2">, </span><span class="s4">&quot;autojump_threshold&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>
        <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep</span><span class="s2">(</span><span class="s1">DURATION</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">current_time</span><span class="s2">() == </span><span class="s1">DURATION</span>

    <span class="s1">start </span><span class="s2">= </span><span class="s1">time</span><span class="s2">.</span><span class="s1">monotonic</span><span class="s2">()</span>
    <span class="s1">trivial_guest_run</span><span class="s2">(</span><span class="s1">trio_main</span><span class="s2">, </span><span class="s1">clock</span><span class="s2">=</span><span class="s1">clock</span><span class="s2">)</span>
    <span class="s1">end </span><span class="s2">= </span><span class="s1">time</span><span class="s2">.</span><span class="s1">monotonic</span><span class="s2">()</span>
    <span class="s3"># Should be basically instantaneous, but we'll leave a generous buffer to</span>
    <span class="s3"># account for any CI weirdness</span>
    <span class="s0">assert </span><span class="s1">end </span><span class="s2">- </span><span class="s1">start </span><span class="s2">&lt; </span><span class="s1">DURATION </span><span class="s2">/ </span><span class="s5">2</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span><span class="s1">buggy_pypy_asyncgens</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;PyPy 7.2 is buggy&quot;</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
    <span class="s1">sys</span><span class="s2">.</span><span class="s1">implementation</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s4">&quot;pypy&quot;</span><span class="s2">,</span>
    <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;async generator issue under investigation&quot;</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s2">@</span><span class="s1">restore_unraisablehook</span><span class="s2">()</span>
<span class="s0">def </span><span class="s1">test_guest_mode_asyncgens</span><span class="s2">():</span>
    <span class="s0">import </span><span class="s1">sniffio</span>

    <span class="s1">record </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">agen</span><span class="s2">(</span><span class="s1">label</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">() == </span><span class="s1">label</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s5">1</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">library </span><span class="s2">= </span><span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library</span><span class="s2">()</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">[</span><span class="s1">library</span><span class="s2">].</span><span class="s1">sleep</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">:</span>
                <span class="s0">pass</span>
            <span class="s1">record</span><span class="s2">.</span><span class="s1">add</span><span class="s2">((</span><span class="s1">label</span><span class="s2">, </span><span class="s1">library</span><span class="s2">))</span>

    <span class="s0">async def </span><span class="s1">iterate_in_aio</span><span class="s2">():</span>
        <span class="s3"># &quot;trio&quot; gets inherited from our Trio caller if we don't set this</span>
        <span class="s1">sniffio</span><span class="s2">.</span><span class="s1">current_async_library_cvar</span><span class="s2">.</span><span class="s1">set</span><span class="s2">(</span><span class="s4">&quot;asyncio&quot;</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">agen</span><span class="s2">(</span><span class="s4">&quot;asyncio&quot;</span><span class="s2">).</span><span class="s1">asend</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">trio_main</span><span class="s2">():</span>
        <span class="s1">task </span><span class="s2">= </span><span class="s1">asyncio</span><span class="s2">.</span><span class="s1">ensure_future</span><span class="s2">(</span><span class="s1">iterate_in_aio</span><span class="s2">())</span>
        <span class="s1">done_evt </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
        <span class="s1">task</span><span class="s2">.</span><span class="s1">add_done_callback</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: </span><span class="s1">done_evt</span><span class="s2">.</span><span class="s1">set</span><span class="s2">())</span>
        <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">fail_after</span><span class="s2">(</span><span class="s5">1</span><span class="s2">):</span>
            <span class="s0">await </span><span class="s1">done_evt</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>

        <span class="s0">await </span><span class="s1">agen</span><span class="s2">(</span><span class="s4">&quot;trio&quot;</span><span class="s2">).</span><span class="s1">asend</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">gc_collect_harder</span><span class="s2">()</span>

    <span class="s3"># Ensure we don't pollute the thread-level context if run under</span>
    <span class="s3"># an asyncio without contextvars support (3.6)</span>
    <span class="s1">context </span><span class="s2">= </span><span class="s1">contextvars</span><span class="s2">.</span><span class="s1">copy_context</span><span class="s2">()</span>
    <span class="s1">context</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">aiotrio_run</span><span class="s2">, </span><span class="s1">trio_main</span><span class="s2">, </span><span class="s1">host_uses_signal_set_wakeup_fd</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">record </span><span class="s2">== {(</span><span class="s4">&quot;asyncio&quot;</span><span class="s2">, </span><span class="s4">&quot;asyncio&quot;</span><span class="s2">), (</span><span class="s4">&quot;trio&quot;</span><span class="s2">, </span><span class="s4">&quot;trio&quot;</span><span class="s2">)}</span>
</pre>
</body>
</html>