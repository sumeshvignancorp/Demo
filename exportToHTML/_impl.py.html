<html>
<head>
<title>_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">OrderedDict</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">asynccontextmanager</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">ipaddress </span><span class="s0">import </span><span class="s1">ip_address</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">ssl</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">urllib</span><span class="s2">.</span><span class="s1">parse</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">trio</span>
<span class="s0">import </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">exceptiongroup </span><span class="s0">import </span><span class="s1">BaseExceptionGroup</span>
<span class="s0">from </span><span class="s1">wsproto </span><span class="s0">import </span><span class="s1">ConnectionType</span><span class="s2">, </span><span class="s1">WSConnection</span>
<span class="s0">from </span><span class="s1">wsproto</span><span class="s2">.</span><span class="s1">connection </span><span class="s0">import </span><span class="s1">ConnectionState</span>
<span class="s0">import </span><span class="s1">wsproto</span><span class="s2">.</span><span class="s1">frame_protocol </span><span class="s0">as </span><span class="s1">wsframeproto</span>
<span class="s0">from </span><span class="s1">wsproto</span><span class="s2">.</span><span class="s1">events </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">AcceptConnection</span><span class="s2">,</span>
    <span class="s1">BytesMessage</span><span class="s2">,</span>
    <span class="s1">CloseConnection</span><span class="s2">,</span>
    <span class="s1">Ping</span><span class="s2">,</span>
    <span class="s1">Pong</span><span class="s2">,</span>
    <span class="s1">RejectConnection</span><span class="s2">,</span>
    <span class="s1">RejectData</span><span class="s2">,</span>
    <span class="s1">Request</span><span class="s2">,</span>
    <span class="s1">TextMessage</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">wsproto</span><span class="s2">.</span><span class="s1">utilities</span>

<span class="s1">_TRIO_MULTI_ERROR </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">'.'</span><span class="s2">)[:</span><span class="s4">2</span><span class="s2">])) &lt; (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">22</span><span class="s2">)</span>

<span class="s1">CONN_TIMEOUT </span><span class="s2">= </span><span class="s4">60 </span><span class="s5"># default connect &amp; disconnect timeout, in seconds</span>
<span class="s1">MESSAGE_QUEUE_SIZE </span><span class="s2">= </span><span class="s4">1</span>
<span class="s1">MAX_MESSAGE_SIZE </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">** </span><span class="s4">20 </span><span class="s5"># 1 MiB</span>
<span class="s1">RECEIVE_BYTES </span><span class="s2">= </span><span class="s4">4 </span><span class="s2">* </span><span class="s4">2 </span><span class="s2">** </span><span class="s4">10 </span><span class="s5"># 4 KiB</span>
<span class="s1">logger </span><span class="s2">= </span><span class="s1">logging</span><span class="s2">.</span><span class="s1">getLogger</span><span class="s2">(</span><span class="s3">'trio-websocket'</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_ignore_cancel</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">):</span>
    <span class="s0">return None if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">) </span><span class="s0">else </span><span class="s1">exc</span>


<span class="s0">class </span><span class="s1">_preserve_current_exception</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot;A context manager which should surround an ``__exit__`` or 
    ``__aexit__`` handler or the contents of a ``finally:`` 
    block. It ensures that any exception that was being handled 
    upon entry is not masked by a `trio.Cancelled` raised within 
    the body of the context manager. 
 
    https://github.com/python-trio/trio/issues/1559 
    https://gitter.im/python-trio/general?at=5faf2293d37a1a13d6a582cf 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ </span><span class="s2">= (</span><span class="s3">&quot;_armed&quot;</span><span class="s2">,)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_armed </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__enter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_armed </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">exc_info</span><span class="s2">()[</span><span class="s4">1</span><span class="s2">] </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">__exit__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">tb</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_armed</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s0">if </span><span class="s1">_TRIO_MULTI_ERROR</span><span class="s2">:</span>
            <span class="s1">filtered_exception </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">MultiError</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">_ignore_cancel</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)  </span><span class="s5"># pylint: disable=no-member</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">BaseExceptionGroup</span><span class="s2">):</span>
            <span class="s1">filtered_exception </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">subgroup</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">exc</span><span class="s2">: </span><span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">exc</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Cancelled</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">filtered_exception </span><span class="s2">= </span><span class="s1">_ignore_cancel</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">filtered_exception </span><span class="s0">is None</span>


<span class="s2">@</span><span class="s1">asynccontextmanager</span>
<span class="s0">async def </span><span class="s1">open_websocket</span><span class="s2">(</span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, *, </span><span class="s1">use_ssl</span><span class="s2">, </span><span class="s1">subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">,</span>
    <span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">, </span><span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">):</span>
    <span class="s6">''' 
    Open a WebSocket client connection to a host. 
 
    This async context manager connects when entering the context manager and 
    disconnects when exiting. It yields a 
    :class:`WebSocketConnection` instance. 
 
    :param str host: The host to connect to. 
    :param int port: The port to connect to. 
    :param str resource: The resource, i.e. URL path. 
    :param Union[bool, ssl.SSLContext] use_ssl: If this is an SSL context, then 
        use that context. If this is ``True`` then use default SSL context. If 
        this is ``False`` then disable SSL. 
    :param subprotocols: An iterable of strings representing preferred 
        subprotocols. 
    :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples containing 
        HTTP header key/value pairs to send with the connection request. Note 
        that headers used by the WebSocket protocol (e.g. 
        ``Sec-WebSocket-Accept``) will be overwritten. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :param float connect_timeout: The number of seconds to wait for the 
        connection before timing out. 
    :param float disconnect_timeout: The number of seconds to wait when closing 
        the connection before timing out. 
    :raises HandshakeError: for any networking error, 
        client-side timeout (:exc:`ConnectionTimeout`, :exc:`DisconnectionTimeout`), 
        or server rejection (:exc:`ConnectionRejected`) during handshakes. 
    '''</span>
    <span class="s0">async with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">new_nursery</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">fail_after</span><span class="s2">(</span><span class="s1">connect_timeout</span><span class="s2">):</span>
                <span class="s1">connection </span><span class="s2">= </span><span class="s0">await </span><span class="s1">connect_websocket</span><span class="s2">(</span><span class="s1">new_nursery</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">,</span>
                    <span class="s1">resource</span><span class="s2">, </span><span class="s1">use_ssl</span><span class="s2">=</span><span class="s1">use_ssl</span><span class="s2">, </span><span class="s1">subprotocols</span><span class="s2">=</span><span class="s1">subprotocols</span><span class="s2">,</span>
                    <span class="s1">extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">,</span>
                    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
                    <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TooSlowError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionTimeout </span><span class="s0">from None</span>
        <span class="s0">except </span><span class="s1">OSError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">HandshakeError </span><span class="s0">from </span><span class="s1">e</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">yield </span><span class="s1">connection</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">fail_after</span><span class="s2">(</span><span class="s1">disconnect_timeout</span><span class="s2">):</span>
                    <span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
            <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TooSlowError</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">DisconnectionTimeout </span><span class="s0">from None</span>


<span class="s0">async def </span><span class="s1">connect_websocket</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, *, </span><span class="s1">use_ssl</span><span class="s2">,</span>
    <span class="s1">subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">):</span>
    <span class="s6">''' 
    Return an open WebSocket client connection to a host. 
 
    This function is used to specify a custom nursery to run connection 
    background tasks in. The caller is responsible for closing the connection. 
 
    If you don't need a custom nursery, you should probably use 
    :func:`open_websocket` instead. 
 
    :param nursery: A Trio nursery to run background tasks in. 
    :param str host: The host to connect to. 
    :param int port: The port to connect to. 
    :param str resource: The resource, i.e. URL path. 
    :param Union[bool, ssl.SSLContext] use_ssl: If this is an SSL context, then 
        use that context. If this is ``True`` then use default SSL context. If 
        this is ``False`` then disable SSL. 
    :param subprotocols: An iterable of strings representing preferred 
        subprotocols. 
    :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples containing 
        HTTP header key/value pairs to send with the connection request. Note 
        that headers used by the WebSocket protocol (e.g. 
        ``Sec-WebSocket-Accept``) will be overwritten. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :rtype: WebSocketConnection 
    '''</span>
    <span class="s0">if </span><span class="s1">use_ssl </span><span class="s0">is True</span><span class="s2">:</span>
        <span class="s1">ssl_context </span><span class="s2">= </span><span class="s1">ssl</span><span class="s2">.</span><span class="s1">create_default_context</span><span class="s2">()</span>
    <span class="s0">elif </span><span class="s1">use_ssl </span><span class="s0">is False</span><span class="s2">:</span>
        <span class="s1">ssl_context </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">use_ssl</span><span class="s2">, </span><span class="s1">ssl</span><span class="s2">.</span><span class="s1">SSLContext</span><span class="s2">):</span>
        <span class="s1">ssl_context </span><span class="s2">= </span><span class="s1">use_ssl</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'`use_ssl` argument must be bool or ssl.SSLContext'</span><span class="s2">)</span>

    <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'Connecting to ws%s://%s:%d%s'</span><span class="s2">,</span>
        <span class="s3">'' </span><span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">is None else </span><span class="s3">'s'</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">stream </span><span class="s2">= </span><span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_tcp_stream</span><span class="s2">(</span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">stream </span><span class="s2">= </span><span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_ssl_over_tcp_stream</span><span class="s2">(</span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">,</span>
            <span class="s1">ssl_context</span><span class="s2">=</span><span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">https_compatible</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">port </span><span class="s0">in </span><span class="s2">(</span><span class="s4">80</span><span class="s2">, </span><span class="s4">443</span><span class="s2">):</span>
        <span class="s1">host_header </span><span class="s2">= </span><span class="s1">host</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">host_header </span><span class="s2">= </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">host</span><span class="s0">}</span><span class="s3">:</span><span class="s0">{</span><span class="s1">port</span><span class="s0">}</span><span class="s3">'</span>
    <span class="s1">connection </span><span class="s2">= </span><span class="s1">WebSocketConnection</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">,</span>
        <span class="s1">WSConnection</span><span class="s2">(</span><span class="s1">ConnectionType</span><span class="s2">.</span><span class="s1">CLIENT</span><span class="s2">),</span>
        <span class="s1">host</span><span class="s2">=</span><span class="s1">host_header</span><span class="s2">,</span>
        <span class="s1">path</span><span class="s2">=</span><span class="s1">resource</span><span class="s2">,</span>
        <span class="s1">client_subprotocols</span><span class="s2">=</span><span class="s1">subprotocols</span><span class="s2">, </span><span class="s1">client_extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">,</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">)</span>
    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_reader_task</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_open_handshake</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">connection</span>


<span class="s0">def </span><span class="s1">open_websocket_url</span><span class="s2">(</span><span class="s1">url</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">,</span>
    <span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">, </span><span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">):</span>
    <span class="s6">''' 
    Open a WebSocket client connection to a URL. 
 
    This async context manager connects when entering the context manager and 
    disconnects when exiting. It yields a 
    :class:`WebSocketConnection` instance. 
 
    :param str url: A WebSocket URL, i.e. `ws:` or `wss:` URL scheme. 
    :param ssl_context: Optional SSL context used for ``wss:`` URLs. A default 
        SSL context is used for ``wss:`` if this argument is ``None``. 
    :type ssl_context: ssl.SSLContext or None 
    :param subprotocols: An iterable of strings representing preferred 
        subprotocols. 
    :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples containing 
        HTTP header key/value pairs to send with the connection request. Note 
        that headers used by the WebSocket protocol (e.g. 
        ``Sec-WebSocket-Accept``) will be overwritten. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :param float connect_timeout: The number of seconds to wait for the 
        connection before timing out. 
    :param float disconnect_timeout: The number of seconds to wait when closing 
        the connection before timing out. 
    :raises HandshakeError: for any networking error, 
        client-side timeout (:exc:`ConnectionTimeout`, :exc:`DisconnectionTimeout`), 
        or server rejection (:exc:`ConnectionRejected`) during handshakes. 
    '''</span>
    <span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, </span><span class="s1">ssl_context </span><span class="s2">= </span><span class="s1">_url_to_host</span><span class="s2">(</span><span class="s1">url</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">open_websocket</span><span class="s2">(</span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, </span><span class="s1">use_ssl</span><span class="s2">=</span><span class="s1">ssl_context</span><span class="s2">,</span>
        <span class="s1">subprotocols</span><span class="s2">=</span><span class="s1">subprotocols</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">,</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">,</span>
        <span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">connect_timeout</span><span class="s2">, </span><span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">disconnect_timeout</span><span class="s2">)</span>


<span class="s0">async def </span><span class="s1">connect_websocket_url</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">url</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *,</span>
    <span class="s1">subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">):</span>
    <span class="s6">''' 
    Return an open WebSocket client connection to a URL. 
 
    This function is used to specify a custom nursery to run connection 
    background tasks in. The caller is responsible for closing the connection. 
 
    If you don't need a custom nursery, you should probably use 
    :func:`open_websocket_url` instead. 
 
    :param nursery: A nursery to run background tasks in. 
    :param str url: A WebSocket URL. 
    :param ssl_context: Optional SSL context used for ``wss:`` URLs. 
    :type ssl_context: ssl.SSLContext or None 
    :param subprotocols: An iterable of strings representing preferred 
        subprotocols. 
    :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples containing 
        HTTP header key/value pairs to send with the connection request. Note 
        that headers used by the WebSocket protocol (e.g. 
        ``Sec-WebSocket-Accept``) will be overwritten. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :rtype: WebSocketConnection 
    '''</span>
    <span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, </span><span class="s1">ssl_context </span><span class="s2">= </span><span class="s1">_url_to_host</span><span class="s2">(</span><span class="s1">url</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">)</span>
    <span class="s0">return await </span><span class="s1">connect_websocket</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">,</span>
        <span class="s1">use_ssl</span><span class="s2">=</span><span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">subprotocols</span><span class="s2">=</span><span class="s1">subprotocols</span><span class="s2">,</span>
        <span class="s1">extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">, </span><span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_url_to_host</span><span class="s2">(</span><span class="s1">url</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">):</span>
    <span class="s6">''' 
    Convert a WebSocket URL to a (host,port,resource) tuple. 
 
    The returned ``ssl_context`` is either the same object that was passed in, 
    or if ``ssl_context`` is None, then a bool indicating if a default SSL 
    context needs to be created. 
 
    :param str url: A WebSocket URL. 
    :type ssl_context: ssl.SSLContext or None 
    :returns: A tuple of ``(host, port, resource, ssl_context)``. 
    '''</span>
    <span class="s1">url </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">url</span><span class="s2">)  </span><span class="s5"># For backward compat with isinstance(url, yarl.URL).</span>
    <span class="s1">parts </span><span class="s2">= </span><span class="s1">urllib</span><span class="s2">.</span><span class="s1">parse</span><span class="s2">.</span><span class="s1">urlsplit</span><span class="s2">(</span><span class="s1">url</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">scheme </span><span class="s0">not in </span><span class="s2">(</span><span class="s3">'ws'</span><span class="s2">, </span><span class="s3">'wss'</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'WebSocket URL scheme must be &quot;ws:&quot; or &quot;wss:&quot;'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">ssl_context </span><span class="s2">= </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">scheme </span><span class="s2">== </span><span class="s3">'wss'</span>
    <span class="s0">elif </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">scheme </span><span class="s2">== </span><span class="s3">'ws'</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'SSL context must be None for ws: URL scheme'</span><span class="s2">)</span>
    <span class="s1">host </span><span class="s2">= </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">hostname</span>
    <span class="s0">if </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">port </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">port </span><span class="s2">= </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">port</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">port </span><span class="s2">= </span><span class="s4">443 </span><span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">else </span><span class="s4">80</span>
    <span class="s1">path_qs </span><span class="s2">= </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">path</span>
    <span class="s5"># RFC 7230, Section 5.3.1:</span>
    <span class="s5"># If the target URI's path component is empty, the client MUST</span>
    <span class="s5"># send &quot;/&quot; as the path within the origin-form of request-target.</span>
    <span class="s0">if not </span><span class="s1">path_qs</span><span class="s2">:</span>
        <span class="s1">path_qs </span><span class="s2">= </span><span class="s3">'/'</span>
    <span class="s0">if </span><span class="s3">'?' </span><span class="s0">in </span><span class="s1">url</span><span class="s2">:</span>
        <span class="s1">path_qs </span><span class="s2">+= </span><span class="s3">'?' </span><span class="s2">+ </span><span class="s1">parts</span><span class="s2">.</span><span class="s1">query</span>
    <span class="s0">return </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">path_qs</span><span class="s2">, </span><span class="s1">ssl_context</span>


<span class="s0">async def </span><span class="s1">wrap_client_stream</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">resource</span><span class="s2">, *,</span>
    <span class="s1">subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">):</span>
    <span class="s6">''' 
    Wrap an arbitrary stream in a WebSocket connection. 
 
    This is a low-level function only needed in rare cases. In most cases, you 
    should use :func:`open_websocket` or :func:`open_websocket_url`. 
 
    :param nursery: A Trio nursery to run background tasks in. 
    :param stream: A Trio stream to be wrapped. 
    :type stream: trio.abc.Stream 
    :param str host: A host string that will be sent in the ``Host:`` header. 
    :param str resource: A resource string, i.e. the path component to be 
        accessed on the server. 
    :param subprotocols: An iterable of strings representing preferred 
        subprotocols. 
    :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples containing 
        HTTP header key/value pairs to send with the connection request. Note 
        that headers used by the WebSocket protocol (e.g. 
        ``Sec-WebSocket-Accept``) will be overwritten. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :rtype: WebSocketConnection 
    '''</span>
    <span class="s1">connection </span><span class="s2">= </span><span class="s1">WebSocketConnection</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">,</span>
        <span class="s1">WSConnection</span><span class="s2">(</span><span class="s1">ConnectionType</span><span class="s2">.</span><span class="s1">CLIENT</span><span class="s2">),</span>
        <span class="s1">host</span><span class="s2">=</span><span class="s1">host</span><span class="s2">, </span><span class="s1">path</span><span class="s2">=</span><span class="s1">resource</span><span class="s2">,</span>
        <span class="s1">client_subprotocols</span><span class="s2">=</span><span class="s1">subprotocols</span><span class="s2">, </span><span class="s1">client_extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">,</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">)</span>
    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_reader_task</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_open_handshake</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">connection</span>


<span class="s0">async def </span><span class="s1">wrap_server_stream</span><span class="s2">(</span><span class="s1">nursery</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">,</span>
    <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">, </span><span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">):</span>
    <span class="s6">''' 
    Wrap an arbitrary stream in a server-side WebSocket. 
 
    This is a low-level function only needed in rare cases. In most cases, you 
    should use :func:`serve_websocket`. 
 
    :param nursery: A nursery to run background tasks in. 
    :param stream: A stream to be wrapped. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :type stream: trio.abc.Stream 
    :rtype: WebSocketRequest 
    '''</span>
    <span class="s1">connection </span><span class="s2">= </span><span class="s1">WebSocketConnection</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">,</span>
        <span class="s1">WSConnection</span><span class="s2">(</span><span class="s1">ConnectionType</span><span class="s2">.</span><span class="s1">SERVER</span><span class="s2">),</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">)</span>
    <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_reader_task</span><span class="s2">)</span>
    <span class="s1">request </span><span class="s2">= </span><span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_get_request</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">request</span>


<span class="s0">async def </span><span class="s1">serve_websocket</span><span class="s2">(</span><span class="s1">handler</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">ssl_context</span><span class="s2">, *,</span>
    <span class="s1">handler_nursery</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">,</span>
    <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">, </span><span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">,</span>
    <span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">, </span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
    <span class="s6">''' 
    Serve a WebSocket over TCP. 
 
    This function supports the Trio nursery start protocol: ``server = await 
    nursery.start(serve_websocket, …)``. It will block until the server 
    is accepting connections and then return a :class:`WebSocketServer` object. 
 
    Note that if ``host`` is ``None`` and ``port`` is zero, then you may get 
    multiple listeners that have *different port numbers!* 
 
    :param handler: An async function that is invoked with a request 
        for each new connection. 
    :param host: The host interface to bind. This can be an address of an 
        interface, a name that resolves to an interface address (e.g. 
        ``localhost``), or a wildcard address like ``0.0.0.0`` for IPv4 or 
        ``::`` for IPv6. If ``None``, then all local interfaces are bound. 
    :type host: str, bytes, or None 
    :param int port: The port to bind to. 
    :param ssl_context: The SSL context to use for encrypted connections, or 
        ``None`` for unencrypted connection. 
    :type ssl_context: ssl.SSLContext or None 
    :param handler_nursery: An optional nursery to spawn handlers and background 
        tasks in. If not specified, a new nursery will be created internally. 
    :param int message_queue_size: The maximum number of messages that will be 
        buffered in the library's internal message queue. 
    :param int max_message_size: The maximum message size as measured by 
        ``len()``. If a message is received that is larger than this size, 
        then the connection is closed with code 1009 (Message Too Big). 
    :param float connect_timeout: The number of seconds to wait for a client 
        to finish connection handshake before timing out. 
    :param float disconnect_timeout: The number of seconds to wait for a client 
        to finish the closing handshake before timing out. 
    :param task_status: Part of Trio nursery start protocol. 
    :returns: This function runs until cancelled. 
    '''</span>
    <span class="s0">if </span><span class="s1">ssl_context </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">open_tcp_listeners </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_tcp_listeners</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">host</span><span class="s2">=</span><span class="s1">host</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">open_tcp_listeners </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_ssl_over_tcp_listeners</span><span class="s2">, </span><span class="s1">port</span><span class="s2">,</span>
            <span class="s1">ssl_context</span><span class="s2">, </span><span class="s1">host</span><span class="s2">=</span><span class="s1">host</span><span class="s2">, </span><span class="s1">https_compatible</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">listeners </span><span class="s2">= </span><span class="s0">await </span><span class="s1">open_tcp_listeners</span><span class="s2">()</span>
    <span class="s1">server </span><span class="s2">= </span><span class="s1">WebSocketServer</span><span class="s2">(</span><span class="s1">handler</span><span class="s2">, </span><span class="s1">listeners</span><span class="s2">,</span>
        <span class="s1">handler_nursery</span><span class="s2">=</span><span class="s1">handler_nursery</span><span class="s2">, </span><span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">message_queue_size</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">max_message_size</span><span class="s2">, </span><span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">connect_timeout</span><span class="s2">,</span>
        <span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">disconnect_timeout</span><span class="s2">)</span>
    <span class="s0">await </span><span class="s1">server</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">task_status</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">HandshakeError</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s6">''' 
    There was an error during connection or disconnection with the websocket 
    server. 
    '''</span>

<span class="s0">class </span><span class="s1">ConnectionTimeout</span><span class="s2">(</span><span class="s1">HandshakeError</span><span class="s2">):</span>
    <span class="s6">'''There was a timeout when connecting to the websocket server.'''</span>

<span class="s0">class </span><span class="s1">DisconnectionTimeout</span><span class="s2">(</span><span class="s1">HandshakeError</span><span class="s2">):</span>
    <span class="s6">'''There was a timeout when disconnecting from the websocket server.'''</span>

<span class="s0">class </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">Exception</span><span class="s2">):</span>
    <span class="s6">''' 
    A WebSocket operation cannot be completed because the connection is closed 
    or in the process of closing. 
    '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        :param reason: 
        :type reason: CloseReason 
        '''</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reason </span><span class="s2">= </span><span class="s1">reason</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Return representation. '''</span>
        <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">&lt;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">reason</span><span class="s0">}</span><span class="s3">&gt;'</span>


<span class="s0">class </span><span class="s1">ConnectionRejected</span><span class="s2">(</span><span class="s1">HandshakeError</span><span class="s2">):</span>
    <span class="s6">''' 
    A WebSocket connection could not be established because the server rejected 
    the connection attempt. 
    '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">status_code</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">body</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        :param reason: 
        :type reason: CloseReason 
        '''</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s5">#: a 3 digit HTTP status code</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">status_code </span><span class="s2">= </span><span class="s1">status_code</span>
        <span class="s5">#: a tuple of 2-tuples containing header key/value pairs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">headers </span><span class="s2">= </span><span class="s1">headers</span>
        <span class="s5">#: an optional ``bytes`` response body</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">body </span><span class="s2">= </span><span class="s1">body</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Return representation. '''</span>
        <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">&lt;status_code=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">status_code</span><span class="s0">}</span><span class="s3">&gt;'</span>


<span class="s0">class </span><span class="s1">CloseReason</span><span class="s2">:</span>
    <span class="s6">''' Contains information about why a WebSocket was closed. '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        :param int code: 
        :param Optional[str] reason: 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_code </span><span class="s2">= </span><span class="s1">code</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s1">wsframeproto</span><span class="s2">.</span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s1">code</span><span class="s2">).</span><span class="s1">name</span>
        <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s4">1000 </span><span class="s2">&lt;= </span><span class="s1">code </span><span class="s2">&lt;= </span><span class="s4">2999</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s3">'RFC_RESERVED'</span>
            <span class="s0">elif </span><span class="s4">3000 </span><span class="s2">&lt;= </span><span class="s1">code </span><span class="s2">&lt;= </span><span class="s4">3999</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s3">'IANA_RESERVED'</span>
            <span class="s0">elif </span><span class="s4">4000 </span><span class="s2">&lt;= </span><span class="s1">code </span><span class="s2">&lt;= </span><span class="s4">4999</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s3">'PRIVATE_RESERVED'</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_name </span><span class="s2">= </span><span class="s3">'INVALID_CODE'</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reason </span><span class="s2">= </span><span class="s1">reason</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">code</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' (Read-only) The numeric close code. '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_code</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' (Read-only) The human-readable close code. '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_name</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">reason</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' (Read-only) An arbitrary reason string. '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reason</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Show close code, name, and reason. '''</span>
        <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s3">' </span><span class="s1">\</span>
               <span class="s3">f'&lt;code=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">code</span><span class="s0">}</span><span class="s3">, name=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s0">}</span><span class="s3">, reason=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">reason</span><span class="s0">}</span><span class="s3">&gt;'</span>


<span class="s0">class </span><span class="s1">Future</span><span class="s2">:</span>
    <span class="s6">''' Represents a value that will be available in the future. '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Constructor. '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_event </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">set_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s6">''' 
        Set a value, which will notify any waiters. 
 
        :param value: 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value_event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">wait_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        Wait for this future to have a value, then return it. 
 
        :returns: The value set by ``set_value()``. 
        '''</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value_event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span>


<span class="s0">class </span><span class="s1">WebSocketRequest</span><span class="s2">:</span>
    <span class="s6">''' 
    Represents a handshake presented by a client to a server. 
 
    The server may modify the handshake or leave it as is. The server should 
    call ``accept()`` to finish the handshake and obtain a connection object. 
    '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">connection</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        :param WebSocketConnection connection: 
        :type event: wsproto.events.Request 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_connection </span><span class="s2">= </span><span class="s1">connection</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_event </span><span class="s2">= </span><span class="s1">event</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">headers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        HTTP headers represented as a list of (name, value) pairs. 
 
        :rtype: list[tuple] 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">extra_headers</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The requested URL path. 
 
        :rtype: str 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">target</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">proposed_subprotocols</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        A tuple of protocols proposed by the client. 
 
        :rtype: tuple[str] 
        '''</span>
        <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">.</span><span class="s1">subprotocols</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">local</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The connection's local endpoint. 
 
        :rtype: Endpoint or str 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection</span><span class="s2">.</span><span class="s1">local</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">remote</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The connection's remote endpoint. 
 
        :rtype: Endpoint or str 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection</span><span class="s2">.</span><span class="s1">remote</span>

    <span class="s0">async def </span><span class="s1">accept</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">subprotocol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">''' 
        Accept the request and return a connection object. 
 
        :param subprotocol: The selected subprotocol for this connection. 
        :type subprotocol: str or None 
        :param extra_headers: A list of 2-tuples containing key/value pairs to 
            send as HTTP headers. 
        :type extra_headers: list[tuple[bytes,bytes]] or None 
        :rtype: WebSocketConnection 
        '''</span>
        <span class="s0">if </span><span class="s1">extra_headers </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">extra_headers </span><span class="s2">= []</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection</span><span class="s2">.</span><span class="s1">_accept</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_event</span><span class="s2">, </span><span class="s1">subprotocol</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection</span>

    <span class="s0">async def </span><span class="s1">reject</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">status_code</span><span class="s2">, *, </span><span class="s1">extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">body</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">''' 
        Reject the handshake. 
 
        :param int status_code: The 3 digit HTTP status code. In order to be 
            RFC-compliant, this should NOT be 101, and would ideally be an 
            appropriate code in the range 300-599. 
        :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples 
            containing key/value pairs to send as HTTP headers. 
        :param body: If provided, this data will be sent in the response 
            body, otherwise no response body will be sent. 
        :type body: bytes or None 
        '''</span>
        <span class="s1">extra_headers </span><span class="s2">= </span><span class="s1">extra_headers </span><span class="s0">or </span><span class="s2">[]</span>
        <span class="s1">body </span><span class="s2">= </span><span class="s1">body </span><span class="s0">or </span><span class="s7">b''</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection</span><span class="s2">.</span><span class="s1">_reject</span><span class="s2">(</span><span class="s1">status_code</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">, </span><span class="s1">body</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_stream_endpoint</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, *, </span><span class="s1">local</span><span class="s2">):</span>
    <span class="s6">''' 
    Construct an endpoint from a stream. 
 
    :param trio.Stream stream: 
    :param bool local: If true, return local endpoint. Otherwise return remote. 
    :returns: An endpoint instance or ``repr()`` for streams that cannot be 
        represented as an endpoint. 
    :rtype: Endpoint or str 
    '''</span>
    <span class="s1">socket</span><span class="s2">, </span><span class="s1">is_ssl </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">SocketStream</span><span class="s2">):</span>
        <span class="s1">socket </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">socket</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">SSLStream</span><span class="s2">):</span>
        <span class="s1">socket </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">transport_stream</span><span class="s2">.</span><span class="s1">socket</span>
        <span class="s1">is_ssl </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s0">if </span><span class="s1">socket</span><span class="s2">:</span>
        <span class="s1">addr</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, *</span><span class="s1">_ </span><span class="s2">= </span><span class="s1">socket</span><span class="s2">.</span><span class="s1">getsockname</span><span class="s2">() </span><span class="s0">if </span><span class="s1">local </span><span class="s0">else </span><span class="s1">socket</span><span class="s2">.</span><span class="s1">getpeername</span><span class="s2">()</span>
        <span class="s1">endpoint </span><span class="s2">= </span><span class="s1">Endpoint</span><span class="s2">(</span><span class="s1">addr</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">is_ssl</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">endpoint </span><span class="s2">= </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">endpoint</span>


<span class="s0">class </span><span class="s1">WebSocketConnection</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">AsyncResource</span><span class="s2">):</span>
    <span class="s6">''' A WebSocket connection. '''</span>

    <span class="s1">CONNECTION_ID </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">count</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">ws_connection</span><span class="s2">, *, </span><span class="s1">host</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">path</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">client_subprotocols</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">client_extra_headers</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        Generally speaking, users are discouraged from directly instantiating a 
        ``WebSocketConnection`` and should instead use one of the convenience 
        functions in this module, e.g. ``open_websocket()`` or 
        ``serve_websocket()``. This class has some tricky internal logic and 
        timing that depends on whether it is an instance of a client connection 
        or a server connection. The convenience functions handle this complexity 
        for you. 
 
        :param SocketStream stream: 
        :param ws_connection wsproto.WSConnection: 
        :param str host: The hostname to send in the HTTP request headers. Only 
            used for client connections. 
        :param str path: The URL path for this connection. 
        :param list client_subprotocols: A list of desired subprotocols. Only 
            used for client connections. 
        :param list[tuple[bytes,bytes]] client_extra_headers: Extra headers to 
            send with the connection request. Only used for client connections. 
        :param int message_queue_size: The maximum number of messages that will be 
            buffered in the library's internal message queue. 
        :param int max_message_size: The maximum message size as measured by 
            ``len()``. If a message is received that is larger than this size, 
            then the connection is closed with code 1009 (Message Too Big). 
        '''</span>
        <span class="s5"># NOTE: The implementation uses _close_reason for more than an advisory</span>
        <span class="s5">#   purpose.  It's critical internal state, indicating when the</span>
        <span class="s5">#   connection is closed or closing.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">CloseReason</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_id </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">CONNECTION_ID</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_stream </span><span class="s2">= </span><span class="s1">stream</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_stream_lock </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">StrictFIFOLock</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto </span><span class="s2">= </span><span class="s1">ws_connection</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_size </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_parts</span><span class="s2">: </span><span class="s1">List</span><span class="s2">[</span><span class="s1">Union</span><span class="s2">[</span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">str</span><span class="s2">]] = []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_max_message_size </span><span class="s2">= </span><span class="s1">max_message_size</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">ws_connection</span><span class="s2">.</span><span class="s1">client</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_request</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">Request</span><span class="s2">] = </span><span class="s1">Request</span><span class="s2">(</span><span class="s1">host</span><span class="s2">=</span><span class="s1">host</span><span class="s2">, </span><span class="s1">target</span><span class="s2">=</span><span class="s1">path</span><span class="s2">,</span>
                <span class="s1">subprotocols</span><span class="s2">=</span><span class="s1">client_subprotocols</span><span class="s2">,</span>
                <span class="s1">extra_headers</span><span class="s2">=</span><span class="s1">client_extra_headers </span><span class="s0">or </span><span class="s2">[])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_request </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_path </span><span class="s2">= </span><span class="s1">path</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_subprotocol</span><span class="s2">: </span><span class="s1">Optional</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] = </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_handshake_headers </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_status </span><span class="s2">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_headers </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_body </span><span class="s2">= </span><span class="s7">b''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_send_channel</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_recv_channel </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_memory_channel</span><span class="s2">(</span>
            <span class="s1">message_queue_size</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pings </span><span class="s2">= </span><span class="s1">OrderedDict</span><span class="s2">()</span>
        <span class="s5"># Set when the server has received a connection request event. This</span>
        <span class="s5"># future is never set on client connections.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_connection_proposal </span><span class="s2">= </span><span class="s1">Future</span><span class="s2">()</span>
        <span class="s5"># Set once the WebSocket open handshake takes place, i.e.</span>
        <span class="s5"># ConnectionRequested for server or ConnectedEstablished for client.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_open_handshake </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
        <span class="s5"># Set once a WebSocket closed handshake takes place, i.e after a close</span>
        <span class="s5"># frame has been sent and a close frame has been received.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
        <span class="s5"># Set upon receiving CloseConnection from peer.</span>
        <span class="s5"># Used to test close race conditions between client and server.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_for_testing_peer_closed_connection </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">closed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        (Read-only) The reason why the connection was or is being closed, 
        else ``None``. 
 
        :rtype: Optional[CloseReason] 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_client</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' (Read-only) Is this a client instance? '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">client</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_server</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' (Read-only) Is this a server instance? '''</span>
        <span class="s0">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">client</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">local</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The local endpoint of the connection. 
 
        :rtype: Endpoint or str 
        '''</span>
        <span class="s0">return </span><span class="s1">_get_stream_endpoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream</span><span class="s2">, </span><span class="s1">local</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">remote</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The remote endpoint of the connection. 
 
        :rtype: Endpoint or str 
        '''</span>
        <span class="s0">return </span><span class="s1">_get_stream_endpoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream</span><span class="s2">, </span><span class="s1">local</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The requested URL path. For clients, this is set when the connection is 
        instantiated. For servers, it is set after the handshake completes. 
 
        :rtype: str 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_path</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">subprotocol</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        (Read-only) The negotiated subprotocol, or ``None`` if there is no 
        subprotocol. 
 
        This is only valid after the opening handshake is complete. 
 
        :rtype: str or None 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_subprotocol</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">handshake_headers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        The HTTP headers that were sent by the remote during the handshake, 
        stored as 2-tuples containing key/value pairs. Header keys are always 
        lower case. 
 
        :rtype: tuple[tuple[str,str]] 
        '''</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handshake_headers</span>

    <span class="s0">async def </span><span class="s1">aclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):  </span><span class="s5"># pylint: disable=arguments-differ</span>
        <span class="s6">''' 
        Close the WebSocket connection. 
 
        This sends a closing frame and suspends until the connection is closed. 
        After calling this method, any further I/O on this WebSocket (such as 
        ``get_message()`` or ``send_message()``) will raise 
        ``ConnectionClosed``. 
 
        This method is idempotent: it may be called multiple times on the same 
        connection without any errors. 
 
        :param int code: A 4-digit code number indicating the type of closure. 
        :param str reason: An optional string describing the closure. 
        '''</span>
        <span class="s0">with </span><span class="s1">_preserve_current_exception</span><span class="s2">():</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_aclose</span><span class="s2">(</span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">_aclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">:</span>
            <span class="s5"># Per AsyncResource interface, calling aclose() on a closed resource</span>
            <span class="s5"># should succeed.</span>
            <span class="s0">return</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s2">== </span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">OPEN</span><span class="s2">:</span>
                <span class="s5"># Our side is initiating the close, so send a close connection</span>
                <span class="s5"># event to peer, while setting the local close reason to normal.</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s2">= </span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">CloseConnection</span><span class="s2">(</span><span class="s1">code</span><span class="s2">=</span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s1">reason</span><span class="s2">))</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s0">in </span><span class="s2">(</span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">CONNECTING</span><span class="s2">,</span>
                    <span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">REJECTING</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
            <span class="s5"># TODO: shouldn't the receive channel be closed earlier, so that</span>
            <span class="s5">#  get_message() during send of the CloseConneciton event fails?</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_recv_channel</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">ConnectionClosed</span><span class="s2">:</span>
            <span class="s5"># If _send() raised ConnectionClosed, then we can bail out.</span>
            <span class="s0">pass</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s5"># If cancelled during WebSocket close, make sure that the underlying</span>
            <span class="s5"># stream is closed.</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_stream</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">get_message</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        Receive the next WebSocket message. 
 
        If no message is available immediately, then this function blocks until 
        a message is ready. 
 
        If the remote endpoint closes the connection, then the caller can still 
        get messages sent prior to closing. Once all pending messages have been 
        retrieved, additional calls to this method will raise 
        ``ConnectionClosed``. If the local endpoint closes the connection, then 
        pending messages are discarded and calls to this method will immediately 
        raise ``ConnectionClosed``. 
 
        :rtype: str or bytes 
        :raises ConnectionClosed: if the connection is closed. 
        '''</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_recv_channel</span><span class="s2">.</span><span class="s1">receive</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">ClosedResourceError</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">EndOfChannel</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">) </span><span class="s0">from None</span>
        <span class="s0">return </span><span class="s1">message</span>

    <span class="s0">async def </span><span class="s1">ping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">payload</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">''' 
        Send WebSocket ping to remote endpoint and wait for a correspoding pong. 
 
        Each in-flight ping must include a unique payload. This function sends 
        the ping and then waits for a corresponding pong from the remote 
        endpoint. 
 
        *Note: If the remote endpoint recieves multiple pings, it is allowed to 
        send a single pong. Therefore, the order of calls to ``ping()`` is 
        tracked, and a pong will wake up its corresponding ping as well as all 
        previous in-flight pings.* 
 
        :param payload: The payload to send. If ``None`` then a random 32-bit 
            payload is created. 
        :type payload: bytes or None 
        :raises ConnectionClosed: if connection is closed. 
        :raises ValueError: if ``payload`` is identical to another in-flight 
            ping. 
        '''</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">payload </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pings</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Payload value </span><span class="s0">{</span><span class="s1">payload</span><span class="s0">} </span><span class="s3">is already in flight.'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">payload </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">payload </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">'!I'</span><span class="s2">, </span><span class="s1">random</span><span class="s2">.</span><span class="s1">getrandbits</span><span class="s2">(</span><span class="s4">32</span><span class="s2">))</span>
        <span class="s1">event </span><span class="s2">= </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">Event</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pings</span><span class="s2">[</span><span class="s1">payload</span><span class="s2">] = </span><span class="s1">event</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">Ping</span><span class="s2">(</span><span class="s1">payload</span><span class="s2">=</span><span class="s1">payload</span><span class="s2">))</span>
        <span class="s0">await </span><span class="s1">event</span><span class="s2">.</span><span class="s1">wait</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">pong</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">payload</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">''' 
        Send an unsolicted pong. 
 
        :param payload: The pong's payload. If ``None``, then no payload is 
            sent. 
        :type payload: bytes or None 
        :raises ConnectionClosed: if connection is closed 
        '''</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">Pong</span><span class="s2">(</span><span class="s1">payload</span><span class="s2">=</span><span class="s1">payload</span><span class="s2">))</span>

    <span class="s0">async def </span><span class="s1">send_message</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">message</span><span class="s2">):</span>
        <span class="s6">''' 
        Send a WebSocket message. 
 
        :param message: The message to send. 
        :type message: str or bytes 
        :raises ConnectionClosed: if connection is closed, or being closed 
        '''</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">event </span><span class="s2">= </span><span class="s1">TextMessage</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">):</span>
            <span class="s1">event </span><span class="s2">= </span><span class="s1">BytesMessage</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'message must be str or bytes'</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">event</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Connection ID and type. '''</span>
        <span class="s1">type_ </span><span class="s2">= </span><span class="s3">'client' </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_client </span><span class="s0">else </span><span class="s3">'server'</span>
        <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">type_</span><span class="s0">}</span><span class="s3">-</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_id</span><span class="s0">}</span><span class="s3">'</span>

    <span class="s0">async def </span><span class="s1">_accept</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">request</span><span class="s2">, </span><span class="s1">subprotocol</span><span class="s2">, </span><span class="s1">extra_headers</span><span class="s2">):</span>
        <span class="s6">''' 
        Accept the handshake. 
 
        This method is only applicable to server-side connections. 
 
        :param wsproto.events.Request request: 
        :param subprotocol: 
        :type subprotocol: str or None 
        :param list[tuple[bytes,bytes]] extra_headers: A list of 2-tuples 
            containing key/value pairs to send as HTTP headers. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_subprotocol </span><span class="s2">= </span><span class="s1">subprotocol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_path </span><span class="s2">= </span><span class="s1">request</span><span class="s2">.</span><span class="s1">target</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">AcceptConnection</span><span class="s2">(</span><span class="s1">subprotocol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_subprotocol</span><span class="s2">,</span>
            <span class="s1">extra_headers</span><span class="s2">=</span><span class="s1">extra_headers</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_open_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_reject</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">status_code</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">body</span><span class="s2">):</span>
        <span class="s6">''' 
        Reject the handshake. 
 
        :param int status_code: The 3 digit HTTP status code. In order to be 
            RFC-compliant, this must not be 101, and should be an appropriate 
            code in the range 300-599. 
        :param list[tuple[bytes,bytes]] headers: A list of 2-tuples containing 
            key/value pairs to send as HTTP headers. 
        :param bytes body: An optional response body. 
        '''</span>
        <span class="s0">if </span><span class="s1">body</span><span class="s2">:</span>
            <span class="s1">headers</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s3">'Content-length'</span><span class="s2">, </span><span class="s1">str</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">body</span><span class="s2">)).</span><span class="s1">encode</span><span class="s2">(</span><span class="s3">'ascii'</span><span class="s2">)))</span>
        <span class="s1">reject_conn </span><span class="s2">= </span><span class="s1">RejectConnection</span><span class="s2">(</span><span class="s1">status_code</span><span class="s2">=</span><span class="s1">status_code</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">=</span><span class="s1">headers</span><span class="s2">,</span>
            <span class="s1">has_body</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">(</span><span class="s1">body</span><span class="s2">))</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">reject_conn</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">body</span><span class="s2">:</span>
            <span class="s1">reject_body </span><span class="s2">= </span><span class="s1">RejectData</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=</span><span class="s1">body</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">reject_body</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s2">= </span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s4">1006</span><span class="s2">, </span><span class="s3">'Rejected WebSocket handshake'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_abort_web_socket</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        If a stream is closed outside of this class, e.g. due to network 
        conditions or because some other code closed our stream object, then we 
        cannot perform the close handshake. We just need to clean up internal 
        state. 
        '''</span>
        <span class="s1">close_reason </span><span class="s2">= </span><span class="s1">wsframeproto</span><span class="s2">.</span><span class="s1">CloseReason</span><span class="s2">.</span><span class="s1">ABNORMAL_CLOSURE</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s2">== </span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">OPEN</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s1">CloseConnection</span><span class="s2">(</span><span class="s1">code</span><span class="s2">=</span><span class="s1">close_reason</span><span class="s2">.</span><span class="s1">value</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_web_socket</span><span class="s2">(</span><span class="s1">close_reason</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s5"># We didn't really handshake, but we want any task waiting on this event</span>
        <span class="s5"># (e.g. self.aclose()) to resume.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_close_stream</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Close the TCP connection. '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">_preserve_current_exception</span><span class="s2">():</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
        <span class="s0">except </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span><span class="s2">:</span>
            <span class="s5"># This means the TCP connection is already dead.</span>
            <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">_close_web_socket</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s6">''' 
        Mark the WebSocket as closed. Close the message channel so that if any 
        tasks are suspended in get_message(), they will wake up with a 
        ConnectionClosed exception. 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s2">= </span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s1">code</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">)</span>
        <span class="s1">exc </span><span class="s2">= </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">)</span>
        <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s websocket closed %r'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">exc</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send_channel</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_get_request</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        Return a proposal for a WebSocket handshake. 
 
        This method can only be called on server connections and it may only be 
        called one time. 
 
        :rtype: WebSocketRequest 
        '''</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_server</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">'This method is only valid for server connections.'</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection_proposal </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">'No proposal available. Did you call this method'</span>
                <span class="s3">' multiple times or at the wrong time?'</span><span class="s2">)</span>
        <span class="s1">proposal </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connection_proposal</span><span class="s2">.</span><span class="s1">wait_value</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_connection_proposal </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">proposal</span>

    <span class="s0">async def </span><span class="s1">_handle_request_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a connection request. 
 
        This method is async even though it never awaits, because the event 
        dispatch requires an async function. 
 
        :param event: 
        '''</span>
        <span class="s1">proposal </span><span class="s2">= </span><span class="s1">WebSocketRequest</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_connection_proposal</span><span class="s2">.</span><span class="s1">set_value</span><span class="s2">(</span><span class="s1">proposal</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">_handle_accept_connection_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle an AcceptConnection event. 
 
        :param wsproto.eventsAcceptConnection event: 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_subprotocol </span><span class="s2">= </span><span class="s1">event</span><span class="s2">.</span><span class="s1">subprotocol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_handshake_headers </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">extra_headers</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_open_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_handle_reject_connection_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a RejectConnection event. 
 
        :param event: 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_status </span><span class="s2">= </span><span class="s1">event</span><span class="s2">.</span><span class="s1">status_code</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_headers </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">headers</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">event</span><span class="s2">.</span><span class="s1">has_body</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionRejected</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_status</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_headers</span><span class="s2">,</span>
                <span class="s1">body</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">_handle_reject_data_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a RejectData event. 
 
        :param event: 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_body </span><span class="s2">+= </span><span class="s1">event</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s0">if </span><span class="s1">event</span><span class="s2">.</span><span class="s1">body_finished</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ConnectionRejected</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_status</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_headers</span><span class="s2">,</span>
                <span class="s1">body</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reject_body</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">_handle_close_connection_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a close event. 
 
        :param wsproto.events.CloseConnection event: 
        '''</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s2">== </span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">REMOTE_CLOSING</span><span class="s2">:</span>
            <span class="s5"># Set _close_reason in advance, so that send_message() will raise</span>
            <span class="s5"># ConnectionClosed during the close handshake.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s2">= </span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">code</span><span class="s2">, </span><span class="s1">event</span><span class="s2">.</span><span class="s1">reason </span><span class="s0">or None</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_for_testing_peer_closed_connection</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">response</span><span class="s2">())</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_web_socket</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">code</span><span class="s2">, </span><span class="s1">event</span><span class="s2">.</span><span class="s1">reason </span><span class="s0">or None</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_handshake</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
        <span class="s5"># RFC: &quot;When a server is instructed to Close the WebSocket Connection</span>
        <span class="s5">#   it SHOULD initiate a TCP Close immediately, and when a client is</span>
        <span class="s5">#   instructed to do the same, it SHOULD wait for a TCP Close from the</span>
        <span class="s5">#   server.&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_server</span><span class="s2">:</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_stream</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_handle_message_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a message event. 
 
        :param event: 
        :type event: wsproto.events.BytesMessage or wsproto.events.TextMessage 
        '''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_size </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_message_size </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_message_size</span><span class="s2">:</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s3">f'Exceeded maximum message size: </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_message_size</span><span class="s0">} </span><span class="s3">bytes'</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_size </span><span class="s2">= </span><span class="s4">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_parts </span><span class="s2">= []</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason </span><span class="s2">= </span><span class="s1">CloseReason</span><span class="s2">(</span><span class="s4">1009</span><span class="s2">, </span><span class="s1">err</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">CloseConnection</span><span class="s2">(</span><span class="s1">code</span><span class="s2">=</span><span class="s4">1009</span><span class="s2">, </span><span class="s1">reason</span><span class="s2">=</span><span class="s1">err</span><span class="s2">))</span>
            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_recv_channel</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">elif </span><span class="s1">event</span><span class="s2">.</span><span class="s1">message_finished</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s7">b'' </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">event</span><span class="s2">, </span><span class="s1">BytesMessage</span><span class="s2">) </span><span class="s0">else </span><span class="s3">''</span><span class="s2">) </span><span class="s1">\</span>
                <span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_message_parts</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_size </span><span class="s2">= </span><span class="s4">0</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_parts </span><span class="s2">= []</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send_channel</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">ClosedResourceError</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span><span class="s2">):</span>
                <span class="s5"># The receive channel is closed, probably because somebody</span>
                <span class="s5"># called ``aclose()``. We don't want to abort the reader task,</span>
                <span class="s5"># and there's no useful cleanup that we can do here.</span>
                <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">_handle_ping_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a PingReceived event. 
 
        Wsproto queues a pong frame automatically, so this handler just needs to 
        send it. 
 
        :param wsproto.events.Ping event: 
        '''</span>
        <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s ping %r'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">.</span><span class="s1">payload</span><span class="s2">)</span>
        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">response</span><span class="s2">())</span>

    <span class="s0">async def </span><span class="s1">_handle_pong_event</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle a PongReceived event. 
 
        When a pong is received, check if we have any ping requests waiting for 
        this pong response. If the remote endpoint skipped any earlier pings, 
        then we wake up those skipped pings, too. 
 
        This function is async even though it never awaits, because the other 
        event handlers are async, too, and event dispatch would be more 
        complicated if some handlers were sync. 
 
        :param event: 
        '''</span>
        <span class="s1">payload </span><span class="s2">= </span><span class="s1">bytes</span><span class="s2">(</span><span class="s1">event</span><span class="s2">.</span><span class="s1">payload</span><span class="s2">)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pings</span><span class="s2">[</span><span class="s1">payload</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s5"># We received a pong that doesn't match any in-flight pongs. Nothing</span>
            <span class="s5"># we can do with it, so ignore it.</span>
            <span class="s0">return</span>
        <span class="s0">while </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pings</span><span class="s2">:</span>
            <span class="s1">key</span><span class="s2">, </span><span class="s1">event </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_pings</span><span class="s2">.</span><span class="s1">popitem</span><span class="s2">(</span><span class="s4">0</span><span class="s2">)</span>
            <span class="s1">skipped </span><span class="s2">= </span><span class="s3">' [skipped] ' </span><span class="s0">if </span><span class="s1">payload </span><span class="s2">!= </span><span class="s1">key </span><span class="s0">else </span><span class="s3">' '</span>
            <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s pong%s%r'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">skipped</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>
            <span class="s1">event</span><span class="s2">.</span><span class="s1">set</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">payload </span><span class="s2">== </span><span class="s1">key</span><span class="s2">:</span>
                <span class="s0">break</span>

    <span class="s0">async def </span><span class="s1">_reader_task</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' A background task that reads network data and generates events. '''</span>
        <span class="s1">handlers </span><span class="s2">= {</span>
            <span class="s1">AcceptConnection</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_accept_connection_event</span><span class="s2">,</span>
            <span class="s1">BytesMessage</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_message_event</span><span class="s2">,</span>
            <span class="s1">CloseConnection</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_close_connection_event</span><span class="s2">,</span>
            <span class="s1">Ping</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_ping_event</span><span class="s2">,</span>
            <span class="s1">Pong</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_pong_event</span><span class="s2">,</span>
            <span class="s1">RejectConnection</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_reject_connection_event</span><span class="s2">,</span>
            <span class="s1">RejectData</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_reject_data_event</span><span class="s2">,</span>
            <span class="s1">Request</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_request_event</span><span class="s2">,</span>
            <span class="s1">TextMessage</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_message_event</span><span class="s2">,</span>
        <span class="s2">}</span>

        <span class="s5"># Clients need to initiate the opening handshake.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_request</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_initial_request</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">ConnectionClosed</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">async with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send_channel</span><span class="s2">:</span>
            <span class="s0">while </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running</span><span class="s2">:</span>
                <span class="s5"># Process events.</span>
                <span class="s0">for </span><span class="s1">event </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">events</span><span class="s2">():</span>
                    <span class="s1">event_type </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">event</span><span class="s2">)</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">handler </span><span class="s2">= </span><span class="s1">handlers</span><span class="s2">[</span><span class="s1">event_type</span><span class="s2">]</span>
                        <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s received event: %s'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">,</span>
                            <span class="s1">event_type</span><span class="s2">)</span>
                        <span class="s0">await </span><span class="s1">handler</span><span class="s2">(</span><span class="s1">event</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                        <span class="s1">logger</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">'%s received unknown event type: &quot;%s&quot;'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">,</span>
                            <span class="s1">event_type</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">ConnectionClosed</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_reader_running </span><span class="s2">= </span><span class="s0">False</span>
                        <span class="s0">break</span>

                <span class="s5"># Get network data.</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s1">data </span><span class="s2">= </span><span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream</span><span class="s2">.</span><span class="s1">receive_some</span><span class="s2">(</span><span class="s1">RECEIVE_BYTES</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">ClosedResourceError</span><span class="s2">):</span>
                    <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_abort_web_socket</span><span class="s2">()</span>
                    <span class="s0">break</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) == </span><span class="s4">0</span><span class="s2">:</span>
                    <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s received zero bytes (connection closed)'</span><span class="s2">,</span>
                        <span class="s1">self</span><span class="s2">)</span>
                    <span class="s5"># If TCP closed before WebSocket, then record it as an abnormal</span>
                    <span class="s5"># closure.</span>
                    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s2">!= </span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">CLOSED</span><span class="s2">:</span>
                        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_abort_web_socket</span><span class="s2">()</span>
                    <span class="s0">break</span>
                <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s received %d bytes'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">))</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">state </span><span class="s2">!= </span><span class="s1">ConnectionState</span><span class="s2">.</span><span class="s1">CLOSED</span><span class="s2">:</span>
                    <span class="s0">try</span><span class="s2">:</span>
                        <span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">receive_data</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
                    <span class="s0">except </span><span class="s1">wsproto</span><span class="s2">.</span><span class="s1">utilities</span><span class="s2">.</span><span class="s1">RemoteProtocolError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
                        <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s remote protocol error: %s'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">err</span><span class="s2">)</span>
                        <span class="s0">if </span><span class="s1">err</span><span class="s2">.</span><span class="s1">event_hint</span><span class="s2">:</span>
                            <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_send</span><span class="s2">(</span><span class="s1">err</span><span class="s2">.</span><span class="s1">event_hint</span><span class="s2">)</span>
                        <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_stream</span><span class="s2">()</span>

        <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s reader task finished'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">async def </span><span class="s1">_send</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">):</span>
        <span class="s6">''' 
        Send an event to the remote WebSocket. 
 
        The reader task and one or more writers might try to send messages at 
        the same time, so this method uses an internal lock to serialize 
        requests to send data. 
 
        :param wsproto.events.Event event: 
        '''</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wsproto</span><span class="s2">.</span><span class="s1">send</span><span class="s2">(</span><span class="s1">event</span><span class="s2">)</span>
        <span class="s0">async with </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream_lock</span><span class="s2">:</span>
            <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'%s sending %d bytes'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">))</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_stream</span><span class="s2">.</span><span class="s1">send_all</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">BrokenResourceError</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">ClosedResourceError</span><span class="s2">):</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_abort_web_socket</span><span class="s2">()</span>
                <span class="s0">raise </span><span class="s1">ConnectionClosed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_close_reason</span><span class="s2">) </span><span class="s0">from None</span>


<span class="s0">class </span><span class="s1">Endpoint</span><span class="s2">:</span>
    <span class="s6">''' Represents a connection endpoint. '''</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">address</span><span class="s2">, </span><span class="s1">port</span><span class="s2">, </span><span class="s1">is_ssl</span><span class="s2">):</span>
        <span class="s5">#: IP address :class:`ipaddress.ip_address`</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">address </span><span class="s2">= </span><span class="s1">ip_address</span><span class="s2">(</span><span class="s1">address</span><span class="s2">)</span>
        <span class="s5">#: TCP port</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">port </span><span class="s2">= </span><span class="s1">port</span>
        <span class="s5">#: Whether SSL is in use</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">is_ssl </span><span class="s2">= </span><span class="s1">is_ssl</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">url</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Return a URL representation of a TCP endpoint, e.g. 
        ``ws://127.0.0.1:80``. '''</span>
        <span class="s1">scheme </span><span class="s2">= </span><span class="s3">'wss' </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_ssl </span><span class="s0">else </span><span class="s3">'ws'</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">port </span><span class="s2">== </span><span class="s4">80 </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_ssl</span><span class="s2">) </span><span class="s0">or </span><span class="s1">\</span>
           <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">port </span><span class="s2">== </span><span class="s4">443 </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_ssl</span><span class="s2">):</span>
            <span class="s1">port_str </span><span class="s2">= </span><span class="s3">''</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">port_str </span><span class="s2">= </span><span class="s3">':' </span><span class="s2">+ </span><span class="s1">str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">port</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">address</span><span class="s2">.</span><span class="s1">version </span><span class="s2">== </span><span class="s4">4</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">scheme</span><span class="s0">}</span><span class="s3">://</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">address</span><span class="s0">}{</span><span class="s1">port_str</span><span class="s0">}</span><span class="s3">'</span>
        <span class="s0">return </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">scheme</span><span class="s0">}</span><span class="s3">://[</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">address</span><span class="s0">}</span><span class="s3">]</span><span class="s0">{</span><span class="s1">port_str</span><span class="s0">}</span><span class="s3">'</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' Return endpoint info as string. '''</span>
        <span class="s0">return </span><span class="s3">f'Endpoint(address=&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">address</span><span class="s0">}</span><span class="s3">&quot;, port=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">port</span><span class="s0">}</span><span class="s3">, is_ssl=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_ssl</span><span class="s0">}</span><span class="s3">)'</span>


<span class="s0">class </span><span class="s1">WebSocketServer</span><span class="s2">:</span>
    <span class="s6">''' 
    WebSocket server. 
 
    The server class handles incoming connections on one or more ``Listener`` 
    objects. For each incoming connection, it creates a ``WebSocketConnection`` 
    instance and starts some background tasks, 
    '''</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">listeners</span><span class="s2">, *, </span><span class="s1">handler_nursery</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">MESSAGE_QUEUE_SIZE</span><span class="s2">,</span>
        <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">MAX_MESSAGE_SIZE</span><span class="s2">, </span><span class="s1">connect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">,</span>
        <span class="s1">disconnect_timeout</span><span class="s2">=</span><span class="s1">CONN_TIMEOUT</span><span class="s2">):</span>
        <span class="s6">''' 
        Constructor. 
 
        Note that if ``host`` is ``None`` and ``port`` is zero, then you may get 
        multiple listeners that have _different port numbers!_ See the 
        ``listeners`` property. 
 
        :param handler: the async function called with a :class:`WebSocketRequest` 
            on each new connection.  The call will be made 
            once the HTTP handshake completes, which notably implies that the 
            connection's `path` property will be valid. 
        :param listeners: The WebSocket will be served on each of the listeners. 
        :param handler_nursery: An optional nursery to spawn connection tasks 
            inside of. If ``None``, then a new nursery will be created 
            internally. 
        :param float connect_timeout: The number of seconds to wait for a client 
            to finish connection handshake before timing out. 
        :param float disconnect_timeout: The number of seconds to wait for a client 
            to finish the closing handshake before timing out. 
        '''</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">listeners</span><span class="s2">) == </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Listeners must contain at least one item.'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_handler </span><span class="s2">= </span><span class="s1">handler</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_handler_nursery </span><span class="s2">= </span><span class="s1">handler_nursery</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_listeners </span><span class="s2">= </span><span class="s1">listeners</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_message_queue_size </span><span class="s2">= </span><span class="s1">message_queue_size</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_max_message_size </span><span class="s2">= </span><span class="s1">max_message_size</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_connect_timeout </span><span class="s2">= </span><span class="s1">connect_timeout</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_disconnect_timeout </span><span class="s2">= </span><span class="s1">disconnect_timeout</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">port</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Returns the requested or kernel-assigned port number. 
 
        In the case of kernel-assigned port (requested with port=0 in the 
        constructor), the assigned port will be reflected after calling 
        starting the `listen` task.  (Technically, once listen reaches the 
        &quot;started&quot; state.) 
 
        This property only works if you have a single listener, and that 
        listener must be socket-based. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_listeners</span><span class="s2">) &gt; </span><span class="s4">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">'Cannot get port because this server has'</span>
                <span class="s3">' more than 1 listeners.'</span><span class="s2">)</span>
        <span class="s1">listener </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">listeners</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">listener</span><span class="s2">.</span><span class="s1">port</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s3">f'This socket does not have a port: </span><span class="s0">{</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">listener</span><span class="s2">)</span><span class="s0">}</span><span class="s3">'</span><span class="s2">) </span><span class="s0">from None</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">listeners</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">''' 
        Return a list of listener metadata. Each TCP listener is represented as 
        an ``Endpoint`` instance. Other listener types are represented by their 
        ``repr()``. 
 
        :returns: Listeners 
        :rtype list[Endpoint or str]: 
        '''</span>
        <span class="s1">listeners </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">listener </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_listeners</span><span class="s2">:</span>
            <span class="s1">socket</span><span class="s2">, </span><span class="s1">is_ssl </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">listener</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">SocketListener</span><span class="s2">):</span>
                <span class="s1">socket </span><span class="s2">= </span><span class="s1">listener</span><span class="s2">.</span><span class="s1">socket</span>
            <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">listener</span><span class="s2">, </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">SSLListener</span><span class="s2">):</span>
                <span class="s1">socket </span><span class="s2">= </span><span class="s1">listener</span><span class="s2">.</span><span class="s1">transport_listener</span><span class="s2">.</span><span class="s1">socket</span>
                <span class="s1">is_ssl </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">if </span><span class="s1">socket</span><span class="s2">:</span>
                <span class="s1">sockname </span><span class="s2">= </span><span class="s1">socket</span><span class="s2">.</span><span class="s1">getsockname</span><span class="s2">()</span>
                <span class="s1">listeners</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">Endpoint</span><span class="s2">(</span><span class="s1">sockname</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">sockname</span><span class="s2">[</span><span class="s4">1</span><span class="s2">], </span><span class="s1">is_ssl</span><span class="s2">))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">listeners</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">listener</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">listeners</span>

    <span class="s0">async def </span><span class="s1">run</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">task_status</span><span class="s2">=</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">TASK_STATUS_IGNORED</span><span class="s2">):</span>
        <span class="s6">''' 
        Start serving incoming connections requests. 
 
        This method supports the Trio nursery start protocol: ``server = await 
        nursery.start(server.run, …)``. It will block until the server is 
        accepting connections and then return a :class:`WebSocketServer` object. 
 
        :param task_status: Part of the Trio nursery start protocol. 
        :returns: This method never returns unless cancelled. 
        '''</span>
        <span class="s0">async with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">serve_listeners </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">trio</span><span class="s2">.</span><span class="s1">serve_listeners</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_handle_connection</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_listeners</span><span class="s2">,</span>
                <span class="s1">handler_nursery</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handler_nursery</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">nursery</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">serve_listeners</span><span class="s2">)</span>
            <span class="s1">logger</span><span class="s2">.</span><span class="s1">debug</span><span class="s2">(</span><span class="s3">'Listening on %s'</span><span class="s2">,</span>
                <span class="s3">','</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s1">str</span><span class="s2">(</span><span class="s1">l</span><span class="s2">) </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">listeners</span><span class="s2">]))</span>
            <span class="s1">task_status</span><span class="s2">.</span><span class="s1">started</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
            <span class="s0">await </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">sleep_forever</span><span class="s2">()</span>

    <span class="s0">async def </span><span class="s1">_handle_connection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">):</span>
        <span class="s6">''' 
        Handle an incoming connection by spawning a connection background task 
        and a handler task inside a new nursery. 
 
        :param stream: 
        :type stream: trio.abc.Stream 
        '''</span>
        <span class="s0">async with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">open_nursery</span><span class="s2">() </span><span class="s0">as </span><span class="s1">nursery</span><span class="s2">:</span>
            <span class="s1">connection </span><span class="s2">= </span><span class="s1">WebSocketConnection</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">,</span>
                <span class="s1">WSConnection</span><span class="s2">(</span><span class="s1">ConnectionType</span><span class="s2">.</span><span class="s1">SERVER</span><span class="s2">),</span>
                <span class="s1">message_queue_size</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_message_queue_size</span><span class="s2">,</span>
                <span class="s1">max_message_size</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_max_message_size</span><span class="s2">)</span>
            <span class="s1">nursery</span><span class="s2">.</span><span class="s1">start_soon</span><span class="s2">(</span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_reader_task</span><span class="s2">)</span>
            <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">move_on_after</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_connect_timeout</span><span class="s2">) </span><span class="s0">as </span><span class="s1">connect_scope</span><span class="s2">:</span>
                <span class="s1">request </span><span class="s2">= </span><span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">_get_request</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">connect_scope</span><span class="s2">.</span><span class="s1">cancelled_caught</span><span class="s2">:</span>
                <span class="s1">nursery</span><span class="s2">.</span><span class="s1">cancel_scope</span><span class="s2">.</span><span class="s1">cancel</span><span class="s2">()</span>
                <span class="s0">await </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
                <span class="s0">return</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">await </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_handler</span><span class="s2">(</span><span class="s1">request</span><span class="s2">)</span>
            <span class="s0">finally</span><span class="s2">:</span>
                <span class="s0">with </span><span class="s1">trio</span><span class="s2">.</span><span class="s1">move_on_after</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_disconnect_timeout</span><span class="s2">):</span>
                    <span class="s5"># aclose() will shut down the reader task even if it's</span>
                    <span class="s5"># cancelled:</span>
                    <span class="s0">await </span><span class="s1">connection</span><span class="s2">.</span><span class="s1">aclose</span><span class="s2">()</span>
</pre>
</body>
</html>