<html>
<head>
<title>recipes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
recipes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Imported from the recipes section of the itertools documentation. 
 
All functions taken from the recipes section of the itertools library docs 
[1]_. 
Some backward-compatible usability improvements have been made. 
 
.. [1] http://docs.python.org/library/itertools.html#recipes 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">chain</span><span class="s3">,</span>
    <span class="s1">combinations</span><span class="s3">,</span>
    <span class="s1">count</span><span class="s3">,</span>
    <span class="s1">cycle</span><span class="s3">,</span>
    <span class="s1">groupby</span><span class="s3">,</span>
    <span class="s1">islice</span><span class="s3">,</span>
    <span class="s1">repeat</span><span class="s3">,</span>
    <span class="s1">starmap</span><span class="s3">,</span>
    <span class="s1">tee</span><span class="s3">,</span>
    <span class="s1">zip_longest</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">random </span><span class="s2">import </span><span class="s1">randrange</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">choice</span>

<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s4">'all_equal'</span><span class="s3">,</span>
    <span class="s4">'before_and_after'</span><span class="s3">,</span>
    <span class="s4">'consume'</span><span class="s3">,</span>
    <span class="s4">'convolve'</span><span class="s3">,</span>
    <span class="s4">'dotproduct'</span><span class="s3">,</span>
    <span class="s4">'first_true'</span><span class="s3">,</span>
    <span class="s4">'flatten'</span><span class="s3">,</span>
    <span class="s4">'grouper'</span><span class="s3">,</span>
    <span class="s4">'iter_except'</span><span class="s3">,</span>
    <span class="s4">'ncycles'</span><span class="s3">,</span>
    <span class="s4">'nth'</span><span class="s3">,</span>
    <span class="s4">'nth_combination'</span><span class="s3">,</span>
    <span class="s4">'padnone'</span><span class="s3">,</span>
    <span class="s4">'pad_none'</span><span class="s3">,</span>
    <span class="s4">'pairwise'</span><span class="s3">,</span>
    <span class="s4">'partition'</span><span class="s3">,</span>
    <span class="s4">'powerset'</span><span class="s3">,</span>
    <span class="s4">'prepend'</span><span class="s3">,</span>
    <span class="s4">'quantify'</span><span class="s3">,</span>
    <span class="s4">'random_combination_with_replacement'</span><span class="s3">,</span>
    <span class="s4">'random_combination'</span><span class="s3">,</span>
    <span class="s4">'random_permutation'</span><span class="s3">,</span>
    <span class="s4">'random_product'</span><span class="s3">,</span>
    <span class="s4">'repeatfunc'</span><span class="s3">,</span>
    <span class="s4">'roundrobin'</span><span class="s3">,</span>
    <span class="s4">'sliding_window'</span><span class="s3">,</span>
    <span class="s4">'tabulate'</span><span class="s3">,</span>
    <span class="s4">'tail'</span><span class="s3">,</span>
    <span class="s4">'take'</span><span class="s3">,</span>
    <span class="s4">'triplewise'</span><span class="s3">,</span>
    <span class="s4">'unique_everseen'</span><span class="s3">,</span>
    <span class="s4">'unique_justseen'</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s2">def </span><span class="s1">take</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return first *n* items of the iterable as a list. 
 
        &gt;&gt;&gt; take(3, range(10)) 
        [0, 1, 2] 
 
    If there are fewer than *n* items in the iterable, all of them are 
    returned. 
 
        &gt;&gt;&gt; take(10, range(3)) 
        [0, 1, 2] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">tabulate</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return an iterator over the results of ``func(start)``, 
    ``func(start + 1)``, ``func(start + 2)``... 
 
    *func* should be a function that accepts one integer argument. 
 
    If *start* is not specified it defaults to 0. It will be incremented each 
    time the iterator is advanced. 
 
        &gt;&gt;&gt; square = lambda x: x ** 2 
        &gt;&gt;&gt; iterator = tabulate(square, -3) 
        &gt;&gt;&gt; take(4, iterator) 
        [9, 4, 1, 0] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">map</span><span class="s3">(</span><span class="s1">function</span><span class="s3">, </span><span class="s1">count</span><span class="s3">(</span><span class="s1">start</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">tail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return an iterator over the last *n* items of *iterable*. 
 
    &gt;&gt;&gt; t = tail(3, 'ABCDEFG') 
    &gt;&gt;&gt; list(t) 
    ['E', 'F', 'G'] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">deque</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">maxlen</span><span class="s3">=</span><span class="s1">n</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">consume</span><span class="s3">(</span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Advance *iterable* by *n* steps. If *n* is ``None``, consume it 
    entirely. 
 
    Efficiently exhausts an iterator without returning values. Defaults to 
    consuming the whole iterator, but an optional second argument may be 
    provided to limit consumption. 
 
        &gt;&gt;&gt; i = (x for x in range(10)) 
        &gt;&gt;&gt; next(i) 
        0 
        &gt;&gt;&gt; consume(i, 3) 
        &gt;&gt;&gt; next(i) 
        4 
        &gt;&gt;&gt; consume(i) 
        &gt;&gt;&gt; next(i) 
        Traceback (most recent call last): 
          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 
        StopIteration 
 
    If the iterator has fewer items remaining than the provided limit, the 
    whole iterator will be consumed. 
 
        &gt;&gt;&gt; i = (x for x in range(3)) 
        &gt;&gt;&gt; consume(i, 5) 
        &gt;&gt;&gt; next(i) 
        Traceback (most recent call last): 
          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 
        StopIteration 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Use functions that consume iterators at C speed.</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># feed the entire iterator into a zero-length deque</span>
        <span class="s1">deque</span><span class="s3">(</span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">maxlen</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># advance to the empty slice starting at position n</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">iterator</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s2">None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">nth</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the nth item or a default value. 
 
    &gt;&gt;&gt; l = range(10) 
    &gt;&gt;&gt; nth(l, 3) 
    3 
    &gt;&gt;&gt; nth(l, 20, &quot;zebra&quot;) 
    'zebra' 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">next</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), </span><span class="s1">default</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">all_equal</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns ``True`` if all the elements are equal to each other. 
 
        &gt;&gt;&gt; all_equal('aaaa') 
        True 
        &gt;&gt;&gt; all_equal('aaab') 
        False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">g </span><span class="s3">= </span><span class="s1">groupby</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">next</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s2">True</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">next</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">quantify</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return the how many times the predicate is true. 
 
    &gt;&gt;&gt; quantify([True, False, True]) 
    2 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">pad_none</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the sequence of elements and then returns ``None`` indefinitely. 
 
        &gt;&gt;&gt; take(5, pad_none(range(3))) 
        [0, 1, 2, None, None] 
 
    Useful for emulating the behavior of the built-in :func:`map` function. 
 
    See also :func:`padded`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">chain</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">(</span><span class="s2">None</span><span class="s3">))</span>


<span class="s1">padnone </span><span class="s3">= </span><span class="s1">pad_none</span>


<span class="s2">def </span><span class="s1">ncycles</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the sequence elements *n* times 
 
    &gt;&gt;&gt; list(ncycles([&quot;a&quot;, &quot;b&quot;], 3)) 
    ['a', 'b', 'a', 'b', 'a', 'b'] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">chain</span><span class="s3">.</span><span class="s1">from_iterable</span><span class="s3">(</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">), </span><span class="s1">n</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">dotproduct</span><span class="s3">(</span><span class="s1">vec1</span><span class="s3">, </span><span class="s1">vec2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the dot product of the two iterables. 
 
    &gt;&gt;&gt; dotproduct([10, 10], [20, 20]) 
    400 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">vec1</span><span class="s3">, </span><span class="s1">vec2</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">listOfLists</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return an iterator flattening one level of nesting in a list of lists. 
 
        &gt;&gt;&gt; list(flatten([[0, 1], [2, 3]])) 
        [0, 1, 2, 3] 
 
    See also :func:`collapse`, which can flatten multiple levels of nesting. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">chain</span><span class="s3">.</span><span class="s1">from_iterable</span><span class="s3">(</span><span class="s1">listOfLists</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">repeatfunc</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">times</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Call *func* with *args* repeatedly, returning an iterable over the 
    results. 
 
    If *times* is specified, the iterable will terminate after that many 
    repetitions: 
 
        &gt;&gt;&gt; from operator import add 
        &gt;&gt;&gt; times = 4 
        &gt;&gt;&gt; args = 3, 5 
        &gt;&gt;&gt; list(repeatfunc(add, times, *args)) 
        [8, 8, 8, 8] 
 
    If *times* is ``None`` the iterable will not terminate: 
 
        &gt;&gt;&gt; from random import randrange 
        &gt;&gt;&gt; times = None 
        &gt;&gt;&gt; args = 1, 11 
        &gt;&gt;&gt; take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP 
        [2, 4, 8, 1, 8, 4] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">times </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">starmap</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">args</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">starmap</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">times</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_pairwise</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns an iterator of paired items, overlapping, from the original 
 
    &gt;&gt;&gt; take(4, pairwise(count())) 
    [(0, 1), (1, 2), (2, 3), (3, 4)] 
 
    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">tee</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">next</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">yield from </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>


<span class="s2">try</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">pairwise </span><span class="s2">as </span><span class="s1">itertools_pairwise</span>
<span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">pairwise </span><span class="s3">= </span><span class="s1">_pairwise</span>
<span class="s2">else</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">pairwise</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
        <span class="s2">yield from </span><span class="s1">itertools_pairwise</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>

    <span class="s1">pairwise</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">_pairwise</span><span class="s3">.</span><span class="s1">__doc__</span>


<span class="s2">def </span><span class="s1">grouper</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Collect data into fixed-length chunks or blocks. 
 
    &gt;&gt;&gt; list(grouper('ABCDEFG', 3, 'x')) 
    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;grouper expects iterable as first parameter&quot;</span><span class="s3">, </span><span class="s1">DeprecationWarning</span>
        <span class="s3">)</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">iterable </span><span class="s3">= </span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span>
    <span class="s1">args </span><span class="s3">= [</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)] * </span><span class="s1">n</span>
    <span class="s2">return </span><span class="s1">zip_longest</span><span class="s3">(</span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s1">fillvalue</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">roundrobin</span><span class="s3">(*</span><span class="s1">iterables</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yields an item from each iterable, alternating between them. 
 
        &gt;&gt;&gt; list(roundrobin('ABC', 'D', 'EF')) 
        ['A', 'D', 'E', 'B', 'F', 'C'] 
 
    This function produces the same output as :func:`interleave_longest`, but 
    may perform better for some inputs (in particular when the number of 
    iterables is small). 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># Recipe credited to George Sakkis</span>
    <span class="s1">pending </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">iterables</span><span class="s3">)</span>
    <span class="s1">nexts </span><span class="s3">= </span><span class="s1">cycle</span><span class="s3">(</span><span class="s1">iter</span><span class="s3">(</span><span class="s1">it</span><span class="s3">).</span><span class="s1">__next__ </span><span class="s2">for </span><span class="s1">it </span><span class="s2">in </span><span class="s1">iterables</span><span class="s3">)</span>
    <span class="s2">while </span><span class="s1">pending</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">next </span><span class="s2">in </span><span class="s1">nexts</span><span class="s3">:</span>
                <span class="s2">yield </span><span class="s1">next</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">StopIteration</span><span class="s3">:</span>
            <span class="s1">pending </span><span class="s3">-= </span><span class="s5">1</span>
            <span class="s1">nexts </span><span class="s3">= </span><span class="s1">cycle</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">nexts</span><span class="s3">, </span><span class="s1">pending</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">partition</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a 2-tuple of iterables derived from the input iterable. 
    The first yields the items that have ``pred(item) == False``. 
    The second yields the items that have ``pred(item) == True``. 
 
        &gt;&gt;&gt; is_odd = lambda x: x % 2 != 0 
        &gt;&gt;&gt; iterable = range(10) 
        &gt;&gt;&gt; even_items, odd_items = partition(is_odd, iterable) 
        &gt;&gt;&gt; list(even_items), list(odd_items) 
        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9]) 
 
    If *pred* is None, :func:`bool` is used. 
 
        &gt;&gt;&gt; iterable = [0, 1, False, True, '', ' '] 
        &gt;&gt;&gt; false_items, true_items = partition(None, iterable) 
        &gt;&gt;&gt; list(false_items), list(true_items) 
        ([0, False, ''], [1, True, ' ']) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">pred </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">pred </span><span class="s3">= </span><span class="s1">bool</span>

    <span class="s1">evaluations </span><span class="s3">= ((</span><span class="s1">pred</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">t1</span><span class="s3">, </span><span class="s1">t2 </span><span class="s3">= </span><span class="s1">tee</span><span class="s3">(</span><span class="s1">evaluations</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">x </span><span class="s2">for </span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">in </span><span class="s1">t1 </span><span class="s2">if not </span><span class="s1">cond</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">x </span><span class="s2">for </span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) </span><span class="s2">in </span><span class="s1">t2 </span><span class="s2">if </span><span class="s1">cond</span><span class="s3">),</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">powerset</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yields all possible subsets of the iterable. 
 
        &gt;&gt;&gt; list(powerset([1, 2, 3])) 
        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)] 
 
    :func:`powerset` will operate on iterables that aren't :class:`set` 
    instances, so repeated elements in the input will produce repeated elements 
    in the output. Use :func:`unique_everseen` on the input to avoid generating 
    duplicates: 
 
        &gt;&gt;&gt; seq = [1, 1, 0] 
        &gt;&gt;&gt; list(powerset(seq)) 
        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)] 
        &gt;&gt;&gt; from more_itertools import unique_everseen 
        &gt;&gt;&gt; list(powerset(unique_everseen(seq))) 
        [(), (1,), (0,), (1, 0)] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">chain</span><span class="s3">.</span><span class="s1">from_iterable</span><span class="s3">(</span><span class="s1">combinations</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">r</span><span class="s3">) </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">unique_everseen</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Yield unique elements, preserving order. 
 
        &gt;&gt;&gt; list(unique_everseen('AAAABBBCCDAABBB')) 
        ['A', 'B', 'C', 'D'] 
        &gt;&gt;&gt; list(unique_everseen('ABBCcAD', str.lower)) 
        ['A', 'B', 'C', 'D'] 
 
    Sequences with a mix of hashable and unhashable items can be used. 
    The function will be slower (i.e., `O(n^2)`) for unhashable items. 
 
    Remember that ``list`` objects are unhashable - you can use the *key* 
    parameter to transform the list to a tuple (which is hashable) to 
    avoid a slowdown. 
 
        &gt;&gt;&gt; iterable = ([1, 2], [2, 3], [1, 2]) 
        &gt;&gt;&gt; list(unique_everseen(iterable))  # Slow 
        [[1, 2], [2, 3]] 
        &gt;&gt;&gt; list(unique_everseen(iterable, key=tuple))  # Faster 
        [[1, 2], [2, 3]] 
 
    Similary, you may want to convert unhashable ``set`` objects with 
    ``key=frozenset``. For ``dict`` objects, 
    ``key=lambda x: frozenset(x.items())`` can be used. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">seenset </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">seenset_add </span><span class="s3">= </span><span class="s1">seenset</span><span class="s3">.</span><span class="s1">add</span>
    <span class="s1">seenlist </span><span class="s3">= []</span>
    <span class="s1">seenlist_add </span><span class="s3">= </span><span class="s1">seenlist</span><span class="s3">.</span><span class="s1">append</span>
    <span class="s1">use_key </span><span class="s3">= </span><span class="s1">key </span><span class="s2">is not None</span>

    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">iterable</span><span class="s3">:</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">key</span><span class="s3">(</span><span class="s1">element</span><span class="s3">) </span><span class="s2">if </span><span class="s1">use_key </span><span class="s2">else </span><span class="s1">element</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">seenset</span><span class="s3">:</span>
                <span class="s1">seenset_add</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s2">yield </span><span class="s1">element</span>
        <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">seenlist</span><span class="s3">:</span>
                <span class="s1">seenlist_add</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s2">yield </span><span class="s1">element</span>


<span class="s2">def </span><span class="s1">unique_justseen</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yields elements in order, ignoring serial duplicates 
 
    &gt;&gt;&gt; list(unique_justseen('AAAABBBCCDAABBB')) 
    ['A', 'B', 'C', 'D', 'A', 'B'] 
    &gt;&gt;&gt; list(unique_justseen('ABBCcAD', str.lower)) 
    ['A', 'B', 'C', 'A', 'D'] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">map</span><span class="s3">(</span><span class="s1">next</span><span class="s3">, </span><span class="s1">map</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">itemgetter</span><span class="s3">(</span><span class="s5">1</span><span class="s3">), </span><span class="s1">groupby</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">iter_except</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">, </span><span class="s1">first</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yields results from a function repeatedly until an exception is raised. 
 
    Converts a call-until-exception interface to an iterator interface. 
    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel 
    to end the loop. 
 
        &gt;&gt;&gt; l = [0, 1, 2] 
        &gt;&gt;&gt; list(iter_except(l.pop, IndexError)) 
        [2, 1, 0] 
 
    Multiple exceptions can be specified as a stopping condition: 
 
        &gt;&gt;&gt; l = [1, 2, 3, '...', 4, 5, 6] 
        &gt;&gt;&gt; list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError))) 
        [7, 6, 5] 
        &gt;&gt;&gt; list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError))) 
        [4, 3, 2] 
        &gt;&gt;&gt; list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError))) 
        [] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">first </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">first</span><span class="s3">()</span>
        <span class="s2">while </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">func</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s1">exception</span><span class="s3">:</span>
        <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">first_true</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">pred</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the first true value in the iterable. 
 
    If no true value is found, returns *default* 
 
    If *pred* is not None, returns the first item for which 
    ``pred(item) == True`` . 
 
        &gt;&gt;&gt; first_true(range(10)) 
        1 
        &gt;&gt;&gt; first_true(range(10), pred=lambda x: x &gt; 5) 
        6 
        &gt;&gt;&gt; first_true(range(10), default='missing', pred=lambda x: x &gt; 9) 
        'missing' 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">next</span><span class="s3">(</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">pred</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">), </span><span class="s1">default</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">random_product</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Draw an item at random from each of the input iterables. 
 
        &gt;&gt;&gt; random_product('abc', range(4), 'XYZ')  # doctest:+SKIP 
        ('c', 3, 'Z') 
 
    If *repeat* is provided as a keyword argument, that many items will be 
    drawn from each iterable. 
 
        &gt;&gt;&gt; random_product('abcd', range(4), repeat=2)  # doctest:+SKIP 
        ('a', 2, 'd', 3) 
 
    This equivalent to taking a random selection from 
    ``itertools.product(*args, **kwarg)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pools </span><span class="s3">= [</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">) </span><span class="s2">for </span><span class="s1">pool </span><span class="s2">in </span><span class="s1">args</span><span class="s3">] * </span><span class="s1">repeat</span>
    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">choice</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">) </span><span class="s2">for </span><span class="s1">pool </span><span class="s2">in </span><span class="s1">pools</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">random_permutation</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">r</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a random *r* length permutation of the elements in *iterable*. 
 
    If *r* is not specified or is ``None``, then *r* defaults to the length of 
    *iterable*. 
 
        &gt;&gt;&gt; random_permutation(range(5))  # doctest:+SKIP 
        (3, 4, 0, 1, 2) 
 
    This equivalent to taking a random selection from 
    ``itertools.permutations(iterable, r)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pool </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">) </span><span class="s2">if </span><span class="s1">r </span><span class="s2">is None else </span><span class="s1">r</span>
    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sample</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">, </span><span class="s1">r</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">random_combination</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a random *r* length subsequence of the elements in *iterable*. 
 
        &gt;&gt;&gt; random_combination(range(5), 3)  # doctest:+SKIP 
        (2, 3, 4) 
 
    This equivalent to taking a random selection from 
    ``itertools.combinations(iterable, r)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pool </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">)</span>
    <span class="s1">indices </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">sample</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">r</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">random_combination_with_replacement</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a random *r* length subsequence of elements in *iterable*, 
    allowing individual elements to be repeated. 
 
        &gt;&gt;&gt; random_combination_with_replacement(range(3), 5) # doctest:+SKIP 
        (0, 0, 1, 2, 2) 
 
    This equivalent to taking a random selection from 
    ``itertools.combinations_with_replacement(iterable, r)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">pool </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">)</span>
    <span class="s1">indices </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">randrange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">r</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">nth_combination</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">index</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Equivalent to ``list(combinations(iterable, r))[index]``. 
 
    The subsequences of *iterable* that are of length *r* can be ordered 
    lexicographically. :func:`nth_combination` computes the subsequence at 
    sort position *index* directly, without computing the previous 
    subsequences. 
 
        &gt;&gt;&gt; nth_combination(range(5), 3, 5) 
        (0, 3, 4) 
 
    ``ValueError`` will be raised If *r* is negative or greater than the length 
    of *iterable*. 
    ``IndexError`` will be raised if the given *index* is invalid. 
    &quot;&quot;&quot;</span>
    <span class="s1">pool </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">r </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">r </span><span class="s3">&gt; </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s1">c </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s1">r</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">c </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">) // </span><span class="s1">i</span>

    <span class="s2">if </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">index </span><span class="s3">+= </span><span class="s1">c</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">index </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">index </span><span class="s3">&gt;= </span><span class="s1">c</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">IndexError</span>

    <span class="s1">result </span><span class="s3">= []</span>
    <span class="s2">while </span><span class="s1">r</span><span class="s3">:</span>
        <span class="s1">c</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r </span><span class="s3">= </span><span class="s1">c </span><span class="s3">* </span><span class="s1">r </span><span class="s3">// </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">r </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">while </span><span class="s1">index </span><span class="s3">&gt;= </span><span class="s1">c</span><span class="s3">:</span>
            <span class="s1">index </span><span class="s3">-= </span><span class="s1">c</span>
            <span class="s1">c</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">c </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">- </span><span class="s1">r</span><span class="s3">) // </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pool</span><span class="s3">[-</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">n</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">prepend</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">iterator</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yield *value*, followed by the elements in *iterator*. 
 
        &gt;&gt;&gt; value = '0' 
        &gt;&gt;&gt; iterator = ['1', '2', '3'] 
        &gt;&gt;&gt; list(prepend(value, iterator)) 
        ['0', '1', '2', '3'] 
 
    To prepend multiple values, see :func:`itertools.chain` 
    or :func:`value_chain`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">chain</span><span class="s3">([</span><span class="s1">value</span><span class="s3">], </span><span class="s1">iterator</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Convolve the iterable *signal* with the iterable *kernel*. 
 
        &gt;&gt;&gt; signal = (1, 2, 3, 4, 5) 
        &gt;&gt;&gt; kernel = [3, 2, 1] 
        &gt;&gt;&gt; list(convolve(signal, kernel)) 
        [3, 8, 14, 20, 26, 14, 5] 
 
    Note: the input arguments are not interchangeable, as the *kernel* 
    is immediately consumed and stored. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">kernel </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">)[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">)</span>
    <span class="s1">window </span><span class="s3">= </span><span class="s1">deque</span><span class="s3">([</span><span class="s5">0</span><span class="s3">], </span><span class="s1">maxlen</span><span class="s3">=</span><span class="s1">n</span><span class="s3">) * </span><span class="s1">n</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">chain</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)):</span>
        <span class="s1">window</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">window</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">before_and_after</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">it</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A variant of :func:`takewhile` that allows complete access to the 
    remainder of the iterator. 
 
         &gt;&gt;&gt; it = iter('ABCdEfGhI') 
         &gt;&gt;&gt; all_upper, remainder = before_and_after(str.isupper, it) 
         &gt;&gt;&gt; ''.join(all_upper) 
         'ABC' 
         &gt;&gt;&gt; ''.join(remainder) # takewhile() would lose the 'd' 
         'dEfGhI' 
 
    Note that the first iterator must be fully consumed before the second 
    iterator can generate valid results. 
    &quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">it</span><span class="s3">)</span>
    <span class="s1">transition </span><span class="s3">= []</span>

    <span class="s2">def </span><span class="s1">true_iterator</span><span class="s3">():</span>
        <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">elem</span><span class="s3">):</span>
                <span class="s2">yield </span><span class="s1">elem</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">transition</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">elem</span><span class="s3">)</span>
                <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">remainder_iterator</span><span class="s3">():</span>
        <span class="s2">yield from </span><span class="s1">transition</span>
        <span class="s2">yield from </span><span class="s1">it</span>

    <span class="s2">return </span><span class="s1">true_iterator</span><span class="s3">(), </span><span class="s1">remainder_iterator</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">triplewise</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return overlapping triplets from *iterable*. 
 
    &gt;&gt;&gt; list(triplewise('ABCDE')) 
    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')] 
 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">_</span><span class="s3">), (</span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">) </span><span class="s2">in </span><span class="s1">pairwise</span><span class="s3">(</span><span class="s1">pairwise</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)):</span>
        <span class="s2">yield </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">sliding_window</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a sliding window of width *n* over *iterable*. 
 
        &gt;&gt;&gt; list(sliding_window(range(6), 4)) 
        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)] 
 
    If *iterable* has fewer than *n* items, then nothing is yielded: 
 
        &gt;&gt;&gt; list(sliding_window(range(3), 4)) 
        [] 
 
    For a variant with more features, see :func:`windowed`. 
    &quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>
    <span class="s1">window </span><span class="s3">= </span><span class="s1">deque</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">it</span><span class="s3">, </span><span class="s1">n</span><span class="s3">), </span><span class="s1">maxlen</span><span class="s3">=</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">window</span><span class="s3">) == </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s2">yield </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">window</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s1">window</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">yield </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">window</span><span class="s3">)</span>
</pre>
</body>
</html>