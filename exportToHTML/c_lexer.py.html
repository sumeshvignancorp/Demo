<html>
<head>
<title>c_lexer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
c_lexer.py</font>
</center></td></tr></table>
<pre><span class="s0">#------------------------------------------------------------------------------</span>
<span class="s0"># pycparser: c_lexer.py</span>
<span class="s0">#</span>
<span class="s0"># CLexer class: lexer for the C language</span>
<span class="s0">#</span>
<span class="s0"># Eli Bendersky [https://eli.thegreenplace.net/]</span>
<span class="s0"># License: BSD</span>
<span class="s0">#------------------------------------------------------------------------------</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">ply </span><span class="s2">import </span><span class="s1">lex</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">ply</span><span class="s3">.</span><span class="s1">lex </span><span class="s2">import </span><span class="s1">TOKEN</span>


<span class="s2">class </span><span class="s1">CLexer</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; A lexer for the C language. After building it, set the 
        input text with input(), and call token() to get new 
        tokens. 
 
        The public attribute filename can be set to an initial 
        filename, but the lexer will update it upon #line 
        directives. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">error_func</span><span class="s3">, </span><span class="s1">on_lbrace_func</span><span class="s3">, </span><span class="s1">on_rbrace_func</span><span class="s3">,</span>
                 <span class="s1">type_lookup_func</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot; Create a new Lexer. 
 
            error_func: 
                An error function. Will be called with an error 
                message, line and column as arguments, in case of 
                an error during lexing. 
 
            on_lbrace_func, on_rbrace_func: 
                Called when an LBRACE or RBRACE is encountered 
                (likely to push/pop type_lookup_func's scope) 
 
            type_lookup_func: 
                A type lookup function. Given a string, it must 
                return True IFF this string is a name of a type 
                that was defined with a typedef earlier. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">error_func </span><span class="s3">= </span><span class="s1">error_func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">on_lbrace_func </span><span class="s3">= </span><span class="s1">on_lbrace_func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">on_rbrace_func </span><span class="s3">= </span><span class="s1">on_rbrace_func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">type_lookup_func </span><span class="s3">= </span><span class="s1">type_lookup_func</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s5">''</span>

        <span class="s0"># Keeps track of the last token returned from self.token()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">last_token </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s0"># Allow either &quot;# line&quot; or &quot;# &lt;num&gt;&quot; to support GCC's</span>
        <span class="s0"># cpp output</span>
        <span class="s0">#</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">line_pattern </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'([ \t]*line\W)|([ \t]*\d+)'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pragma_pattern </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s5">r'[ \t]*pragma\W'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">build</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot; Builds the lexer from the specification. Must be 
            called after the lexer object is created. 
 
            This method exists separately, because the PLY 
            manual warns against calling lex.lex inside 
            __init__ 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer </span><span class="s3">= </span><span class="s1">lex</span><span class="s3">.</span><span class="s1">lex</span><span class="s3">(</span><span class="s1">object</span><span class="s3">=</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reset_lineno</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot; Resets the internal line number counter of the lexer. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">input</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">input</span><span class="s3">(</span><span class="s1">text</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">token</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">last_token </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">token</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">last_token</span>

    <span class="s2">def </span><span class="s1">find_tok_column</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">token</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot; Find the column of the token in its line. 
        &quot;&quot;&quot;</span>
        <span class="s1">last_cr </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexdata</span><span class="s3">.</span><span class="s1">rfind</span><span class="s3">(</span><span class="s5">'</span><span class="s2">\n</span><span class="s5">'</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">token</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">token</span><span class="s3">.</span><span class="s1">lexpos </span><span class="s3">- </span><span class="s1">last_cr</span>

    <span class="s0">######################--   PRIVATE   --######################</span>

    <span class="s0">##</span>
    <span class="s0">## Internal auxiliary methods</span>
    <span class="s0">##</span>
    <span class="s2">def </span><span class="s1">_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">msg</span><span class="s3">, </span><span class="s1">token</span><span class="s3">):</span>
        <span class="s1">location </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_make_tok_location</span><span class="s3">(</span><span class="s1">token</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">error_func</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">location</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">location</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_make_tok_location</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">token</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">token</span><span class="s3">.</span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">find_tok_column</span><span class="s3">(</span><span class="s1">token</span><span class="s3">))</span>

    <span class="s0">##</span>
    <span class="s0">## Reserved keywords</span>
    <span class="s0">##</span>
    <span class="s1">keywords </span><span class="s3">= (</span>
        <span class="s5">'AUTO'</span><span class="s3">, </span><span class="s5">'BREAK'</span><span class="s3">, </span><span class="s5">'CASE'</span><span class="s3">, </span><span class="s5">'CHAR'</span><span class="s3">, </span><span class="s5">'CONST'</span><span class="s3">,</span>
        <span class="s5">'CONTINUE'</span><span class="s3">, </span><span class="s5">'DEFAULT'</span><span class="s3">, </span><span class="s5">'DO'</span><span class="s3">, </span><span class="s5">'DOUBLE'</span><span class="s3">, </span><span class="s5">'ELSE'</span><span class="s3">, </span><span class="s5">'ENUM'</span><span class="s3">, </span><span class="s5">'EXTERN'</span><span class="s3">,</span>
        <span class="s5">'FLOAT'</span><span class="s3">, </span><span class="s5">'FOR'</span><span class="s3">, </span><span class="s5">'GOTO'</span><span class="s3">, </span><span class="s5">'IF'</span><span class="s3">, </span><span class="s5">'INLINE'</span><span class="s3">, </span><span class="s5">'INT'</span><span class="s3">, </span><span class="s5">'LONG'</span><span class="s3">,</span>
        <span class="s5">'REGISTER'</span><span class="s3">, </span><span class="s5">'OFFSETOF'</span><span class="s3">,</span>
        <span class="s5">'RESTRICT'</span><span class="s3">, </span><span class="s5">'RETURN'</span><span class="s3">, </span><span class="s5">'SHORT'</span><span class="s3">, </span><span class="s5">'SIGNED'</span><span class="s3">, </span><span class="s5">'SIZEOF'</span><span class="s3">, </span><span class="s5">'STATIC'</span><span class="s3">, </span><span class="s5">'STRUCT'</span><span class="s3">,</span>
        <span class="s5">'SWITCH'</span><span class="s3">, </span><span class="s5">'TYPEDEF'</span><span class="s3">, </span><span class="s5">'UNION'</span><span class="s3">, </span><span class="s5">'UNSIGNED'</span><span class="s3">, </span><span class="s5">'VOID'</span><span class="s3">,</span>
        <span class="s5">'VOLATILE'</span><span class="s3">, </span><span class="s5">'WHILE'</span><span class="s3">, </span><span class="s5">'__INT128'</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">keywords_new </span><span class="s3">= (</span>
        <span class="s5">'_BOOL'</span><span class="s3">, </span><span class="s5">'_COMPLEX'</span><span class="s3">,</span>
        <span class="s5">'_NORETURN'</span><span class="s3">, </span><span class="s5">'_THREAD_LOCAL'</span><span class="s3">, </span><span class="s5">'_STATIC_ASSERT'</span><span class="s3">,</span>
        <span class="s5">'_ATOMIC'</span><span class="s3">, </span><span class="s5">'_ALIGNOF'</span><span class="s3">, </span><span class="s5">'_ALIGNAS'</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s1">keyword_map </span><span class="s3">= {}</span>

    <span class="s2">for </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">keywords</span><span class="s3">:</span>
        <span class="s1">keyword_map</span><span class="s3">[</span><span class="s1">keyword</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()] = </span><span class="s1">keyword</span>

    <span class="s2">for </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">keywords_new</span><span class="s3">:</span>
        <span class="s1">keyword_map</span><span class="s3">[</span><span class="s1">keyword</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">].</span><span class="s1">upper</span><span class="s3">() + </span><span class="s1">keyword</span><span class="s3">[</span><span class="s6">2</span><span class="s3">:].</span><span class="s1">lower</span><span class="s3">()] = </span><span class="s1">keyword</span>

    <span class="s0">##</span>
    <span class="s0">## All the tokens recognized by the lexer</span>
    <span class="s0">##</span>
    <span class="s1">tokens </span><span class="s3">= </span><span class="s1">keywords </span><span class="s3">+ </span><span class="s1">keywords_new </span><span class="s3">+ (</span>
        <span class="s0"># Identifiers</span>
        <span class="s5">'ID'</span><span class="s3">,</span>

        <span class="s0"># Type identifiers (identifiers previously defined as</span>
        <span class="s0"># types with typedef)</span>
        <span class="s5">'TYPEID'</span><span class="s3">,</span>

        <span class="s0"># constants</span>
        <span class="s5">'INT_CONST_DEC'</span><span class="s3">, </span><span class="s5">'INT_CONST_OCT'</span><span class="s3">, </span><span class="s5">'INT_CONST_HEX'</span><span class="s3">, </span><span class="s5">'INT_CONST_BIN'</span><span class="s3">, </span><span class="s5">'INT_CONST_CHAR'</span><span class="s3">,</span>
        <span class="s5">'FLOAT_CONST'</span><span class="s3">, </span><span class="s5">'HEX_FLOAT_CONST'</span><span class="s3">,</span>
        <span class="s5">'CHAR_CONST'</span><span class="s3">,</span>
        <span class="s5">'WCHAR_CONST'</span><span class="s3">,</span>
        <span class="s5">'U8CHAR_CONST'</span><span class="s3">,</span>
        <span class="s5">'U16CHAR_CONST'</span><span class="s3">,</span>
        <span class="s5">'U32CHAR_CONST'</span><span class="s3">,</span>

        <span class="s0"># String literals</span>
        <span class="s5">'STRING_LITERAL'</span><span class="s3">,</span>
        <span class="s5">'WSTRING_LITERAL'</span><span class="s3">,</span>
        <span class="s5">'U8STRING_LITERAL'</span><span class="s3">,</span>
        <span class="s5">'U16STRING_LITERAL'</span><span class="s3">,</span>
        <span class="s5">'U32STRING_LITERAL'</span><span class="s3">,</span>

        <span class="s0"># Operators</span>
        <span class="s5">'PLUS'</span><span class="s3">, </span><span class="s5">'MINUS'</span><span class="s3">, </span><span class="s5">'TIMES'</span><span class="s3">, </span><span class="s5">'DIVIDE'</span><span class="s3">, </span><span class="s5">'MOD'</span><span class="s3">,</span>
        <span class="s5">'OR'</span><span class="s3">, </span><span class="s5">'AND'</span><span class="s3">, </span><span class="s5">'NOT'</span><span class="s3">, </span><span class="s5">'XOR'</span><span class="s3">, </span><span class="s5">'LSHIFT'</span><span class="s3">, </span><span class="s5">'RSHIFT'</span><span class="s3">,</span>
        <span class="s5">'LOR'</span><span class="s3">, </span><span class="s5">'LAND'</span><span class="s3">, </span><span class="s5">'LNOT'</span><span class="s3">,</span>
        <span class="s5">'LT'</span><span class="s3">, </span><span class="s5">'LE'</span><span class="s3">, </span><span class="s5">'GT'</span><span class="s3">, </span><span class="s5">'GE'</span><span class="s3">, </span><span class="s5">'EQ'</span><span class="s3">, </span><span class="s5">'NE'</span><span class="s3">,</span>

        <span class="s0"># Assignment</span>
        <span class="s5">'EQUALS'</span><span class="s3">, </span><span class="s5">'TIMESEQUAL'</span><span class="s3">, </span><span class="s5">'DIVEQUAL'</span><span class="s3">, </span><span class="s5">'MODEQUAL'</span><span class="s3">,</span>
        <span class="s5">'PLUSEQUAL'</span><span class="s3">, </span><span class="s5">'MINUSEQUAL'</span><span class="s3">,</span>
        <span class="s5">'LSHIFTEQUAL'</span><span class="s3">,</span><span class="s5">'RSHIFTEQUAL'</span><span class="s3">, </span><span class="s5">'ANDEQUAL'</span><span class="s3">, </span><span class="s5">'XOREQUAL'</span><span class="s3">,</span>
        <span class="s5">'OREQUAL'</span><span class="s3">,</span>

        <span class="s0"># Increment/decrement</span>
        <span class="s5">'PLUSPLUS'</span><span class="s3">, </span><span class="s5">'MINUSMINUS'</span><span class="s3">,</span>

        <span class="s0"># Structure dereference (-&gt;)</span>
        <span class="s5">'ARROW'</span><span class="s3">,</span>

        <span class="s0"># Conditional operator (?)</span>
        <span class="s5">'CONDOP'</span><span class="s3">,</span>

        <span class="s0"># Delimiters</span>
        <span class="s5">'LPAREN'</span><span class="s3">, </span><span class="s5">'RPAREN'</span><span class="s3">,         </span><span class="s0"># ( )</span>
        <span class="s5">'LBRACKET'</span><span class="s3">, </span><span class="s5">'RBRACKET'</span><span class="s3">,     </span><span class="s0"># [ ]</span>
        <span class="s5">'LBRACE'</span><span class="s3">, </span><span class="s5">'RBRACE'</span><span class="s3">,         </span><span class="s0"># { }</span>
        <span class="s5">'COMMA'</span><span class="s3">, </span><span class="s5">'PERIOD'</span><span class="s3">,          </span><span class="s0"># . ,</span>
        <span class="s5">'SEMI'</span><span class="s3">, </span><span class="s5">'COLON'</span><span class="s3">,            </span><span class="s0"># ; :</span>

        <span class="s0"># Ellipsis (...)</span>
        <span class="s5">'ELLIPSIS'</span><span class="s3">,</span>

        <span class="s0"># pre-processor</span>
        <span class="s5">'PPHASH'</span><span class="s3">,       </span><span class="s0"># '#'</span>
        <span class="s5">'PPPRAGMA'</span><span class="s3">,     </span><span class="s0"># 'pragma'</span>
        <span class="s5">'PPPRAGMASTR'</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s0">##</span>
    <span class="s0">## Regexes for use in tokens</span>
    <span class="s0">##</span>
    <span class="s0">##</span>

    <span class="s0"># valid C identifiers (K&amp;R2: A.2.3), plus '$' (supported by some compilers)</span>
    <span class="s1">identifier </span><span class="s3">= </span><span class="s5">r'[a-zA-Z_$][0-9a-zA-Z_$]*'</span>

    <span class="s1">hex_prefix </span><span class="s3">= </span><span class="s5">'0[xX]'</span>
    <span class="s1">hex_digits </span><span class="s3">= </span><span class="s5">'[0-9a-fA-F]+'</span>
    <span class="s1">bin_prefix </span><span class="s3">= </span><span class="s5">'0[bB]'</span>
    <span class="s1">bin_digits </span><span class="s3">= </span><span class="s5">'[01]+'</span>

    <span class="s0"># integer constants (K&amp;R2: A.2.5.1)</span>
    <span class="s1">integer_suffix_opt </span><span class="s3">= </span><span class="s5">r'(([uU]ll)|([uU]LL)|(ll[uU]?)|(LL[uU]?)|([uU][lL])|([lL][uU]?)|[uU])?'</span>
    <span class="s1">decimal_constant </span><span class="s3">= </span><span class="s5">'(0'</span><span class="s3">+</span><span class="s1">integer_suffix_opt</span><span class="s3">+</span><span class="s5">')|([1-9][0-9]*'</span><span class="s3">+</span><span class="s1">integer_suffix_opt</span><span class="s3">+</span><span class="s5">')'</span>
    <span class="s1">octal_constant </span><span class="s3">= </span><span class="s5">'0[0-7]*'</span><span class="s3">+</span><span class="s1">integer_suffix_opt</span>
    <span class="s1">hex_constant </span><span class="s3">= </span><span class="s1">hex_prefix</span><span class="s3">+</span><span class="s1">hex_digits</span><span class="s3">+</span><span class="s1">integer_suffix_opt</span>
    <span class="s1">bin_constant </span><span class="s3">= </span><span class="s1">bin_prefix</span><span class="s3">+</span><span class="s1">bin_digits</span><span class="s3">+</span><span class="s1">integer_suffix_opt</span>

    <span class="s1">bad_octal_constant </span><span class="s3">= </span><span class="s5">'0[0-7]*[89]'</span>

    <span class="s0"># character constants (K&amp;R2: A.2.5.2)</span>
    <span class="s0"># Note: a-zA-Z and '.-~^_!=&amp;;,' are allowed as escape chars to support #line</span>
    <span class="s0"># directives with Windows paths as filenames (..\..\dir\file)</span>
    <span class="s0"># For the same reason, decimal_escape allows all digit sequences. We want to</span>
    <span class="s0"># parse all correct code, even if it means to sometimes parse incorrect</span>
    <span class="s0"># code.</span>
    <span class="s0">#</span>
    <span class="s0"># The original regexes were taken verbatim from the C syntax definition,</span>
    <span class="s0"># and were later modified to avoid worst-case exponential running time.</span>
    <span class="s0">#</span>
    <span class="s0">#   simple_escape = r&quot;&quot;&quot;([a-zA-Z._~!=&amp;\^\-\\?'&quot;])&quot;&quot;&quot;</span>
    <span class="s0">#   decimal_escape = r&quot;&quot;&quot;(\d+)&quot;&quot;&quot;</span>
    <span class="s0">#   hex_escape = r&quot;&quot;&quot;(x[0-9a-fA-F]+)&quot;&quot;&quot;</span>
    <span class="s0">#   bad_escape = r&quot;&quot;&quot;([\\][^a-zA-Z._~^!=&amp;\^\-\\?'&quot;x0-7])&quot;&quot;&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># The following modifications were made to avoid the ambiguity that allowed backtracking:</span>
    <span class="s0"># (https://github.com/eliben/pycparser/issues/61)</span>
    <span class="s0">#</span>
    <span class="s0"># - \x was removed from simple_escape, unless it was not followed by a hex digit, to avoid ambiguity with hex_escape.</span>
    <span class="s0"># - hex_escape allows one or more hex characters, but requires that the next character(if any) is not hex</span>
    <span class="s0"># - decimal_escape allows one or more decimal characters, but requires that the next character(if any) is not a decimal</span>
    <span class="s0"># - bad_escape does not allow any decimals (8-9), to avoid conflicting with the permissive decimal_escape.</span>
    <span class="s0">#</span>
    <span class="s0"># Without this change, python's `re` module would recursively try parsing each ambiguous escape sequence in multiple ways.</span>
    <span class="s0"># e.g. `\123` could be parsed as `\1`+`23`, `\12`+`3`, and `\123`.</span>

    <span class="s1">simple_escape </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([a-wyzA-Z._~!=&amp;\^\-\\?'&quot;]|x(?![0-9a-fA-F]))&quot;&quot;&quot;</span>
    <span class="s1">decimal_escape </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;(\d+)(?!\d)&quot;&quot;&quot;</span>
    <span class="s1">hex_escape </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;(x[0-9a-fA-F]+)(?![0-9a-fA-F])&quot;&quot;&quot;</span>
    <span class="s1">bad_escape </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([\\][^a-zA-Z._~^!=&amp;\^\-\\?'&quot;x0-9])&quot;&quot;&quot;</span>

    <span class="s1">escape_sequence </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;(\\(&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">simple_escape</span><span class="s3">+</span><span class="s5">'|'</span><span class="s3">+</span><span class="s1">decimal_escape</span><span class="s3">+</span><span class="s5">'|'</span><span class="s3">+</span><span class="s1">hex_escape</span><span class="s3">+</span><span class="s5">'))'</span>

    <span class="s0"># This complicated regex with lookahead might be slow for strings, so because all of the valid escapes (including \x) allowed</span>
    <span class="s0"># 0 or more non-escaped characters after the first character, simple_escape+decimal_escape+hex_escape got simplified to</span>

    <span class="s1">escape_sequence_start_in_string </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;(\\[0-9a-zA-Z._~!=&amp;\^\-\\?'&quot;])&quot;&quot;&quot;</span>

    <span class="s1">cconst_char </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([^'\\\n]|&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">escape_sequence</span><span class="s3">+</span><span class="s5">')'</span>
    <span class="s1">char_const </span><span class="s3">= </span><span class="s5">&quot;'&quot;</span><span class="s3">+</span><span class="s1">cconst_char</span><span class="s3">+</span><span class="s5">&quot;'&quot;</span>
    <span class="s1">wchar_const </span><span class="s3">= </span><span class="s5">'L'</span><span class="s3">+</span><span class="s1">char_const</span>
    <span class="s1">u8char_const </span><span class="s3">= </span><span class="s5">'u8'</span><span class="s3">+</span><span class="s1">char_const</span>
    <span class="s1">u16char_const </span><span class="s3">= </span><span class="s5">'u'</span><span class="s3">+</span><span class="s1">char_const</span>
    <span class="s1">u32char_const </span><span class="s3">= </span><span class="s5">'U'</span><span class="s3">+</span><span class="s1">char_const</span>
    <span class="s1">multicharacter_constant </span><span class="s3">= </span><span class="s5">&quot;'&quot;</span><span class="s3">+</span><span class="s1">cconst_char</span><span class="s3">+</span><span class="s5">&quot;{2,4}'&quot;</span>
    <span class="s1">unmatched_quote </span><span class="s3">= </span><span class="s5">&quot;('&quot;</span><span class="s3">+</span><span class="s1">cconst_char</span><span class="s3">+</span><span class="s5">&quot;*</span><span class="s2">\\</span><span class="s5">n)|('&quot;</span><span class="s3">+</span><span class="s1">cconst_char</span><span class="s3">+</span><span class="s5">&quot;*$)&quot;</span>
    <span class="s1">bad_char_const </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;('&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">cconst_char</span><span class="s3">+</span><span class="s5">&quot;&quot;&quot;[^'</span><span class="s2">\n</span><span class="s5">]+')|('')|('&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">bad_escape</span><span class="s3">+</span><span class="s5">r&quot;&quot;&quot;[^'\n]*')&quot;&quot;&quot;</span>

    <span class="s0"># string literals (K&amp;R2: A.2.6)</span>
    <span class="s1">string_char </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([^&quot;\\\n]|&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">escape_sequence_start_in_string</span><span class="s3">+</span><span class="s5">')'</span>
    <span class="s1">string_literal </span><span class="s3">= </span><span class="s5">'&quot;'</span><span class="s3">+</span><span class="s1">string_char</span><span class="s3">+</span><span class="s5">'*&quot;'</span>
    <span class="s1">wstring_literal </span><span class="s3">= </span><span class="s5">'L'</span><span class="s3">+</span><span class="s1">string_literal</span>
    <span class="s1">u8string_literal </span><span class="s3">= </span><span class="s5">'u8'</span><span class="s3">+</span><span class="s1">string_literal</span>
    <span class="s1">u16string_literal </span><span class="s3">= </span><span class="s5">'u'</span><span class="s3">+</span><span class="s1">string_literal</span>
    <span class="s1">u32string_literal </span><span class="s3">= </span><span class="s5">'U'</span><span class="s3">+</span><span class="s1">string_literal</span>
    <span class="s1">bad_string_literal </span><span class="s3">= </span><span class="s5">'&quot;'</span><span class="s3">+</span><span class="s1">string_char</span><span class="s3">+</span><span class="s5">'*'</span><span class="s3">+</span><span class="s1">bad_escape</span><span class="s3">+</span><span class="s1">string_char</span><span class="s3">+</span><span class="s5">'*&quot;'</span>

    <span class="s0"># floating constants (K&amp;R2: A.2.5.3)</span>
    <span class="s1">exponent_part </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([eE][-+]?[0-9]+)&quot;&quot;&quot;</span>
    <span class="s1">fractional_constant </span><span class="s3">= </span><span class="s5">r&quot;&quot;&quot;([0-9]*\.[0-9]+)|([0-9]+\.)&quot;&quot;&quot;</span>
    <span class="s1">floating_constant </span><span class="s3">= </span><span class="s5">'(((('</span><span class="s3">+</span><span class="s1">fractional_constant</span><span class="s3">+</span><span class="s5">')'</span><span class="s3">+</span><span class="s1">exponent_part</span><span class="s3">+</span><span class="s5">'?)|([0-9]+'</span><span class="s3">+</span><span class="s1">exponent_part</span><span class="s3">+</span><span class="s5">'))[FfLl]?)'</span>
    <span class="s1">binary_exponent_part </span><span class="s3">= </span><span class="s5">r'''([pP][+-]?[0-9]+)'''</span>
    <span class="s1">hex_fractional_constant </span><span class="s3">= </span><span class="s5">'((('</span><span class="s3">+</span><span class="s1">hex_digits</span><span class="s3">+</span><span class="s5">r&quot;&quot;&quot;)?\.&quot;&quot;&quot;</span><span class="s3">+</span><span class="s1">hex_digits</span><span class="s3">+</span><span class="s5">')|('</span><span class="s3">+</span><span class="s1">hex_digits</span><span class="s3">+</span><span class="s5">r&quot;&quot;&quot;\.))&quot;&quot;&quot;</span>
    <span class="s1">hex_floating_constant </span><span class="s3">= </span><span class="s5">'('</span><span class="s3">+</span><span class="s1">hex_prefix</span><span class="s3">+</span><span class="s5">'('</span><span class="s3">+</span><span class="s1">hex_digits</span><span class="s3">+</span><span class="s5">'|'</span><span class="s3">+</span><span class="s1">hex_fractional_constant</span><span class="s3">+</span><span class="s5">')'</span><span class="s3">+</span><span class="s1">binary_exponent_part</span><span class="s3">+</span><span class="s5">'[FfLl]?)'</span>

    <span class="s0">##</span>
    <span class="s0">## Lexer states: used for preprocessor \n-terminated directives</span>
    <span class="s0">##</span>
    <span class="s1">states </span><span class="s3">= (</span>
        <span class="s0"># ppline: preprocessor line directives</span>
        <span class="s0">#</span>
        <span class="s3">(</span><span class="s5">'ppline'</span><span class="s3">, </span><span class="s5">'exclusive'</span><span class="s3">),</span>

        <span class="s0"># pppragma: pragma</span>
        <span class="s0">#</span>
        <span class="s3">(</span><span class="s5">'pppragma'</span><span class="s3">, </span><span class="s5">'exclusive'</span><span class="s3">),</span>
    <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">t_PPHASH</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'[ \t]*\#'</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">line_pattern</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexdata</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">=</span><span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">):</span>
            <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">begin</span><span class="s3">(</span><span class="s5">'ppline'</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_filename </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pragma_pattern</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexdata</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">=</span><span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lexpos</span><span class="s3">):</span>
            <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">begin</span><span class="s3">(</span><span class="s5">'pppragma'</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s5">'PPHASH'</span>
            <span class="s2">return </span><span class="s1">t</span>

    <span class="s0">##</span>
    <span class="s0">## Rules for the ppline state</span>
    <span class="s0">##</span>
    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">string_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_ppline_FILENAME</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s5">'filename before line number in #line'</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">pp_filename </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s5">'&quot;'</span><span class="s3">).</span><span class="s1">rstrip</span><span class="s3">(</span><span class="s5">'&quot;'</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">decimal_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_ppline_LINE_NUMBER</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Ignore: GCC's cpp sometimes inserts a numeric flag</span>
            <span class="s0"># after the file name</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">t_ppline_NEWLINE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'\n'</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s5">'line number missing in #line'</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_line</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_filename </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">filename </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pp_filename</span>

        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">begin</span><span class="s3">(</span><span class="s5">'INITIAL'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">t_ppline_PPLINE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'line'</span>
        <span class="s2">pass</span>

    <span class="s1">t_ppline_ignore </span><span class="s3">= </span><span class="s5">' </span><span class="s2">\t</span><span class="s5">'</span>

    <span class="s2">def </span><span class="s1">t_ppline_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s5">'invalid #line directive'</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s0">##</span>
    <span class="s0">## Rules for the pppragma state</span>
    <span class="s0">##</span>
    <span class="s2">def </span><span class="s1">t_pppragma_NEWLINE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'\n'</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">+= </span><span class="s6">1</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">begin</span><span class="s3">(</span><span class="s5">'INITIAL'</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">t_pppragma_PPPRAGMA</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'pragma'</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s1">t_pppragma_ignore </span><span class="s3">= </span><span class="s5">' </span><span class="s2">\t</span><span class="s5">'</span>

    <span class="s2">def </span><span class="s1">t_pppragma_STR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">'.+'</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s5">'PPPRAGMASTR'</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">t_pppragma_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s5">'invalid #pragma directive'</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s0">##</span>
    <span class="s0">## Rules for the normal state</span>
    <span class="s0">##</span>
    <span class="s1">t_ignore </span><span class="s3">= </span><span class="s5">' </span><span class="s2">\t</span><span class="s5">'</span>

    <span class="s0"># Newlines</span>
    <span class="s2">def </span><span class="s1">t_NEWLINE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s4">r'\n+'</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">lexer</span><span class="s3">.</span><span class="s1">lineno </span><span class="s3">+= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s3">)</span>

    <span class="s0"># Operators</span>
    <span class="s1">t_PLUS              </span><span class="s3">= </span><span class="s5">r'\+'</span>
    <span class="s1">t_MINUS             </span><span class="s3">= </span><span class="s5">r'-'</span>
    <span class="s1">t_TIMES             </span><span class="s3">= </span><span class="s5">r'\*'</span>
    <span class="s1">t_DIVIDE            </span><span class="s3">= </span><span class="s5">r'/'</span>
    <span class="s1">t_MOD               </span><span class="s3">= </span><span class="s5">r'%'</span>
    <span class="s1">t_OR                </span><span class="s3">= </span><span class="s5">r'\|'</span>
    <span class="s1">t_AND               </span><span class="s3">= </span><span class="s5">r'&amp;'</span>
    <span class="s1">t_NOT               </span><span class="s3">= </span><span class="s5">r'~'</span>
    <span class="s1">t_XOR               </span><span class="s3">= </span><span class="s5">r'\^'</span>
    <span class="s1">t_LSHIFT            </span><span class="s3">= </span><span class="s5">r'&lt;&lt;'</span>
    <span class="s1">t_RSHIFT            </span><span class="s3">= </span><span class="s5">r'&gt;&gt;'</span>
    <span class="s1">t_LOR               </span><span class="s3">= </span><span class="s5">r'\|\|'</span>
    <span class="s1">t_LAND              </span><span class="s3">= </span><span class="s5">r'&amp;&amp;'</span>
    <span class="s1">t_LNOT              </span><span class="s3">= </span><span class="s5">r'!'</span>
    <span class="s1">t_LT                </span><span class="s3">= </span><span class="s5">r'&lt;'</span>
    <span class="s1">t_GT                </span><span class="s3">= </span><span class="s5">r'&gt;'</span>
    <span class="s1">t_LE                </span><span class="s3">= </span><span class="s5">r'&lt;='</span>
    <span class="s1">t_GE                </span><span class="s3">= </span><span class="s5">r'&gt;='</span>
    <span class="s1">t_EQ                </span><span class="s3">= </span><span class="s5">r'=='</span>
    <span class="s1">t_NE                </span><span class="s3">= </span><span class="s5">r'!='</span>

    <span class="s0"># Assignment operators</span>
    <span class="s1">t_EQUALS            </span><span class="s3">= </span><span class="s5">r'='</span>
    <span class="s1">t_TIMESEQUAL        </span><span class="s3">= </span><span class="s5">r'\*='</span>
    <span class="s1">t_DIVEQUAL          </span><span class="s3">= </span><span class="s5">r'/='</span>
    <span class="s1">t_MODEQUAL          </span><span class="s3">= </span><span class="s5">r'%='</span>
    <span class="s1">t_PLUSEQUAL         </span><span class="s3">= </span><span class="s5">r'\+='</span>
    <span class="s1">t_MINUSEQUAL        </span><span class="s3">= </span><span class="s5">r'-='</span>
    <span class="s1">t_LSHIFTEQUAL       </span><span class="s3">= </span><span class="s5">r'&lt;&lt;='</span>
    <span class="s1">t_RSHIFTEQUAL       </span><span class="s3">= </span><span class="s5">r'&gt;&gt;='</span>
    <span class="s1">t_ANDEQUAL          </span><span class="s3">= </span><span class="s5">r'&amp;='</span>
    <span class="s1">t_OREQUAL           </span><span class="s3">= </span><span class="s5">r'\|='</span>
    <span class="s1">t_XOREQUAL          </span><span class="s3">= </span><span class="s5">r'\^='</span>

    <span class="s0"># Increment/decrement</span>
    <span class="s1">t_PLUSPLUS          </span><span class="s3">= </span><span class="s5">r'\+\+'</span>
    <span class="s1">t_MINUSMINUS        </span><span class="s3">= </span><span class="s5">r'--'</span>

    <span class="s0"># -&gt;</span>
    <span class="s1">t_ARROW             </span><span class="s3">= </span><span class="s5">r'-&gt;'</span>

    <span class="s0"># ?</span>
    <span class="s1">t_CONDOP            </span><span class="s3">= </span><span class="s5">r'\?'</span>

    <span class="s0"># Delimiters</span>
    <span class="s1">t_LPAREN            </span><span class="s3">= </span><span class="s5">r'\('</span>
    <span class="s1">t_RPAREN            </span><span class="s3">= </span><span class="s5">r'\)'</span>
    <span class="s1">t_LBRACKET          </span><span class="s3">= </span><span class="s5">r'\['</span>
    <span class="s1">t_RBRACKET          </span><span class="s3">= </span><span class="s5">r'\]'</span>
    <span class="s1">t_COMMA             </span><span class="s3">= </span><span class="s5">r','</span>
    <span class="s1">t_PERIOD            </span><span class="s3">= </span><span class="s5">r'\.'</span>
    <span class="s1">t_SEMI              </span><span class="s3">= </span><span class="s5">r';'</span>
    <span class="s1">t_COLON             </span><span class="s3">= </span><span class="s5">r':'</span>
    <span class="s1">t_ELLIPSIS          </span><span class="s3">= </span><span class="s5">r'\.\.\.'</span>

    <span class="s0"># Scope delimiters</span>
    <span class="s0"># To see why on_lbrace_func is needed, consider:</span>
    <span class="s0">#   typedef char TT;</span>
    <span class="s0">#   void foo(int TT) { TT = 10; }</span>
    <span class="s0">#   TT x = 5;</span>
    <span class="s0"># Outside the function, TT is a typedef, but inside (starting and ending</span>
    <span class="s0"># with the braces) it's a parameter.  The trouble begins with yacc's</span>
    <span class="s0"># lookahead token.  If we open a new scope in brace_open, then TT has</span>
    <span class="s0"># already been read and incorrectly interpreted as TYPEID.  So, we need</span>
    <span class="s0"># to open and close scopes from within the lexer.</span>
    <span class="s0"># Similar for the TT immediately outside the end of the function.</span>
    <span class="s0">#</span>
    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s5">r'\{'</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_LBRACE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">on_lbrace_func</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">t</span>
    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s5">r'\}'</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_RBRACE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">on_rbrace_func</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s1">t_STRING_LITERAL </span><span class="s3">= </span><span class="s1">string_literal</span>

    <span class="s0"># The following floating and integer constants are defined as</span>
    <span class="s0"># functions to impose a strict order (otherwise, decimal</span>
    <span class="s0"># is placed before the others because its regex is longer,</span>
    <span class="s0"># and this is bad)</span>
    <span class="s0">#</span>
    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">floating_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_FLOAT_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">hex_floating_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_HEX_FLOAT_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">hex_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_INT_CONST_HEX</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">bin_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_INT_CONST_BIN</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">bad_octal_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_BAD_CONST_OCT</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Invalid octal constant&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">octal_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_INT_CONST_OCT</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">decimal_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_INT_CONST_DEC</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s0"># Must come before bad_char_const, to prevent it from</span>
    <span class="s0"># catching valid char constants as invalid</span>
    <span class="s0">#</span>
    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">multicharacter_constant</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_INT_CONST_CHAR</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">char_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_CHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">wchar_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_WCHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u8char_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U8CHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u16char_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U16CHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u32char_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U32CHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">unmatched_quote</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_UNMATCHED_QUOTE</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Unmatched '&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">bad_char_const</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_BAD_CHAR_CONST</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;Invalid char constant %s&quot; </span><span class="s3">% </span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">wstring_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_WSTRING_LITERAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u8string_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U8STRING_LITERAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u16string_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U16STRING_LITERAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">u32string_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_U32STRING_LITERAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s0"># unmatched string literals are caught by the preprocessor</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">bad_string_literal</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_BAD_STRING_LITERAL</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">&quot;String contains invalid escape code&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">TOKEN</span><span class="s3">(</span><span class="s1">identifier</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">t_ID</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">keyword_map</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span><span class="s3">, </span><span class="s5">&quot;ID&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s5">'ID' </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">type_lookup_func</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span><span class="s3">):</span>
            <span class="s1">t</span><span class="s3">.</span><span class="s1">type </span><span class="s3">= </span><span class="s5">&quot;TYPEID&quot;</span>
        <span class="s2">return </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">t_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s5">'Illegal character %s' </span><span class="s3">% </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">value</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_error</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
</pre>
</body>
</html>