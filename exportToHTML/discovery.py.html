<html>
<head>
<title>discovery.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
discovery.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Automatic discovery of Python modules and packages (for inclusion in the 
distribution) and other config values. 
 
For the purposes of this module, the following nomenclature is used: 
 
- &quot;src-layout&quot;: a directory representing a Python project that contains a &quot;src&quot; 
  folder. Everything under the &quot;src&quot; folder is meant to be included in the 
  distribution when packaging the project. Example:: 
 
    . 
    ├── tox.ini 
    ├── pyproject.toml 
    └── src/ 
        └── mypkg/ 
            ├── __init__.py 
            ├── mymodule.py 
            └── my_data_file.txt 
 
- &quot;flat-layout&quot;: a Python project that does not use &quot;src-layout&quot; but instead 
  have a directory under the project root for each package:: 
 
    . 
    ├── tox.ini 
    ├── pyproject.toml 
    └── mypkg/ 
        ├── __init__.py 
        ├── mymodule.py 
        └── my_data_file.txt 
 
- &quot;single-module&quot;: a project that contains a single Python script direct under 
  the project root (no directory used):: 
 
    . 
    ├── tox.ini 
    ├── pyproject.toml 
    └── mymodule.py 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">fnmatch </span><span class="s2">import </span><span class="s1">fnmatchcase</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">glob</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s3">,</span>
    <span class="s1">Callable</span><span class="s3">,</span>
    <span class="s1">Dict</span><span class="s3">,</span>
    <span class="s1">Iterable</span><span class="s3">,</span>
    <span class="s1">Iterator</span><span class="s3">,</span>
    <span class="s1">List</span><span class="s3">,</span>
    <span class="s1">Mapping</span><span class="s3">,</span>
    <span class="s1">Optional</span><span class="s3">,</span>
    <span class="s1">Tuple</span><span class="s3">,</span>
    <span class="s1">Union</span>
<span class="s3">)</span>

<span class="s2">import </span><span class="s1">_distutils_hack</span><span class="s3">.</span><span class="s1">override  </span><span class="s4"># noqa: F401</span>

<span class="s2">from </span><span class="s1">distutils </span><span class="s2">import </span><span class="s1">log</span>
<span class="s2">from </span><span class="s1">distutils</span><span class="s3">.</span><span class="s1">util </span><span class="s2">import </span><span class="s1">convert_path</span>

<span class="s1">_Path </span><span class="s3">= </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">PathLike</span><span class="s3">]</span>
<span class="s1">_Filter </span><span class="s3">= </span><span class="s1">Callable</span><span class="s3">[[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">bool</span><span class="s3">]</span>
<span class="s1">StrIter </span><span class="s3">= </span><span class="s1">Iterator</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]</span>

<span class="s1">chain_iter </span><span class="s3">= </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">chain</span><span class="s3">.</span><span class="s1">from_iterable</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">setuptools </span><span class="s2">import </span><span class="s1">Distribution  </span><span class="s4"># noqa</span>


<span class="s2">def </span><span class="s1">_valid_name</span><span class="s3">(</span><span class="s1">path</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s4"># Ignore invalid names that cannot be imported directly</span>
    <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">path</span><span class="s3">).</span><span class="s1">isidentifier</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">_Finder</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Base class that exposes functionality for module/package finders&quot;&quot;&quot;</span>

    <span class="s1">ALWAYS_EXCLUDE</span><span class="s3">: </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...] = ()</span>
    <span class="s1">DEFAULT_EXCLUDE</span><span class="s3">: </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, ...] = ()</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">find</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">where</span><span class="s3">: </span><span class="s1">_Path </span><span class="s3">= </span><span class="s5">'.'</span><span class="s3">,</span>
        <span class="s1">exclude</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = (),</span>
        <span class="s1">include</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = (</span><span class="s5">'*'</span><span class="s3">,)</span>
    <span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Return a list of all Python items (packages or modules, depending on 
        the finder implementation) found within directory 'where'. 
 
        'where' is the root directory which will be searched. 
        It should be supplied as a &quot;cross-platform&quot; (i.e. URL-style) path; 
        it will be converted to the appropriate local path syntax. 
 
        'exclude' is a sequence of names to exclude; '*' can be used 
        as a wildcard in the names. 
        When finding packages, 'foo.*' will exclude all subpackages of 'foo' 
        (but not 'foo' itself). 
 
        'include' is a sequence of names to include. 
        If it's specified, only the named items will be included. 
        If it's not specified, all found items will be included. 
        'include' can contain shell style wildcard patterns just like 
        'exclude'. 
        &quot;&quot;&quot;</span>

        <span class="s1">exclude </span><span class="s3">= </span><span class="s1">exclude </span><span class="s2">or </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">DEFAULT_EXCLUDE</span>
        <span class="s2">return </span><span class="s1">list</span><span class="s3">(</span>
            <span class="s1">cls</span><span class="s3">.</span><span class="s1">_find_iter</span><span class="s3">(</span>
                <span class="s1">convert_path</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">where</span><span class="s3">)),</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">_build_filter</span><span class="s3">(*</span><span class="s1">cls</span><span class="s3">.</span><span class="s1">ALWAYS_EXCLUDE</span><span class="s3">, *</span><span class="s1">exclude</span><span class="s3">),</span>
                <span class="s1">cls</span><span class="s3">.</span><span class="s1">_build_filter</span><span class="s3">(*</span><span class="s1">include</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_find_iter</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">where</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">, </span><span class="s1">include</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">) </span><span class="s1">-&gt; StrIter</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_build_filter</span><span class="s3">(*</span><span class="s1">patterns</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; _Filter</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a list of patterns, return a callable that will be true only if 
        the input matches at least one of the patterns. 
        &quot;&quot;&quot;</span>
        <span class="s2">return lambda </span><span class="s1">name</span><span class="s3">: </span><span class="s1">any</span><span class="s3">(</span><span class="s1">fnmatchcase</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">pat</span><span class="s3">) </span><span class="s2">for </span><span class="s1">pat </span><span class="s2">in </span><span class="s1">patterns</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">PackageFinder</span><span class="s3">(</span><span class="s1">_Finder</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a list of all Python packages found within a directory 
    &quot;&quot;&quot;</span>

    <span class="s1">ALWAYS_EXCLUDE </span><span class="s3">= (</span><span class="s5">&quot;ez_setup&quot;</span><span class="s3">, </span><span class="s5">&quot;*__pycache__&quot;</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_find_iter</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">where</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">, </span><span class="s1">include</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">) </span><span class="s1">-&gt; StrIter</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot; 
        All the packages found in 'where' that pass the 'include' filter, but 
        not the 'exclude' filter. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">root</span><span class="s3">, </span><span class="s1">dirs</span><span class="s3">, </span><span class="s1">files </span><span class="s2">in </span><span class="s1">os</span><span class="s3">.</span><span class="s1">walk</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">where</span><span class="s3">), </span><span class="s1">followlinks</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
            <span class="s4"># Copy dirs to iterate over it, then empty dirs.</span>
            <span class="s1">all_dirs </span><span class="s3">= </span><span class="s1">dirs</span><span class="s3">[:]</span>
            <span class="s1">dirs</span><span class="s3">[:] = []</span>

            <span class="s2">for </span><span class="s1">dir </span><span class="s2">in </span><span class="s1">all_dirs</span><span class="s3">:</span>
                <span class="s1">full_path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">root</span><span class="s3">, </span><span class="s1">dir</span><span class="s3">)</span>
                <span class="s1">rel_path </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">relpath</span><span class="s3">(</span><span class="s1">full_path</span><span class="s3">, </span><span class="s1">where</span><span class="s3">)</span>
                <span class="s1">package </span><span class="s3">= </span><span class="s1">rel_path</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">sep</span><span class="s3">, </span><span class="s5">'.'</span><span class="s3">)</span>

                <span class="s4"># Skip directory trees that are not valid packages</span>
                <span class="s2">if </span><span class="s5">'.' </span><span class="s2">in </span><span class="s1">dir </span><span class="s2">or not </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_looks_like_package</span><span class="s3">(</span><span class="s1">full_path</span><span class="s3">, </span><span class="s1">package</span><span class="s3">):</span>
                    <span class="s2">continue</span>

                <span class="s4"># Should this package be included?</span>
                <span class="s2">if </span><span class="s1">include</span><span class="s3">(</span><span class="s1">package</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">exclude</span><span class="s3">(</span><span class="s1">package</span><span class="s3">):</span>
                    <span class="s2">yield </span><span class="s1">package</span>

                <span class="s4"># Keep searching subdirectories, as there may be more packages</span>
                <span class="s4"># down there, even if the parent was excluded.</span>
                <span class="s1">dirs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_looks_like_package</span><span class="s3">(</span><span class="s1">path</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">_package_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Does a directory look like a package?&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">path</span><span class="s3">, </span><span class="s5">'__init__.py'</span><span class="s3">))</span>


<span class="s2">class </span><span class="s1">PEP420PackageFinder</span><span class="s3">(</span><span class="s1">PackageFinder</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_looks_like_package</span><span class="s3">(</span><span class="s1">_path</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">_package_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">ModuleFinder</span><span class="s3">(</span><span class="s1">_Finder</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Find isolated Python modules. 
    This function will **not** recurse subdirectories. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">_find_iter</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">where</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">, </span><span class="s1">include</span><span class="s3">: </span><span class="s1">_Filter</span><span class="s3">) </span><span class="s1">-&gt; StrIter</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">glob</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">where</span><span class="s3">, </span><span class="s5">&quot;*.py&quot;</span><span class="s3">)):</span>
            <span class="s1">module</span><span class="s3">, </span><span class="s1">_ext </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">splitext</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">file</span><span class="s3">))</span>

            <span class="s2">if not </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">_looks_like_module</span><span class="s3">(</span><span class="s1">module</span><span class="s3">):</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">include</span><span class="s3">(</span><span class="s1">module</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">exclude</span><span class="s3">(</span><span class="s1">module</span><span class="s3">):</span>
                <span class="s2">yield </span><span class="s1">module</span>

    <span class="s1">_looks_like_module </span><span class="s3">= </span><span class="s1">staticmethod</span><span class="s3">(</span><span class="s1">_valid_name</span><span class="s3">)</span>


<span class="s4"># We have to be extra careful in the case of flat layout to not include files</span>
<span class="s4"># and directories not meant for distribution (e.g. tool-related)</span>


<span class="s2">class </span><span class="s1">FlatLayoutPackageFinder</span><span class="s3">(</span><span class="s1">PEP420PackageFinder</span><span class="s3">):</span>
    <span class="s1">_EXCLUDE </span><span class="s3">= (</span>
        <span class="s5">&quot;ci&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;bin&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;doc&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;docs&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;documentation&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;manpages&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;news&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;changelog&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;test&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;tests&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;unit_test&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;unit_tests&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;example&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;examples&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;scripts&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;tools&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;util&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;utils&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;python&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;build&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;dist&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;venv&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;env&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;requirements&quot;</span><span class="s3">,</span>
        <span class="s4"># ---- Task runners / Build tools ----</span>
        <span class="s5">&quot;tasks&quot;</span><span class="s3">,  </span><span class="s4"># invoke</span>
        <span class="s5">&quot;fabfile&quot;</span><span class="s3">,  </span><span class="s4"># fabric</span>
        <span class="s5">&quot;site_scons&quot;</span><span class="s3">,  </span><span class="s4"># SCons</span>
        <span class="s4"># ---- Other tools ----</span>
        <span class="s5">&quot;benchmark&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;benchmarks&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;exercise&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;exercises&quot;</span><span class="s3">,</span>
        <span class="s4"># ---- Hidden directories/Private packages ----</span>
        <span class="s5">&quot;[._]*&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">DEFAULT_EXCLUDE </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">chain_iter</span><span class="s3">((</span><span class="s1">p</span><span class="s3">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">p</span><span class="s2">}</span><span class="s5">.*&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">_EXCLUDE</span><span class="s3">))</span>
    <span class="s5">&quot;&quot;&quot;Reserved package names&quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_looks_like_package</span><span class="s3">(</span><span class="s1">_path</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">, </span><span class="s1">package_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">names </span><span class="s3">= </span><span class="s1">package_name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">'.'</span><span class="s3">)</span>
        <span class="s4"># Consider PEP 561</span>
        <span class="s1">root_pkg_is_valid </span><span class="s3">= </span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">isidentifier</span><span class="s3">() </span><span class="s2">or </span><span class="s1">names</span><span class="s3">[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;-stubs&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">root_pkg_is_valid </span><span class="s2">and </span><span class="s1">all</span><span class="s3">(</span><span class="s1">name</span><span class="s3">.</span><span class="s1">isidentifier</span><span class="s3">() </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:])</span>


<span class="s2">class </span><span class="s1">FlatLayoutModuleFinder</span><span class="s3">(</span><span class="s1">ModuleFinder</span><span class="s3">):</span>
    <span class="s1">DEFAULT_EXCLUDE </span><span class="s3">= (</span>
        <span class="s5">&quot;setup&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;conftest&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;test&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;tests&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;example&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;examples&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;build&quot;</span><span class="s3">,</span>
        <span class="s4"># ---- Task runners ----</span>
        <span class="s5">&quot;toxfile&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;noxfile&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;pavement&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;dodo&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;tasks&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;fabfile&quot;</span><span class="s3">,</span>
        <span class="s4"># ---- Other tools ----</span>
        <span class="s5">&quot;[Ss][Cc]onstruct&quot;</span><span class="s3">,  </span><span class="s4"># SCons</span>
        <span class="s5">&quot;conanfile&quot;</span><span class="s3">,  </span><span class="s4"># Connan: C/C++ build tool</span>
        <span class="s5">&quot;manage&quot;</span><span class="s3">,  </span><span class="s4"># Django</span>
        <span class="s5">&quot;benchmark&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;benchmarks&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;exercise&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;exercises&quot;</span><span class="s3">,</span>
        <span class="s4"># ---- Hidden files/Private modules ----</span>
        <span class="s5">&quot;[._]*&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s5">&quot;&quot;&quot;Reserved top-level module names&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_find_packages_within</span><span class="s3">(</span><span class="s1">root_pkg</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">pkg_dir</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s1">nested </span><span class="s3">= </span><span class="s1">PEP420PackageFinder</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">pkg_dir</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">root_pkg</span><span class="s3">] + [</span><span class="s5">&quot;.&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">((</span><span class="s1">root_pkg</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">nested</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">ConfigDiscovery</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Fill-in metadata and options that can be automatically derived 
    (from other metadata/options, the file system or conventions) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">distribution</span><span class="s3">: </span><span class="s5">&quot;Distribution&quot;</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist </span><span class="s3">= </span><span class="s1">distribution</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_called </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_disabled </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_ext_modules </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_disable</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Internal API to disable automatic discovery&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_disabled </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_ignore_ext_modules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Internal API to disregard ext_modules. 
 
        Normally auto-discovery would not be triggered if ``ext_modules`` are set 
        (this is done for backward compatibility with existing packages relying on 
        ``setup.py`` or ``setup.cfg``). However, ``setuptools`` can call this function 
        to ignore given ``ext_modules`` and proceed with the auto-discovery if 
        ``packages`` and ``py_modules`` are not given (e.g. when using pyproject.toml 
        metadata). 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_ext_modules </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_root_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _Path</span><span class="s3">:</span>
        <span class="s4"># The best is to wait until `src_root` is set in dist, before using _root_dir.</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">src_root </span><span class="s2">or </span><span class="s1">os</span><span class="s3">.</span><span class="s1">curdir</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_package_dir</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">package_dir </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">{}</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">package_dir</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">force</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">ignore_ext_modules</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Automatically discover missing configuration fields 
        and modifies the given ``distribution`` object in-place. 
 
        Note that by default this will only have an effect the first time the 
        ``ConfigDiscovery`` object is called. 
 
        To repeatedly invoke automatic discovery (e.g. when the project 
        directory changes), please use ``force=True`` (or create a new 
        ``ConfigDiscovery`` instance). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">force </span><span class="s2">is False and </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_called </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_disabled</span><span class="s3">):</span>
            <span class="s4"># Avoid overhead of multiple calls</span>
            <span class="s2">return</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_package_layout</span><span class="s3">(</span><span class="s1">ignore_ext_modules</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">analyse_name</span><span class="s3">()  </span><span class="s4"># depends on ``packages`` and ``py_modules``</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_called </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_explicitly_specified</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ignore_ext_modules</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;``True`` if the user has specified some form of package/module listing&quot;&quot;&quot;</span>
        <span class="s1">ignore_ext_modules </span><span class="s3">= </span><span class="s1">ignore_ext_modules </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_skip_ext_modules</span>
        <span class="s1">ext_modules </span><span class="s3">= </span><span class="s2">not </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">ext_modules </span><span class="s2">is None or </span><span class="s1">ignore_ext_modules</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">ext_modules</span>
            <span class="s2">or </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">, </span><span class="s5">&quot;configuration&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">configuration</span>
            <span class="s4"># ^ Some projects use numpy.distutils.misc_util.Configuration</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_analyse_package_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ignore_ext_modules</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_explicitly_specified</span><span class="s3">(</span><span class="s1">ignore_ext_modules</span><span class="s3">):</span>
            <span class="s4"># For backward compatibility, just try to find modules/packages</span>
            <span class="s4"># when nothing is given</span>
            <span class="s2">return True</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
            <span class="s5">&quot;No `packages` or `py_modules` configuration, performing &quot;</span>
            <span class="s5">&quot;automatic discovery.&quot;</span>
        <span class="s3">)</span>

        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_explicit_layout</span><span class="s3">()</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_src_layout</span><span class="s3">()</span>
            <span class="s4"># flat-layout is the trickiest for discovery so it should be last</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_flat_layout</span><span class="s3">()</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_analyse_explicit_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;The user can explicitly give a package layout via ``package_dir``&quot;&quot;&quot;</span>
        <span class="s1">package_dir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_package_dir</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s4"># don't modify directly</span>
        <span class="s1">package_dir</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s5">&quot;&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)  </span><span class="s4"># This falls under the &quot;src-layout&quot; umbrella</span>
        <span class="s1">root_dir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span>

        <span class="s2">if not </span><span class="s1">package_dir</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;`explicit-layout` detected -- analysing </span><span class="s2">{</span><span class="s1">package_dir</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">pkgs </span><span class="s3">= </span><span class="s1">chain_iter</span><span class="s3">(</span>
            <span class="s1">_find_packages_within</span><span class="s3">(</span><span class="s1">pkg</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">root_dir</span><span class="s3">, </span><span class="s1">parent_dir</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">pkg</span><span class="s3">, </span><span class="s1">parent_dir </span><span class="s2">in </span><span class="s1">package_dir</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">pkgs</span><span class="s3">)</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;discovered packages -- </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_analyse_src_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Try to find all packages or modules under the ``src`` directory 
        (or anything pointed by ``package_dir[&quot;&quot;]``). 
 
        The &quot;src-layout&quot; is relatively safe for automatic discovery. 
        We assume that everything within is meant to be included in the 
        distribution. 
 
        If ``package_dir[&quot;&quot;]`` is not given, but the ``src`` directory exists, 
        this function will set ``package_dir[&quot;&quot;] = &quot;src&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s1">package_dir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_package_dir</span>
        <span class="s1">src_dir </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span><span class="s3">, </span><span class="s1">package_dir</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;&quot;</span><span class="s3">, </span><span class="s5">&quot;src&quot;</span><span class="s3">))</span>
        <span class="s2">if not </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isdir</span><span class="s3">(</span><span class="s1">src_dir</span><span class="s3">):</span>
            <span class="s2">return False</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;`src-layout` detected -- analysing </span><span class="s2">{</span><span class="s1">src_dir</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">package_dir</span><span class="s3">.</span><span class="s1">setdefault</span><span class="s3">(</span><span class="s5">&quot;&quot;</span><span class="s3">, </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">src_dir</span><span class="s3">))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">package_dir </span><span class="s3">= </span><span class="s1">package_dir  </span><span class="s4"># persist eventual modifications</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages </span><span class="s3">= </span><span class="s1">PEP420PackageFinder</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">src_dir</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules </span><span class="s3">= </span><span class="s1">ModuleFinder</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">src_dir</span><span class="s3">)</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;discovered packages -- </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;discovered py_modules -- </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_analyse_flat_layout</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s0">&quot;&quot;&quot;Try to find all packages and modules under the project root. 
 
        Since the ``flat-layout`` is more dangerous in terms of accidentally including 
        extra files/directories, this function is more conservative and will raise an 
        error if multiple packages or modules are found. 
 
        This assumes that multi-package dists are uncommon and refuse to support that 
        use case in order to be able to prevent unintended errors. 
        &quot;&quot;&quot;</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;`flat-layout` detected -- analysing </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_flat_packages</span><span class="s3">() </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_analyse_flat_modules</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_analyse_flat_packages</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages </span><span class="s3">= </span><span class="s1">FlatLayoutPackageFinder</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span><span class="s3">)</span>
        <span class="s1">top_level </span><span class="s3">= </span><span class="s1">remove_nested_packages</span><span class="s3">(</span><span class="s1">remove_stubs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s3">))</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;discovered packages -- </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_no_accidental_inclusion</span><span class="s3">(</span><span class="s1">top_level</span><span class="s3">, </span><span class="s5">&quot;packages&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">top_level</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_analyse_flat_modules</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules </span><span class="s3">= </span><span class="s1">FlatLayoutModuleFinder</span><span class="s3">.</span><span class="s1">find</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span><span class="s3">)</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;discovered py_modules -- </span><span class="s2">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_no_accidental_inclusion</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules</span><span class="s3">, </span><span class="s5">&quot;modules&quot;</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">py_modules</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ensure_no_accidental_inclusion</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">detected</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">kind</span><span class="s3">: </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">detected</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">from </span><span class="s1">inspect </span><span class="s2">import </span><span class="s1">cleandoc</span>

            <span class="s2">from </span><span class="s1">setuptools</span><span class="s3">.</span><span class="s1">errors </span><span class="s2">import </span><span class="s1">PackageDiscoveryError</span>

            <span class="s1">msg </span><span class="s3">= </span><span class="s5">f&quot;&quot;&quot;Multiple top-level </span><span class="s2">{</span><span class="s1">kind</span><span class="s2">} </span><span class="s5">discovered in a flat-layout: </span><span class="s2">{</span><span class="s1">detected</span><span class="s2">}</span><span class="s5">.</span>

            <span class="s5">To avoid accidental inclusion of unwanted files or directories,</span>
            <span class="s5">setuptools will not proceed with this build.</span>

            <span class="s5">If you are trying to create a single distribution with multiple </span><span class="s2">{</span><span class="s1">kind</span><span class="s2">}</span>
            <span class="s5">on purpose, you should not rely on automatic discovery.</span>
            <span class="s5">Instead, consider the following options:</span>

            <span class="s5">1. set up custom discovery (`find` directive with `include` or `exclude`)</span>
            <span class="s5">2. use a `src-layout`</span>
            <span class="s5">3. explicitly set `py_modules` or `packages` with a list of names</span>

            <span class="s5">To find more information, look for &quot;package discovery&quot; on setuptools docs.</span>
            <span class="s5">&quot;&quot;&quot;</span>
            <span class="s2">raise </span><span class="s1">PackageDiscoveryError</span><span class="s3">(</span><span class="s1">cleandoc</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">analyse_name</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;The packages/modules are the essential contribution of the author. 
        Therefore the name of the distribution can be derived from them. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">name </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">name</span><span class="s3">:</span>
            <span class="s4"># get_name() is not reliable (can return &quot;UNKNOWN&quot;)</span>
            <span class="s2">return None</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">&quot;No `name` configuration, performing automatic discovery&quot;</span><span class="s3">)</span>

        <span class="s1">name </span><span class="s3">= (</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_find_name_single_package_or_module</span><span class="s3">()</span>
            <span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_find_name_from_packages</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">name </span><span class="s3">= </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">_find_name_single_package_or_module</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Exactly one module or package&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s3">(</span><span class="s5">'packages'</span><span class="s3">, </span><span class="s5">'py_modules'</span><span class="s3">):</span>
            <span class="s1">items </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">, </span><span class="s1">field</span><span class="s3">, </span><span class="s2">None</span><span class="s3">) </span><span class="s2">or </span><span class="s3">[]</span>
            <span class="s2">if </span><span class="s1">items </span><span class="s2">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">) == </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;Single module/package detected, name: </span><span class="s2">{</span><span class="s1">items</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">items</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_find_name_from_packages</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
        <span class="s0">&quot;&quot;&quot;Try to find the root package that is not a PEP 420 namespace&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s3">:</span>
            <span class="s2">return None</span>

        <span class="s1">packages </span><span class="s3">= </span><span class="s1">remove_stubs</span><span class="s3">(</span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">packages</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s1">len</span><span class="s3">))</span>
        <span class="s1">package_dir </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">.</span><span class="s1">package_dir </span><span class="s2">or </span><span class="s3">{}</span>

        <span class="s1">parent_pkg </span><span class="s3">= </span><span class="s1">find_parent_package</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">, </span><span class="s1">package_dir</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_root_dir</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">parent_pkg</span><span class="s3">:</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">f&quot;Common parent package detected, name: </span><span class="s2">{</span><span class="s1">parent_pkg</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">parent_pkg</span>

        <span class="s1">log</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;No parent package detected, impossible to derive `name`&quot;</span><span class="s3">)</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">remove_nested_packages</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Remove nested packages from a list of packages. 
 
    &gt;&gt;&gt; remove_nested_packages([&quot;a&quot;, &quot;a.b1&quot;, &quot;a.b2&quot;, &quot;a.b1.c1&quot;]) 
    ['a'] 
    &gt;&gt;&gt; remove_nested_packages([&quot;a&quot;, &quot;b&quot;, &quot;c.d&quot;, &quot;c.d.e.f&quot;, &quot;g.h&quot;, &quot;a.a1&quot;]) 
    ['a', 'b', 'c.d', 'g.h'] 
    &quot;&quot;&quot;</span>
    <span class="s1">pkgs </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s1">len</span><span class="s3">)</span>
    <span class="s1">top_level </span><span class="s3">= </span><span class="s1">pkgs</span><span class="s3">[:]</span>
    <span class="s1">size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pkgs</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">pkgs</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">name</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">other</span><span class="s2">}</span><span class="s5">.&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">other </span><span class="s2">in </span><span class="s1">top_level</span><span class="s3">):</span>
            <span class="s1">top_level</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">size </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">top_level</span>


<span class="s2">def </span><span class="s1">remove_stubs</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]) </span><span class="s1">-&gt; List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Remove type stubs (:pep:`561`) from a list of packages. 
 
    &gt;&gt;&gt; remove_stubs([&quot;a&quot;, &quot;a.b&quot;, &quot;a-stubs&quot;, &quot;a-stubs.b.c&quot;, &quot;b&quot;, &quot;c-stubs&quot;]) 
    ['a', 'a.b', 'b'] 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">[</span><span class="s1">pkg </span><span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">packages </span><span class="s2">if not </span><span class="s1">pkg</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">].</span><span class="s1">endswith</span><span class="s3">(</span><span class="s5">&quot;-stubs&quot;</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">find_parent_package</span><span class="s3">(</span>
    <span class="s1">packages</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">package_dir</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">], </span><span class="s1">root_dir</span><span class="s3">: </span><span class="s1">_Path</span>
<span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Find the parent package that is not a namespace.&quot;&quot;&quot;</span>
    <span class="s1">packages </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s1">len</span><span class="s3">)</span>
    <span class="s1">common_ancestors </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">startswith</span><span class="s3">(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.&quot;</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">packages</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:]):</span>
            <span class="s4"># Since packages are sorted by length, this condition is able</span>
            <span class="s4"># to find a list of all common ancestors.</span>
            <span class="s4"># When there is divergence (e.g. multiple root packages)</span>
            <span class="s4"># the list will be empty</span>
            <span class="s2">break</span>
        <span class="s1">common_ancestors</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">common_ancestors</span><span class="s3">:</span>
        <span class="s1">pkg_path </span><span class="s3">= </span><span class="s1">find_package_path</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">package_dir</span><span class="s3">, </span><span class="s1">root_dir</span><span class="s3">)</span>
        <span class="s1">init </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">pkg_path</span><span class="s3">, </span><span class="s5">&quot;__init__.py&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">isfile</span><span class="s3">(</span><span class="s1">init</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">find_package_path</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">package_dir</span><span class="s3">: </span><span class="s1">Mapping</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">], </span><span class="s1">root_dir</span><span class="s3">: </span><span class="s1">_Path</span>
<span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Given a package name, return the path where it should be found on 
    disk, considering the ``package_dir`` option. 
 
    &gt;&gt;&gt; path = find_package_path(&quot;my.pkg&quot;, {&quot;&quot;: &quot;root/is/nested&quot;}, &quot;.&quot;) 
    &gt;&gt;&gt; path.replace(os.sep, &quot;/&quot;) 
    './root/is/nested/my/pkg' 
 
    &gt;&gt;&gt; path = find_package_path(&quot;my.pkg&quot;, {&quot;my&quot;: &quot;root/is/nested&quot;}, &quot;.&quot;) 
    &gt;&gt;&gt; path.replace(os.sep, &quot;/&quot;) 
    './root/is/nested/pkg' 
 
    &gt;&gt;&gt; path = find_package_path(&quot;my.pkg&quot;, {&quot;my.pkg&quot;: &quot;root/is/nested&quot;}, &quot;.&quot;) 
    &gt;&gt;&gt; path.replace(os.sep, &quot;/&quot;) 
    './root/is/nested' 
 
    &gt;&gt;&gt; path = find_package_path(&quot;other.pkg&quot;, {&quot;my.pkg&quot;: &quot;root/is/nested&quot;}, &quot;.&quot;) 
    &gt;&gt;&gt; path.replace(os.sep, &quot;/&quot;) 
    './other/pkg' 
    &quot;&quot;&quot;</span>
    <span class="s1">parts </span><span class="s3">= </span><span class="s1">name</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">), </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">):</span>
        <span class="s4"># Look backwards, the most specific package_dir first</span>
        <span class="s1">partial_name </span><span class="s3">= </span><span class="s5">&quot;.&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">parts</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">partial_name </span><span class="s2">in </span><span class="s1">package_dir</span><span class="s3">:</span>
            <span class="s1">parent </span><span class="s3">= </span><span class="s1">package_dir</span><span class="s3">[</span><span class="s1">partial_name</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">root_dir</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, *</span><span class="s1">parts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:])</span>

    <span class="s1">parent </span><span class="s3">= </span><span class="s1">package_dir</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s5">&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">root_dir</span><span class="s3">, *</span><span class="s1">parent</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;/&quot;</span><span class="s3">), *</span><span class="s1">parts</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">construct_package_dir</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">: </span><span class="s1">List</span><span class="s3">[</span><span class="s1">str</span><span class="s3">], </span><span class="s1">package_path</span><span class="s3">: </span><span class="s1">_Path</span><span class="s3">) </span><span class="s1">-&gt; Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">]:</span>
    <span class="s1">parent_pkgs </span><span class="s3">= </span><span class="s1">remove_nested_packages</span><span class="s3">(</span><span class="s1">packages</span><span class="s3">)</span>
    <span class="s1">prefix </span><span class="s3">= </span><span class="s1">Path</span><span class="s3">(</span><span class="s1">package_path</span><span class="s3">).</span><span class="s1">parts</span>
    <span class="s2">return </span><span class="s3">{</span><span class="s1">pkg</span><span class="s3">: </span><span class="s5">&quot;/&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">([*</span><span class="s1">prefix</span><span class="s3">, *</span><span class="s1">pkg</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)]) </span><span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">parent_pkgs</span><span class="s3">}</span>
</pre>
</body>
</html>